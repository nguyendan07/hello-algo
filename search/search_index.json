{"config":{"lang":["vi"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hello Algo","text":""},{"location":"#hello-algo","title":"Hello Algo","text":"<p>Kh\u00f3a h\u1ecdc nhanh v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n v\u1edbi minh h\u1ecda \u0111\u1ed9ng v\u00e0 m\u00e3 ngu\u1ed3n s\u1eb5n s\u00e0ng s\u1eed d\u1ee5ng</p> <p>Dive in</p>"},{"location":"chapter_appendix/","title":"Appendix","text":""},{"location":"chapter_appendix/#appendix","title":"Appendix","text":""},{"location":"chapter_appendix/contribution/","title":"16.2 Contributing","text":""},{"location":"chapter_appendix/contribution/#contributing","title":"Contributing","text":"<p>Due to the limited abilities of the author, some omissions and errors are inevitable in this book. Please understand. If you discover any typos, broken links, missing content, textual ambiguities, unclear explanations, or unreasonable text structures, please assist us in making corrections to provide readers with better quality learning resources.</p> <p>The GitHub IDs of all contributors will be displayed on the repository, web, and PDF versions of the homepage of this book to thank them for their selfless contributions to the open-source community.</p> <p>The charm of open source</p> <p>The interval between two printings of a paper book is often long, making content updates very inconvenient.</p> <p>In this open-source book, however, the content update cycle is shortened to just a few days or even hours.</p>"},{"location":"chapter_appendix/contribution/#content-fine-tuning","title":"Content fine-tuning","text":"<p>As shown in the figure below, there is an \"edit icon\" in the upper right corner of each page. You can follow these steps to modify text or code.</p> <ol> <li>Click the \"edit icon\". If prompted to \"fork this repository\", please agree to do so.</li> <li>Modify the Markdown source file content, check the accuracy of the content, and try to keep the formatting consistent.</li> <li>Fill in the modification description at the bottom of the page, then click the \"Propose file change\" button. After the page redirects, click the \"Create pull request\" button to initiate the pull request.</li> </ol> <p></p> <p>Figures cannot be directly modified and require the creation of a new Issue or a comment to describe the problem. We will redraw and replace the figures as soon as possible.</p>"},{"location":"chapter_appendix/contribution/#content-creation","title":"Content creation","text":"<p>If you are interested in participating in this open-source project, including translating code into other programming languages or expanding article content, then the following Pull Request workflow needs to be implemented.</p> <ol> <li>Log in to GitHub and Fork the code repository of this book to your personal account.</li> <li>Go to your Forked repository web page and use the <code>git clone</code> command to clone the repository to your local machine.</li> <li>Create content locally and perform complete tests to verify the correctness of the code.</li> <li>Commit the changes made locally, then push them to the remote repository.</li> <li>Refresh the repository webpage and click the \"Create pull request\" button to initiate the pull request.</li> </ol>"},{"location":"chapter_appendix/contribution/#docker-deployment","title":"Docker deployment","text":"<p>In the <code>hello-algo</code> root directory, execute the following Docker script to access the project at <code>http://localhost:8000</code>:</p> <pre><code>docker-compose up -d\n</code></pre> <p>Use the following command to remove the deployment:</p> <pre><code>docker-compose down\n</code></pre>"},{"location":"chapter_appendix/installation/","title":"16.1 Installation","text":""},{"location":"chapter_appendix/installation/#installation","title":"Installation","text":""},{"location":"chapter_appendix/installation/#install-ide","title":"Install IDE","text":"<p>We recommend using the open-source, lightweight VS Code as your local Integrated Development Environment (IDE). Visit the VS Code official website and choose the version of VS Code appropriate for your operating system to download and install.</p> <p></p> <p>VS Code has a powerful extension ecosystem, supporting the execution and debugging of most programming languages. For example, after installing the \"Python Extension Pack,\" you can debug Python code. The installation steps are shown in the figure below.</p> <p></p>"},{"location":"chapter_appendix/installation/#install-language-environments","title":"Install language environments","text":""},{"location":"chapter_appendix/installation/#python-environment","title":"Python environment","text":"<ol> <li>Download and install Miniconda3, requiring Python 3.10 or newer.</li> <li>In the VS Code extension marketplace, search for <code>python</code> and install the Python Extension Pack.</li> <li>(Optional) Enter <code>pip install black</code> in the command line to install the code formatting tool.</li> </ol>"},{"location":"chapter_appendix/installation/#cc-environment","title":"C/C++ environment","text":"<ol> <li>Windows systems need to install MinGW (Configuration tutorial); MacOS comes with Clang, so no installation is necessary.</li> <li>In the VS Code extension marketplace, search for <code>c++</code> and install the C/C++ Extension Pack.</li> <li>(Optional) Open the Settings page, search for the <code>Clang_format_fallback Style</code> code formatting option, and set it to <code>{ BasedOnStyle: Microsoft, BreakBeforeBraces: Attach }</code>.</li> </ol>"},{"location":"chapter_appendix/installation/#java-environment","title":"Java environment","text":"<ol> <li>Download and install OpenJDK (version must be &gt; JDK 9).</li> <li>In the VS Code extension marketplace, search for <code>java</code> and install the Extension Pack for Java.</li> </ol>"},{"location":"chapter_appendix/installation/#c-environment","title":"C# environment","text":"<ol> <li>Download and install .Net 8.0.</li> <li>In the VS Code extension marketplace, search for <code>C# Dev Kit</code> and install the C# Dev Kit (Configuration tutorial).</li> <li>You can also use Visual Studio (Installation tutorial).</li> </ol>"},{"location":"chapter_appendix/installation/#go-environment","title":"Go environment","text":"<ol> <li>Download and install go.</li> <li>In the VS Code extension marketplace, search for <code>go</code> and install Go.</li> <li>Press <code>Ctrl + Shift + P</code> to call up the command bar, enter go, choose <code>Go: Install/Update Tools</code>, select all and install.</li> </ol>"},{"location":"chapter_appendix/installation/#swift-environment","title":"Swift environment","text":"<ol> <li>Download and install Swift.</li> <li>In the VS Code extension marketplace, search for <code>swift</code> and install Swift for Visual Studio Code.</li> </ol>"},{"location":"chapter_appendix/installation/#javascript-environment","title":"JavaScript environment","text":"<ol> <li>Download and install Node.js.</li> <li>(Optional) In the VS Code extension marketplace, search for <code>Prettier</code> and install the code formatting tool.</li> </ol>"},{"location":"chapter_appendix/installation/#typescript-environment","title":"TypeScript environment","text":"<ol> <li>Follow the same installation steps as the JavaScript environment.</li> <li>Install TypeScript Execute (tsx).</li> <li>In the VS Code extension marketplace, search for <code>typescript</code> and install Pretty TypeScript Errors.</li> </ol>"},{"location":"chapter_appendix/installation/#dart-environment","title":"Dart environment","text":"<ol> <li>Download and install Dart.</li> <li>In the VS Code extension marketplace, search for <code>dart</code> and install Dart.</li> </ol>"},{"location":"chapter_appendix/installation/#rust-environment","title":"Rust environment","text":"<ol> <li>Download and install Rust.</li> <li>In the VS Code extension marketplace, search for <code>rust</code> and install rust-analyzer.</li> </ol>"},{"location":"chapter_appendix/terminology/","title":"16.3 Terminology","text":""},{"location":"chapter_appendix/terminology/#glossary","title":"Glossary","text":"<p>The table below lists the important terms that appear in the book, and it is worth noting the following points.</p> <ul> <li>It is recommended to remember the English names of the terms to facilitate reading English literature.</li> <li>Some terms have different names in Simplified and Traditional Chinese.</li> </ul> <p> Table  \u00a0 Important Terms in Data Structures and Algorithms </p> English \u7b80\u4f53\u4e2d\u6587 \u7e41\u4f53\u4e2d\u6587 algorithm \u7b97\u6cd5 \u6f14\u7b97\u6cd5 data structure \u6570\u636e\u7ed3\u6784 \u8cc7\u6599\u7d50\u69cb code \u4ee3\u7801 \u7a0b\u5f0f\u78bc file \u6587\u4ef6 \u6a94\u6848 function \u51fd\u6570 \u51fd\u5f0f method \u65b9\u6cd5 \u65b9\u6cd5 variable \u53d8\u91cf \u8b8a\u6578 asymptotic complexity analysis \u6e10\u8fd1\u590d\u6742\u5ea6\u5206\u6790 \u6f38\u8fd1\u8907\u96dc\u5ea6\u5206\u6790 time complexity \u65f6\u95f4\u590d\u6742\u5ea6 \u6642\u9593\u8907\u96dc\u5ea6 space complexity \u7a7a\u95f4\u590d\u6742\u5ea6 \u7a7a\u9593\u8907\u96dc\u5ea6 loop \u5faa\u73af \u8ff4\u5708 iteration \u8fed\u4ee3 \u8fed\u4ee3 recursion \u9012\u5f52 \u905e\u8ff4 tail recursion \u5c3e\u9012\u5f52 \u5c3e\u905e\u8ff4 recursion tree \u9012\u5f52\u6811 \u905e\u8ff4\u6a39 big-\\(O\\) notation \u5927 \\(O\\) \u8bb0\u53f7 \u5927 \\(O\\) \u8a18\u865f asymptotic upper bound \u6e10\u8fd1\u4e0a\u754c \u6f38\u8fd1\u4e0a\u754c sign-magnitude \u539f\u7801 \u539f\u78bc 1\u2019s complement \u53cd\u7801 \u4e00\u88dc\u6578 2\u2019s complement \u8865\u7801 \u4e8c\u88dc\u6578 array \u6570\u7ec4 \u9663\u5217 index \u7d22\u5f15 \u7d22\u5f15 linked list \u94fe\u8868 \u93c8\u7d50\u4e32\u5217 linked list node, list node \u94fe\u8868\u8282\u70b9 \u93c8\u7d50\u4e32\u5217\u7bc0\u9ede head node \u5934\u8282\u70b9 \u982d\u7bc0\u9ede tail node \u5c3e\u8282\u70b9 \u5c3e\u7bc0\u9ede list \u5217\u8868 \u4e32\u5217 dynamic array \u52a8\u6001\u6570\u7ec4 \u52d5\u614b\u9663\u5217 hard disk \u786c\u76d8 \u786c\u789f random-access memory (RAM) \u5185\u5b58 \u8a18\u61b6\u9ad4 cache memory \u7f13\u5b58 \u5feb\u53d6 cache miss \u7f13\u5b58\u672a\u547d\u4e2d \u5feb\u53d6\u672a\u547d\u4e2d cache hit rate \u7f13\u5b58\u547d\u4e2d\u7387 \u5feb\u53d6\u547d\u4e2d\u7387 stack \u6808 \u5806\u758a top of the stack \u6808\u9876 \u5806\u758a\u9802 bottom of the stack \u6808\u5e95 \u5806\u758a\u5e95 queue \u961f\u5217 \u4f47\u5217 double-ended queue \u53cc\u5411\u961f\u5217 \u96d9\u5411\u4f47\u5217 front of the queue \u961f\u9996 \u4f47\u5217\u9996 rear of the queue \u961f\u5c3e \u4f47\u5217\u5c3e hash table \u54c8\u5e0c\u8868 \u96dc\u6e4a\u8868 hash set \u54c8\u5e0c\u96c6\u5408 \u96dc\u6e4a\u96c6\u5408 bucket \u6876 \u6876 hash function \u54c8\u5e0c\u51fd\u6570 \u96dc\u6e4a\u51fd\u5f0f hash collision \u54c8\u5e0c\u51b2\u7a81 \u96dc\u6e4a\u885d\u7a81 load factor \u8d1f\u8f7d\u56e0\u5b50 \u8ca0\u8f09\u56e0\u5b50 separate chaining \u94fe\u5f0f\u5730\u5740 \u93c8\u7d50\u4f4d\u5740 open addressing \u5f00\u653e\u5bfb\u5740 \u958b\u653e\u5b9a\u5740 linear probing \u7ebf\u6027\u63a2\u6d4b \u7dda\u6027\u63a2\u67e5 lazy deletion \u61d2\u5220\u9664 \u61f6\u522a\u9664 binary tree \u4e8c\u53c9\u6811 \u4e8c\u5143\u6a39 tree node \u6811\u8282\u70b9 \u6a39\u7bc0\u9ede left-child node \u5de6\u5b50\u8282\u70b9 \u5de6\u5b50\u7bc0\u9ede right-child node \u53f3\u5b50\u8282\u70b9 \u53f3\u5b50\u7bc0\u9ede parent node \u7236\u8282\u70b9 \u7236\u7bc0\u9ede left subtree \u5de6\u5b50\u6811 \u5de6\u5b50\u6a39 right subtree \u53f3\u5b50\u6811 \u53f3\u5b50\u6a39 root node \u6839\u8282\u70b9 \u6839\u7bc0\u9ede leaf node \u53f6\u8282\u70b9 \u8449\u7bc0\u9ede edge \u8fb9 \u908a level \u5c42 \u5c64 degree \u5ea6 \u5ea6 height \u9ad8\u5ea6 \u9ad8\u5ea6 depth \u6df1\u5ea6 \u6df1\u5ea6 perfect binary tree \u5b8c\u7f8e\u4e8c\u53c9\u6811 \u5b8c\u7f8e\u4e8c\u5143\u6a39 complete binary tree \u5b8c\u5168\u4e8c\u53c9\u6811 \u5b8c\u5168\u4e8c\u5143\u6a39 full binary tree \u5b8c\u6ee1\u4e8c\u53c9\u6811 \u5b8c\u6eff\u4e8c\u5143\u6a39 balanced binary tree \u5e73\u8861\u4e8c\u53c9\u6811 \u5e73\u8861\u4e8c\u5143\u6a39 binary search tree \u4e8c\u53c9\u641c\u7d22\u6811 \u4e8c\u5143\u641c\u5c0b\u6a39 AVL tree AVL \u6811 AVL \u6a39 red-black tree \u7ea2\u9ed1\u6811 \u7d05\u9ed1\u6a39 level-order traversal \u5c42\u5e8f\u904d\u5386 \u5c64\u5e8f\u8d70\u8a2a breadth-first traversal \u5e7f\u5ea6\u4f18\u5148\u904d\u5386 \u5ee3\u5ea6\u512a\u5148\u8d70\u8a2a depth-first traversal \u6df1\u5ea6\u4f18\u5148\u904d\u5386 \u6df1\u5ea6\u512a\u5148\u8d70\u8a2a binary search tree \u4e8c\u53c9\u641c\u7d22\u6811 \u4e8c\u5143\u641c\u5c0b\u6a39 balanced binary search tree \u5e73\u8861\u4e8c\u53c9\u641c\u7d22\u6811 \u5e73\u8861\u4e8c\u5143\u641c\u5c0b\u6a39 balance factor \u5e73\u8861\u56e0\u5b50 \u5e73\u8861\u56e0\u5b50 heap \u5806 \u5806\u7a4d max heap \u5927\u9876\u5806 \u5927\u9802\u5806\u7a4d min heap \u5c0f\u9876\u5806 \u5c0f\u9802\u5806\u7a4d priority queue \u4f18\u5148\u961f\u5217 \u512a\u5148\u4f47\u5217 heapify \u5806\u5316 \u5806\u7a4d\u5316 top-\\(k\\) problem Top-\\(k\\) \u95ee\u9898 Top-\\(k\\) \u554f\u984c graph \u56fe \u5716 vertex \u9876\u70b9 \u9802\u9ede undirected graph \u65e0\u5411\u56fe \u7121\u5411\u5716 directed graph \u6709\u5411\u56fe \u6709\u5411\u5716 connected graph \u8fde\u901a\u56fe \u9023\u901a\u5716 disconnected graph \u975e\u8fde\u901a\u56fe \u975e\u9023\u901a\u5716 weighted graph \u6709\u6743\u56fe \u6709\u6b0a\u5716 adjacency \u90bb\u63a5 \u9130\u63a5 path \u8def\u5f84 \u8def\u5f91 in-degree \u5165\u5ea6 \u5165\u5ea6 out-degree \u51fa\u5ea6 \u51fa\u5ea6 adjacency matrix \u90bb\u63a5\u77e9\u9635 \u9130\u63a5\u77e9\u9663 adjacency list \u90bb\u63a5\u8868 \u9130\u63a5\u8868 breadth-first search \u5e7f\u5ea6\u4f18\u5148\u641c\u7d22 \u5ee3\u5ea6\u512a\u5148\u641c\u5c0b depth-first search \u6df1\u5ea6\u4f18\u5148\u641c\u7d22 \u6df1\u5ea6\u512a\u5148\u641c\u5c0b binary search \u4e8c\u5206\u67e5\u627e \u4e8c\u5206\u641c\u5c0b searching algorithm \u641c\u7d22\u7b97\u6cd5 \u641c\u5c0b\u6f14\u7b97\u6cd5 sorting algorithm \u6392\u5e8f\u7b97\u6cd5 \u6392\u5e8f\u6f14\u7b97\u6cd5 selection sort \u9009\u62e9\u6392\u5e8f \u9078\u64c7\u6392\u5e8f bubble sort \u5192\u6ce1\u6392\u5e8f \u6ce1\u6cab\u6392\u5e8f insertion sort \u63d2\u5165\u6392\u5e8f \u63d2\u5165\u6392\u5e8f quick sort \u5feb\u901f\u6392\u5e8f \u5feb\u901f\u6392\u5e8f merge sort \u5f52\u5e76\u6392\u5e8f \u5408\u4f75\u6392\u5e8f heap sort \u5806\u6392\u5e8f \u5806\u7a4d\u6392\u5e8f bucket sort \u6876\u6392\u5e8f \u6876\u6392\u5e8f counting sort \u8ba1\u6570\u6392\u5e8f \u8a08\u6578\u6392\u5e8f radix sort \u57fa\u6570\u6392\u5e8f \u57fa\u6578\u6392\u5e8f divide and conquer \u5206\u6cbb \u5206\u6cbb hanota problem \u6c49\u8bfa\u5854\u95ee\u9898 \u6cb3\u5167\u5854\u554f\u984c backtracking algorithm \u56de\u6eaf\u7b97\u6cd5 \u56de\u6eaf\u6f14\u7b97\u6cd5 constraint \u7ea6\u675f \u7d04\u675f solution \u89e3 \u89e3 state \u72b6\u6001 \u72c0\u614b pruning \u526a\u679d \u526a\u679d permutations problem \u5168\u6392\u5217\u95ee\u9898 \u5168\u6392\u5217\u554f\u984c subset-sum problem \u5b50\u96c6\u548c\u95ee\u9898 \u5b50\u96c6\u5408\u554f\u984c \\(n\\)-queens problem \\(n\\) \u7687\u540e\u95ee\u9898 \\(n\\) \u7687\u540e\u554f\u984c dynamic programming \u52a8\u6001\u89c4\u5212 \u52d5\u614b\u898f\u5283 initial state \u521d\u59cb\u72b6\u6001 \u521d\u59cb\u72c0\u614b state-transition equation \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b \u72c0\u614b\u8f49\u79fb\u65b9\u7a0b knapsack problem \u80cc\u5305\u95ee\u9898 \u80cc\u5305\u554f\u984c edit distance problem \u7f16\u8f91\u8ddd\u79bb\u95ee\u9898 \u7de8\u8f2f\u8ddd\u96e2\u554f\u984c greedy algorithm \u8d2a\u5fc3\u7b97\u6cd5 \u8caa\u5a6a\u6f14\u7b97\u6cd5"},{"location":"chapter_array_and_linkedlist/","title":"M\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft","text":""},{"location":"chapter_array_and_linkedlist/#mang-va-danh-sach-lien-ket","title":"M\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft","text":"<p>Abstract</p> <p>Th\u1ebf gi\u1edbi c\u1ee7a c\u1ea5u tr\u00fac d\u1eef li\u1ec7u gi\u1ed1ng nh\u01b0 m\u1ed9t b\u1ee9c t\u01b0\u1eddng g\u1ea1ch v\u1eefng ch\u1eafc.</p> <p>Trong m\u1ea3ng, h\u00e3y t\u01b0\u1edfng t\u01b0\u1ee3ng c\u00e1c vi\u00ean g\u1ea1ch \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp ch\u1eb7t ch\u1ebd, m\u1ed7i vi\u00ean n\u1eb1m li\u1ec1n k\u1ec1 v\u1edbi vi\u00ean ti\u1ebfp theo, t\u1ea1o th\u00e0nh m\u1ed9t h\u00ecnh d\u1ea1ng th\u1ed1ng nh\u1ea5t. Trong khi \u0111\u00f3, trong danh s\u00e1ch li\u00ean k\u1ebft, c\u00e1c vi\u00ean g\u1ea1ch n\u00e0y ph\u00e2n t\u00e1n t\u1ef1 do, \u0111\u01b0\u1ee3c \u00f4m \u1ea5p b\u1edfi nh\u1eefng d\u00e2y leo nh\u1eb9 nh\u00e0ng k\u1ebft n\u1ed1i ch\u00fang v\u1edbi nhau.</p>"},{"location":"chapter_array_and_linkedlist/array/","title":"4.1 Array","text":""},{"location":"chapter_array_and_linkedlist/array/#mang-array","title":"M\u1ea3ng (Array)","text":"<p>M\u1ed9t m\u1ea3ng l\u00e0 m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u tuy\u1ebfn t\u00ednh ho\u1ea1t \u0111\u1ed9ng nh\u01b0 m\u1ed9t h\u00e0ng c\u00e1c m\u1ee5c t\u01b0\u01a1ng t\u1ef1, \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef c\u00f9ng nhau trong b\u1ed9 nh\u1edb c\u1ee7a m\u00e1y t\u00ednh \u1edf c\u00e1c v\u1ecb tr\u00ed li\u1ec1n k\u1ec1. N\u00f3 gi\u1ed1ng nh\u01b0 m\u1ed9t chu\u1ed7i duy tr\u00ec l\u01b0u tr\u1eef c\u00f3 t\u1ed5 ch\u1ee9c. M\u1ed7i m\u1ee5c trong h\u00e0ng n\u00e0y c\u00f3 'v\u1ecb tr\u00ed' duy nh\u1ea5t c\u1ee7a n\u00f3 \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 ch\u1ec9 s\u1ed1 (index). Vui l\u00f2ng tham kh\u1ea3o h\u00ecnh b\u00ean d\u01b0\u1edbi \u0111\u1ec3 quan s\u00e1t c\u00e1ch m\u1ea3ng ho\u1ea1t \u0111\u1ed9ng v\u00e0 n\u1eafm b\u1eaft c\u00e1c thu\u1eadt ng\u1eef ch\u00ednh n\u00e0y.</p> <p></p>"},{"location":"chapter_array_and_linkedlist/array/#cac-thao-tac-pho-bien-tren-mang","title":"C\u00e1c thao t\u00e1c ph\u1ed5 bi\u1ebfn tr\u00ean m\u1ea3ng","text":""},{"location":"chapter_array_and_linkedlist/array/#khoi-tao-mang","title":"Kh\u1edfi t\u1ea1o m\u1ea3ng","text":"<p>M\u1ea3ng c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o theo hai c\u00e1ch t\u00f9y thu\u1ed9c v\u00e0o nhu c\u1ea7u: ho\u1eb7c kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u ho\u1eb7c v\u1edbi c\u00e1c gi\u00e1 tr\u1ecb ban \u0111\u1ea7u \u0111\u01b0\u1ee3c ch\u1ec9 \u0111\u1ecbnh. Khi c\u00e1c gi\u00e1 tr\u1ecb ban \u0111\u1ea7u kh\u00f4ng \u0111\u01b0\u1ee3c ch\u1ec9 \u0111\u1ecbnh, h\u1ea7u h\u1ebft c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh s\u1ebd \u0111\u1eb7t c\u00e1c ph\u1ea7n t\u1eed m\u1ea3ng th\u00e0nh \\(0\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig array.py<pre><code># Kh\u1edfi t\u1ea1o m\u1ea3ng\narr: list[int] = [0] * 5  # [ 0, 0, 0, 0, 0 ]\nnums: list[int] = [1, 3, 2, 5, 4]\n</code></pre> array.cpp<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\n// L\u01b0u tr\u1eef tr\u00ean stack\nint arr[5];\nint nums[5] = { 1, 3, 2, 5, 4 };\n// L\u01b0u tr\u1eef tr\u00ean heap (c\u1ea7n gi\u1ea3i ph\u00f3ng b\u1ed9 nh\u1edb th\u1ee7 c\u00f4ng)\nint* arr1 = new int[5];\nint* nums1 = new int[5] { 1, 3, 2, 5, 4 };\n</code></pre> array.java<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\nint[] arr = new int[5]; // { 0, 0, 0, 0, 0 }\nint[] nums = { 1, 3, 2, 5, 4 };\n</code></pre> array.cs<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\nint[] arr = new int[5]; // [ 0, 0, 0, 0, 0 ]\nint[] nums = [1, 3, 2, 5, 4];\n</code></pre> array.go<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\nvar arr [5]int\n// Trong Go, ch\u1ec9 \u0111\u1ecbnh \u0111\u1ed9 d\u00e0i ([5]int) bi\u1ec3u th\u1ecb m\u1ed9t m\u1ea3ng, trong khi kh\u00f4ng ch\u1ec9 \u0111\u1ecbnh n\u00f3 ([]int) bi\u1ec3u th\u1ecb m\u1ed9t slice.\n// V\u00ec m\u1ea3ng c\u1ee7a Go \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf \u0111\u1ec3 c\u00f3 \u0111\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh t\u1ea1i th\u1eddi \u0111i\u1ec3m bi\u00ean d\u1ecbch, ch\u1ec9 c\u00e1c h\u1eb1ng s\u1ed1 m\u1edbi c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 ch\u1ec9 \u0111\u1ecbnh \u0111\u1ed9 d\u00e0i.\n// \u0110\u1ec3 thu\u1eadn ti\u1ec7n cho vi\u1ec7c tri\u1ec3n khai ph\u01b0\u01a1ng th\u1ee9c extend(), Slice s\u1ebd \u0111\u01b0\u1ee3c coi l\u00e0 m\u1ed9t M\u1ea3ng \u1edf \u0111\u00e2y.\nnums := []int{1, 3, 2, 5, 4}\n</code></pre> array.swift<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\nlet arr = Array(repeating: 0, count: 5) // [0, 0, 0, 0, 0]\nlet nums = [1, 3, 2, 5, 4]\n</code></pre> array.js<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\nvar arr = new Array(5).fill(0);\nvar nums = [1, 3, 2, 5, 4];\n</code></pre> array.ts<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\nlet arr: number[] = new Array(5).fill(0);\nlet nums: number[] = [1, 3, 2, 5, 4];\n</code></pre> array.dart<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\nList&lt;int&gt; arr = List.filled(5, 0); // [0, 0, 0, 0, 0]\nList&lt;int&gt; nums = [1, 3, 2, 5, 4];\n</code></pre> array.rs<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\nlet arr: [i32; 5] = [0; 5]; // [0, 0, 0, 0, 0]\nlet slice: &amp;[i32] = &amp;[0; 5];\n// Trong Rust, ch\u1ec9 \u0111\u1ecbnh \u0111\u1ed9 d\u00e0i ([i32; 5]) bi\u1ec3u th\u1ecb m\u1ed9t m\u1ea3ng, trong khi kh\u00f4ng ch\u1ec9 \u0111\u1ecbnh n\u00f3 (&amp;[i32]) bi\u1ec3u th\u1ecb m\u1ed9t slice.\n// V\u00ec m\u1ea3ng c\u1ee7a Rust \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf \u0111\u1ec3 c\u00f3 \u0111\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh t\u1ea1i th\u1eddi \u0111i\u1ec3m bi\u00ean d\u1ecbch, ch\u1ec9 c\u00e1c h\u1eb1ng s\u1ed1 m\u1edbi c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 ch\u1ec9 \u0111\u1ecbnh \u0111\u1ed9 d\u00e0i.\n// Vectors th\u01b0\u1eddng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng l\u00e0m m\u1ea3ng \u0111\u1ed9ng trong Rust.\n// \u0110\u1ec3 thu\u1eadn ti\u1ec7n cho vi\u1ec7c tri\u1ec3n khai ph\u01b0\u01a1ng th\u1ee9c extend(), vector s\u1ebd \u0111\u01b0\u1ee3c coi l\u00e0 m\u1ed9t m\u1ea3ng \u1edf \u0111\u00e2y.\nlet nums: Vec&lt;i32&gt; = vec![1, 3, 2, 5, 4];\n</code></pre> array.c<pre><code>/* Kh\u1edfi t\u1ea1o m\u1ea3ng */\nint arr[5] = { 0 }; // { 0, 0, 0, 0, 0 }\nint nums[5] = { 1, 3, 2, 5, 4 };\n</code></pre> array.kt<pre><code>\n</code></pre> array.zig<pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng\nvar arr = [_]i32{0} ** 5; // { 0, 0, 0, 0, 0 }\nvar nums = [_]i32{ 1, 3, 2, 5, 4 };\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#truy-cap-cac-phan-tu","title":"Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed","text":"<p>C\u00e1c ph\u1ea7n t\u1eed trong m\u1ed9t m\u1ea3ng \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong c\u00e1c kh\u00f4ng gian b\u1ed9 nh\u1edb li\u1ec1n k\u1ec1, gi\u00fap vi\u1ec7c t\u00ednh to\u00e1n \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb c\u1ee7a m\u1ed7i ph\u1ea7n t\u1eed tr\u1edf n\u00ean \u0111\u01a1n gi\u1ea3n h\u01a1n. C\u00f4ng th\u1ee9c \u0111\u01b0\u1ee3c hi\u1ec3n th\u1ecb trong H\u00ecnh d\u01b0\u1edbi \u0111\u00e2y h\u1ed7 tr\u1ee3 x\u00e1c \u0111\u1ecbnh \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb c\u1ee7a m\u1ed9t ph\u1ea7n t\u1eed, s\u1eed d\u1ee5ng \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb c\u1ee7a m\u1ea3ng (c\u1ee5 th\u1ec3 l\u00e0 \u0111\u1ecba ch\u1ec9 c\u1ee7a ph\u1ea7n t\u1eed \u0111\u1ea7u ti\u00ean) v\u00e0 ch\u1ec9 s\u1ed1 c\u1ee7a ph\u1ea7n t\u1eed. T\u00ednh to\u00e1n n\u00e0y h\u1ee3p l\u00fd h\u00f3a vi\u1ec7c truy c\u1eadp tr\u1ef1c ti\u1ebfp v\u00e0o ph\u1ea7n t\u1eed mong mu\u1ed1n.</p> <p></p> <p>Nh\u01b0 \u0111\u00e3 quan s\u00e1t trong h\u00ecnh tr\u00ean, l\u1eadp ch\u1ec9 m\u1ee5c m\u1ea3ng theo quy \u01b0\u1edbc b\u1eaft \u0111\u1ea7u t\u1eeb \\(0\\). M\u1eb7c d\u00f9 \u0111i\u1ec1u n\u00e0y c\u00f3 v\u1ebb tr\u00e1i tr\u1ef1c gi\u00e1c, v\u00ec vi\u1ec7c \u0111\u1ebfm th\u01b0\u1eddng b\u1eaft \u0111\u1ea7u t\u1eeb \\(1\\), trong c\u00f4ng th\u1ee9c t\u00ednh \u0111\u1ecba ch\u1ec9, m\u1ed9t ch\u1ec9 s\u1ed1 v\u1ec1 c\u01a1 b\u1ea3n l\u00e0 m\u1ed9t \u0111\u1ed9 l\u1ec7ch so v\u1edbi \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb. \u0110\u1ed1i v\u1edbi \u0111\u1ecba ch\u1ec9 c\u1ee7a ph\u1ea7n t\u1eed \u0111\u1ea7u ti\u00ean, \u0111\u1ed9 l\u1ec7ch n\u00e0y l\u00e0 \\(0\\), x\u00e1c nh\u1eadn ch\u1ec9 s\u1ed1 c\u1ee7a n\u00f3 l\u00e0 \\(0\\).</p> <p>Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed trong m\u1ed9t m\u1ea3ng l\u00e0 r\u1ea5t hi\u1ec7u qu\u1ea3, cho ph\u00e9p ch\u00fang ta truy c\u1eadp ng\u1eabu nhi\u00ean b\u1ea5t k\u1ef3 ph\u1ea7n t\u1eed n\u00e0o trong th\u1eddi gian \\(O(1)\\).</p> <pre><code>[file]{array}-[class]{}-[func]{random_access}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#chen-cac-phan-tu","title":"Ch\u00e8n c\u00e1c ph\u1ea7n t\u1eed","text":"<p>C\u00e1c ph\u1ea7n t\u1eed m\u1ea3ng \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i ch\u1eb7t ch\u1ebd trong b\u1ed9 nh\u1edb, kh\u00f4ng c\u00f3 kh\u00f4ng gian \u0111\u1ec3 ch\u1ee9a th\u00eam d\u1eef li\u1ec7u gi\u1eefa ch\u00fang. Nh\u01b0 \u0111\u01b0\u1ee3c minh h\u1ecda trong h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y, vi\u1ec7c ch\u00e8n m\u1ed9t ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa m\u1ed9t m\u1ea3ng \u0111\u00f2i h\u1ecfi ph\u1ea3i d\u1ecbch chuy\u1ec3n t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed ti\u1ebfp theo l\u00f9i l\u1ea1i m\u1ed9t v\u1ecb tr\u00ed \u0111\u1ec3 t\u1ea1o ch\u1ed7 cho ph\u1ea7n t\u1eed m\u1edbi.</p> <p></p> <p>\u0110i\u1ec1u quan tr\u1ecdng c\u1ea7n l\u01b0u \u00fd l\u00e0 do \u0111\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh c\u1ee7a m\u1ed9t m\u1ea3ng, vi\u1ec7c ch\u00e8n m\u1ed9t ph\u1ea7n t\u1eed ch\u1eafc ch\u1eafn s\u1ebd d\u1eabn \u0111\u1ebfn vi\u1ec7c m\u1ea5t ph\u1ea7n t\u1eed cu\u1ed1i c\u00f9ng trong m\u1ea3ng. C\u00e1c gi\u1ea3i ph\u00e1p \u0111\u1ec3 gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 n\u00e0y s\u1ebd \u0111\u01b0\u1ee3c kh\u00e1m ph\u00e1 trong ch\u01b0\u01a1ng \"Danh s\u00e1ch\".</p> <pre><code>[file]{array}-[class]{}-[func]{insert}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#xoa-cac-phan-tu","title":"X\u00f3a c\u00e1c ph\u1ea7n t\u1eed","text":"<p>T\u01b0\u01a1ng t\u1ef1, nh\u01b0 \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 trong h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y, \u0111\u1ec3 x\u00f3a m\u1ed9t ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 \\(i\\), t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed sau ch\u1ec9 s\u1ed1 \\(i\\) ph\u1ea3i \u0111\u01b0\u1ee3c di chuy\u1ec3n v\u1ec1 ph\u00eda tr\u01b0\u1edbc m\u1ed9t v\u1ecb tr\u00ed.</p> <p></p> <p>Xin l\u01b0u \u00fd r\u1eb1ng sau khi x\u00f3a, ph\u1ea7n t\u1eed cu\u1ed1i c\u00f9ng tr\u01b0\u1edbc \u0111\u00e2y tr\u1edf n\u00ean \"v\u00f4 ngh\u0129a\", do \u0111\u00f3 kh\u00f4ng y\u00eau c\u1ea7u s\u1eeda \u0111\u1ed5i c\u1ee5 th\u1ec3.</p> <pre><code>[file]{array}-[class]{}-[func]{remove}\n</code></pre> <p>T\u00f3m l\u1ea1i, c\u00e1c thao t\u00e1c ch\u00e8n v\u00e0 x\u00f3a trong m\u1ea3ng c\u00f3 nh\u1eefng nh\u01b0\u1ee3c \u0111i\u1ec3m sau:</p> <ul> <li>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian cao: C\u1ea3 ch\u00e8n v\u00e0 x\u00f3a trong m\u1ed9t m\u1ea3ng \u0111\u1ec1u c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian trung b\u00ecnh l\u00e0 \\(O(n)\\), trong \u0111\u00f3 \\(n\\) l\u00e0 \u0111\u1ed9 d\u00e0i c\u1ee7a m\u1ea3ng.</li> <li>M\u1ea5t c\u00e1c ph\u1ea7n t\u1eed: Do \u0111\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh c\u1ee7a m\u1ea3ng, c\u00e1c ph\u1ea7n t\u1eed v\u01b0\u1ee3t qu\u00e1 dung l\u01b0\u1ee3ng c\u1ee7a m\u1ea3ng s\u1ebd b\u1ecb m\u1ea5t trong qu\u00e1 tr\u00ecnh ch\u00e8n.</li> <li>L\u00e3ng ph\u00ed b\u1ed9 nh\u1edb: Kh\u1edfi t\u1ea1o m\u1ed9t m\u1ea3ng d\u00e0i h\u01a1n v\u00e0 ch\u1ec9 s\u1eed d\u1ee5ng ph\u1ea7n \u0111\u1ea7u d\u1eabn \u0111\u1ebfn c\u00e1c ph\u1ea7n t\u1eed cu\u1ed1i \"v\u00f4 ngh\u0129a\" trong qu\u00e1 tr\u00ecnh ch\u00e8n, d\u1eabn \u0111\u1ebfn l\u00e3ng ph\u00ed m\u1ed9t s\u1ed1 kh\u00f4ng gian b\u1ed9 nh\u1edb.</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/#duyet-mang","title":"Duy\u1ec7t m\u1ea3ng","text":"<p>Trong h\u1ea7u h\u1ebft c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh, ch\u00fang ta c\u00f3 th\u1ec3 duy\u1ec7t m\u1ed9t m\u1ea3ng b\u1eb1ng c\u00e1ch s\u1eed d\u1ee5ng ch\u1ec9 s\u1ed1 ho\u1eb7c b\u1eb1ng c\u00e1ch l\u1eb7p tr\u1ef1c ti\u1ebfp qua t\u1eebng ph\u1ea7n t\u1eed:</p> <pre><code>[file]{array}-[class]{}-[func]{traverse}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#tim-kiem-cac-phan-tu","title":"T\u00ecm ki\u1ebfm c\u00e1c ph\u1ea7n t\u1eed","text":"<p>X\u00e1c \u0111\u1ecbnh v\u1ecb tr\u00ed m\u1ed9t ph\u1ea7n t\u1eed c\u1ee5 th\u1ec3 trong m\u1ed9t m\u1ea3ng bao g\u1ed3m vi\u1ec7c l\u1eb7p qua m\u1ea3ng, ki\u1ec3m tra t\u1eebng ph\u1ea7n t\u1eed \u0111\u1ec3 x\u00e1c \u0111\u1ecbnh xem n\u00f3 c\u00f3 kh\u1edbp v\u1edbi gi\u00e1 tr\u1ecb mong mu\u1ed1n hay kh\u00f4ng.</p> <p>V\u00ec m\u1ea3ng l\u00e0 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u tuy\u1ebfn t\u00ednh, thao t\u00e1c n\u00e0y th\u01b0\u1eddng \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 \"t\u00ecm ki\u1ebfm tuy\u1ebfn t\u00ednh\".</p> <pre><code>[file]{array}-[class]{}-[func]{find}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#mo-rong-mang","title":"M\u1edf r\u1ed9ng m\u1ea3ng","text":"<p>Trong m\u00f4i tr\u01b0\u1eddng h\u1ec7 th\u1ed1ng ph\u1ee9c t\u1ea1p, vi\u1ec7c \u0111\u1ea3m b\u1ea3o t\u00ednh kh\u1ea3 d\u1ee5ng c\u1ee7a kh\u00f4ng gian b\u1ed9 nh\u1edb sau m\u1ed9t m\u1ea3ng \u0111\u1ec3 m\u1edf r\u1ed9ng dung l\u01b0\u1ee3ng an to\u00e0n tr\u1edf n\u00ean kh\u00f3 kh\u0103n. Do \u0111\u00f3, trong h\u1ea7u h\u1ebft c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh, \u0111\u1ed9 d\u00e0i c\u1ee7a m\u1ed9t m\u1ea3ng l\u00e0 b\u1ea5t bi\u1ebfn.</p> <p>\u0110\u1ec3 m\u1edf r\u1ed9ng m\u1ed9t m\u1ea3ng, c\u1ea7n t\u1ea1o m\u1ed9t m\u1ea3ng l\u1edbn h\u01a1n v\u00e0 sau \u0111\u00f3 sao ch\u00e9p c\u00e1c ph\u1ea7n t\u1eed t\u1eeb m\u1ea3ng ban \u0111\u1ea7u. Thao t\u00e1c n\u00e0y c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian l\u00e0 \\(O(n)\\) v\u00e0 c\u00f3 th\u1ec3 t\u1ed1n th\u1eddi gian \u0111\u1ed1i v\u1edbi c\u00e1c m\u1ea3ng l\u1edbn. M\u00e3 nh\u01b0 sau:</p> <pre><code>[file]{array}-[class]{}-[func]{extend}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/array/#uu-iem-va-han-che-cua-mang","title":"\u01afu \u0111i\u1ec3m v\u00e0 h\u1ea1n ch\u1ebf c\u1ee7a m\u1ea3ng","text":"<p>M\u1ea3ng \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong c\u00e1c kh\u00f4ng gian b\u1ed9 nh\u1edb li\u1ec1n k\u1ec1 v\u00e0 bao g\u1ed3m c\u00e1c ph\u1ea7n t\u1eed c\u00f9ng lo\u1ea1i. C\u00e1ch ti\u1ebfp c\u1eadn n\u00e0y cung c\u1ea5p th\u00f4ng tin tr\u01b0\u1edbc \u0111\u00e1ng k\u1ec3 m\u00e0 h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 t\u1eadn d\u1ee5ng \u0111\u1ec3 t\u1ed1i \u01b0u h\u00f3a hi\u1ec7u qu\u1ea3 c\u1ee7a c\u00e1c thao t\u00e1c c\u1ea5u tr\u00fac d\u1eef li\u1ec7u.</p> <ul> <li>Hi\u1ec7u qu\u1ea3 kh\u00f4ng gian cao: M\u1ea3ng ph\u00e2n b\u1ed5 m\u1ed9t kh\u1ed1i b\u1ed9 nh\u1edb li\u1ec1n k\u1ec1 cho d\u1eef li\u1ec7u, lo\u1ea1i b\u1ecf nhu c\u1ea7u v\u1ec1 chi ph\u00ed c\u1ea5u tr\u00fac b\u1ed5 sung.</li> <li>H\u1ed7 tr\u1ee3 truy c\u1eadp ng\u1eabu nhi\u00ean: M\u1ea3ng cho ph\u00e9p truy c\u1eadp th\u1eddi gian \\(O(1)\\) v\u00e0o b\u1ea5t k\u1ef3 ph\u1ea7n t\u1eed n\u00e0o.</li> <li>T\u00ednh c\u1ee5c b\u1ed9 c\u1ee7a b\u1ed9 nh\u1edb cache: Khi truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed m\u1ea3ng, m\u00e1y t\u00ednh kh\u00f4ng ch\u1ec9 t\u1ea3i ch\u00fang m\u00e0 c\u00f2n l\u01b0u v\u00e0o b\u1ed9 nh\u1edb cache d\u1eef li\u1ec7u xung quanh, s\u1eed d\u1ee5ng b\u1ed9 nh\u1edb cache t\u1ed1c \u0111\u1ed9 cao \u0111\u1ec3 n\u00e2ng cao t\u1ed1c \u0111\u1ed9 ho\u1ea1t \u0111\u1ed9ng ti\u1ebfp theo.</li> </ul> <p>Tuy nhi\u00ean, l\u01b0u tr\u1eef kh\u00f4ng gian li\u00ean t\u1ee5c l\u00e0 m\u1ed9t con dao hai l\u01b0\u1ee1i, v\u1edbi nh\u1eefng h\u1ea1n ch\u1ebf sau:</p> <ul> <li>Hi\u1ec7u qu\u1ea3 th\u1ea5p trong ch\u00e8n v\u00e0 x\u00f3a: Khi m\u1ea3ng t\u00edch l\u0169y nhi\u1ec1u ph\u1ea7n t\u1eed, vi\u1ec7c ch\u00e8n ho\u1eb7c x\u00f3a c\u00e1c ph\u1ea7n t\u1eed \u0111\u00f2i h\u1ecfi ph\u1ea3i d\u1ecbch chuy\u1ec3n m\u1ed9t s\u1ed1 l\u01b0\u1ee3ng l\u1edbn c\u00e1c ph\u1ea7n t\u1eed.</li> <li>\u0110\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh: \u0110\u1ed9 d\u00e0i c\u1ee7a m\u1ed9t m\u1ea3ng \u0111\u01b0\u1ee3c c\u1ed1 \u0111\u1ecbnh sau khi kh\u1edfi t\u1ea1o. M\u1edf r\u1ed9ng m\u1ed9t m\u1ea3ng \u0111\u00f2i h\u1ecfi ph\u1ea3i sao ch\u00e9p t\u1ea5t c\u1ea3 d\u1eef li\u1ec7u sang m\u1ed9t m\u1ea3ng m\u1edbi, ph\u00e1t sinh chi ph\u00ed \u0111\u00e1ng k\u1ec3.</li> <li>L\u00e3ng ph\u00ed kh\u00f4ng gian: N\u1ebfu k\u00edch th\u01b0\u1edbc m\u1ea3ng \u0111\u01b0\u1ee3c ph\u00e2n b\u1ed5 v\u01b0\u1ee3t qu\u00e1 m\u1ee9c c\u1ea7n thi\u1ebft, kh\u00f4ng gian th\u1eeba s\u1ebd b\u1ecb l\u00e3ng ph\u00ed.</li> </ul>"},{"location":"chapter_array_and_linkedlist/array/#cac-ung-dung-ien-hinh-cua-mang","title":"C\u00e1c \u1ee9ng d\u1ee5ng \u0111i\u1ec3n h\u00ecnh c\u1ee7a m\u1ea3ng","text":"<p>M\u1ea3ng l\u00e0 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u c\u01a1 b\u1ea3n v\u00e0 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng r\u1ed9ng r\u00e3i. Ch\u00fang \u0111\u01b0\u1ee3c \u1ee9ng d\u1ee5ng th\u01b0\u1eddng xuy\u00ean trong c\u00e1c thu\u1eadt to\u00e1n kh\u00e1c nhau v\u00e0 ph\u1ee5c v\u1ee5 trong vi\u1ec7c tri\u1ec3n khai c\u00e1c c\u1ea5u tr\u00fac d\u1eef li\u1ec7u ph\u1ee9c t\u1ea1p.</p> <ul> <li>Truy c\u1eadp ng\u1eabu nhi\u00ean: M\u1ea3ng l\u00e0 l\u00fd t\u01b0\u1edfng \u0111\u1ec3 l\u01b0u tr\u1eef d\u1eef li\u1ec7u khi c\u1ea7n l\u1ea5y m\u1eabu ng\u1eabu nhi\u00ean. B\u1eb1ng c\u00e1ch t\u1ea1o m\u1ed9t chu\u1ed7i ng\u1eabu nhi\u00ean d\u1ef1a tr\u00ean c\u00e1c ch\u1ec9 s\u1ed1, ch\u00fang ta c\u00f3 th\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c l\u1ea5y m\u1eabu ng\u1eabu nhi\u00ean m\u1ed9t c\u00e1ch hi\u1ec7u qu\u1ea3.</li> <li>S\u1eafp x\u1ebfp v\u00e0 t\u00ecm ki\u1ebfm: M\u1ea3ng l\u00e0 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng ph\u1ed5 bi\u1ebfn nh\u1ea5t cho c\u00e1c thu\u1eadt to\u00e1n s\u1eafp x\u1ebfp v\u00e0 t\u00ecm ki\u1ebfm. C\u00e1c k\u1ef9 thu\u1eadt nh\u01b0 s\u1eafp x\u1ebfp nhanh, s\u1eafp x\u1ebfp tr\u1ed9n, t\u00ecm ki\u1ebfm nh\u1ecb ph\u00e2n, v.v., ch\u1ee7 y\u1ebfu ho\u1ea1t \u0111\u1ed9ng tr\u00ean m\u1ea3ng.</li> <li>B\u1ea3ng tra c\u1ee9u: M\u1ea3ng \u0111\u00f3ng vai tr\u00f2 l\u00e0 b\u1ea3ng tra c\u1ee9u hi\u1ec7u qu\u1ea3 \u0111\u1ec3 truy xu\u1ea5t nhanh c\u00e1c ph\u1ea7n t\u1eed ho\u1eb7c m\u1ed1i quan h\u1ec7. V\u00ed d\u1ee5: \u00e1nh x\u1ea1 c\u00e1c k\u00fd t\u1ef1 v\u1edbi m\u00e3 ASCII tr\u1edf n\u00ean li\u1ec1n m\u1ea1ch b\u1eb1ng c\u00e1ch s\u1eed d\u1ee5ng c\u00e1c gi\u00e1 tr\u1ecb m\u00e3 ASCII l\u00e0m ch\u1ec9 s\u1ed1 v\u00e0 l\u01b0u tr\u1eef c\u00e1c ph\u1ea7n t\u1eed t\u01b0\u01a1ng \u1ee9ng trong m\u1ea3ng.</li> <li>H\u1ecdc m\u00e1y: Trong l\u0129nh v\u1ef1c m\u1ea1ng n\u01a1-ron, m\u1ea3ng \u0111\u00f3ng m\u1ed9t vai tr\u00f2 quan tr\u1ecdng trong vi\u1ec7c th\u1ef1c hi\u1ec7n c\u00e1c ph\u00e9p to\u00e1n \u0111\u1ea1i s\u1ed1 tuy\u1ebfn t\u00ednh quan tr\u1ecdng li\u00ean quan \u0111\u1ebfn vect\u01a1, ma tr\u1eadn v\u00e0 tenx\u01a1. M\u1ea3ng \u0111\u00f3ng vai tr\u00f2 l\u00e0 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u ch\u00ednh v\u00e0 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng r\u1ed9ng r\u00e3i nh\u1ea5t trong l\u1eadp tr\u00ecnh m\u1ea1ng n\u01a1-ron.</li> <li>Tri\u1ec3n khai c\u1ea5u tr\u00fac d\u1eef li\u1ec7u: M\u1ea3ng \u0111\u00f3ng vai tr\u00f2 l\u00e0 c\u00e1c kh\u1ed1i x\u00e2y d\u1ef1ng \u0111\u1ec3 tri\u1ec3n khai c\u00e1c c\u1ea5u tr\u00fac d\u1eef li\u1ec7u kh\u00e1c nhau nh\u01b0 ng\u0103n x\u1ebfp, h\u00e0ng \u0111\u1ee3i, b\u1ea3ng b\u0103m, heap, \u0111\u1ed3 th\u1ecb, v.v. V\u00ed d\u1ee5: bi\u1ec3u di\u1ec5n ma tr\u1eadn k\u1ec1 c\u1ee7a m\u1ed9t \u0111\u1ed3 th\u1ecb v\u1ec1 c\u01a1 b\u1ea3n l\u00e0 m\u1ed9t m\u1ea3ng hai chi\u1ec1u.</li> </ul>"},{"location":"chapter_array_and_linkedlist/linked_list/","title":"4.2 Linked list","text":""},{"location":"chapter_array_and_linkedlist/linked_list/#danh-sach-lien-ket","title":"Danh s\u00e1ch li\u00ean k\u1ebft","text":"<p>Kh\u00f4ng gian b\u1ed9 nh\u1edb l\u00e0 m\u1ed9t t\u00e0i nguy\u00ean \u0111\u01b0\u1ee3c chia s\u1ebb gi\u1eefa t\u1ea5t c\u1ea3 c\u00e1c ch\u01b0\u01a1ng tr\u00ecnh. Trong m\u1ed9t m\u00f4i tr\u01b0\u1eddng h\u1ec7 th\u1ed1ng ph\u1ee9c t\u1ea1p, b\u1ed9 nh\u1edb kh\u1ea3 d\u1ee5ng c\u00f3 th\u1ec3 b\u1ecb ph\u00e2n t\u00e1n kh\u1eafp kh\u00f4ng gian b\u1ed9 nh\u1edb. Ch\u00fang ta hi\u1ec3u r\u1eb1ng b\u1ed9 nh\u1edb \u0111\u01b0\u1ee3c c\u1ea5p ph\u00e1t cho m\u1ed9t m\u1ea3ng ph\u1ea3i li\u00ean t\u1ee5c. Tuy nhi\u00ean, \u0111\u1ed1i v\u1edbi c\u00e1c m\u1ea3ng r\u1ea5t l\u1edbn, vi\u1ec7c t\u00ecm m\u1ed9t kh\u00f4ng gian b\u1ed9 nh\u1edb li\u1ec1n k\u1ec1 \u0111\u1ee7 l\u1edbn c\u00f3 th\u1ec3 l\u00e0 m\u1ed9t th\u00e1ch th\u1ee9c. \u0110\u00e2y l\u00e0 n\u01a1i \u01b0u \u0111i\u1ec3m linh ho\u1ea1t c\u1ee7a danh s\u00e1ch li\u00ean k\u1ebft tr\u1edf n\u00ean r\u00f5 r\u00e0ng.</p> <p>M\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft l\u00e0 m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u tuy\u1ebfn t\u00ednh trong \u0111\u00f3 m\u1ed7i ph\u1ea7n t\u1eed l\u00e0 m\u1ed9t \u0111\u1ed1i t\u01b0\u1ee3ng n\u00fat v\u00e0 c\u00e1c n\u00fat \u0111\u01b0\u1ee3c k\u1ebft n\u1ed1i v\u1edbi nhau th\u00f4ng qua \"tham chi\u1ebfu\". C\u00e1c tham chi\u1ebfu n\u00e0y gi\u1eef \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb c\u1ee7a c\u00e1c n\u00fat ti\u1ebfp theo, cho ph\u00e9p \u0111i\u1ec1u h\u01b0\u1edbng t\u1eeb n\u00fat n\u00e0y sang n\u00fat kh\u00e1c.</p> <p>Thi\u1ebft k\u1ebf c\u1ee7a danh s\u00e1ch li\u00ean k\u1ebft cho ph\u00e9p c\u00e1c n\u00fat c\u1ee7a ch\u00fang \u0111\u01b0\u1ee3c ph\u00e2n ph\u1ed1i tr\u00ean c\u00e1c v\u1ecb tr\u00ed b\u1ed9 nh\u1edb m\u00e0 kh\u00f4ng c\u1ea7n \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb li\u1ec1n k\u1ec1.</p> <p></p> <p>Nh\u01b0 trong h\u00ecnh tr\u00ean, ch\u00fang ta th\u1ea5y r\u1eb1ng kh\u1ed1i x\u00e2y d\u1ef1ng c\u01a1 b\u1ea3n c\u1ee7a m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft l\u00e0 \u0111\u1ed1i t\u01b0\u1ee3ng n\u00fat. M\u1ed7i n\u00fat bao g\u1ed3m hai th\u00e0nh ph\u1ea7n ch\u00ednh: \"gi\u00e1 tr\u1ecb\" c\u1ee7a n\u00fat v\u00e0 m\u1ed9t \"tham chi\u1ebfu\" \u0111\u1ebfn n\u00fat ti\u1ebfp theo.</p> <ul> <li>N\u00fat \u0111\u1ea7u ti\u00ean trong m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft l\u00e0 \"n\u00fat \u0111\u1ea7u\", v\u00e0 n\u00fat cu\u1ed1i c\u00f9ng l\u00e0 \"n\u00fat \u0111u\u00f4i\".</li> <li>N\u00fat \u0111u\u00f4i tr\u1ecf \u0111\u1ebfn \"null\", \u0111\u01b0\u1ee3c ch\u1ec9 \u0111\u1ecbnh l\u00e0 <code>null</code> trong Java, <code>nullptr</code> trong C++ v\u00e0 <code>None</code> trong Python.</li> <li>Trong c\u00e1c ng\u00f4n ng\u1eef h\u1ed7 tr\u1ee3 con tr\u1ecf, nh\u01b0 C, C++, Go v\u00e0 Rust, \"tham chi\u1ebfu\" n\u00e0y th\u01b0\u1eddng \u0111\u01b0\u1ee3c tri\u1ec3n khai nh\u01b0 m\u1ed9t \"con tr\u1ecf\".</li> </ul> <p>Nh\u01b0 \u0111o\u1ea1n code d\u01b0\u1edbi \u0111\u00e2y minh h\u1ecda, m\u1ed9t <code>ListNode</code> trong m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft, ngo\u00e0i vi\u1ec7c gi\u1eef m\u1ed9t gi\u00e1 tr\u1ecb, c\u0169ng ph\u1ea3i duy tr\u00ec m\u1ed9t tham chi\u1ebfu (ho\u1eb7c con tr\u1ecf) b\u1ed5 sung. Do \u0111\u00f3, m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft chi\u1ebfm nhi\u1ec1u kh\u00f4ng gian b\u1ed9 nh\u1edb h\u01a1n m\u1ed9t m\u1ea3ng khi l\u01b0u tr\u1eef c\u00f9ng m\u1ed9t l\u01b0\u1ee3ng d\u1eef li\u1ec7u.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>class ListNode:\n    \"\"\"L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val               # Gi\u00e1 tr\u1ecb n\u00fat\n        self.next: ListNode | None = None # Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n</code></pre> <pre><code>/* C\u1ea5u tr\u00fac n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\nstruct ListNode {\n    int val;         // Gi\u00e1 tr\u1ecb n\u00fat\n    ListNode *next;  // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n    ListNode(int x) : val(x), next(nullptr) {}  // H\u00e0m t\u1ea1o\n};\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\nclass ListNode {\n    int val;        // Gi\u00e1 tr\u1ecb n\u00fat\n    ListNode next;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n    ListNode(int x) { val = x; }  // H\u00e0m t\u1ea1o\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\nclass ListNode(int x) {  // H\u00e0m t\u1ea1o\n    int val = x;         // Gi\u00e1 tr\u1ecb n\u00fat\n    ListNode? next;      // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n}\n</code></pre> <pre><code>/* C\u1ea5u tr\u00fac n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\ntype ListNode struct {\n    Val  int       // Gi\u00e1 tr\u1ecb n\u00fat\n    Next *ListNode // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n}\n\n// NewListNode Constructor, t\u1ea1o m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft m\u1edbi\nfunc NewListNode(val int) *ListNode {\n    return &amp;ListNode{\n        Val:  val,\n        Next: nil,\n    }\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\nclass ListNode {\n    var val: Int // Gi\u00e1 tr\u1ecb n\u00fat\n    var next: ListNode? // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n\n    init(x: Int) { // H\u00e0m t\u1ea1o\n        val = x\n    }\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\nclass ListNode {\n    constructor(val, next) {\n        this.val = (val === undefined ? 0 : val);       // Gi\u00e1 tr\u1ecb n\u00fat\n        this.next = (next === undefined ? null : next); // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n    }\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    constructor(val?: number, next?: ListNode | null) {\n        this.val = val === undefined ? 0 : val;        // Gi\u00e1 tr\u1ecb n\u00fat\n        this.next = next === undefined ? null : next;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n    }\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\nclass ListNode {\n  int val; // Gi\u00e1 tr\u1ecb n\u00fat\n  ListNode? next; // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n  ListNode(this.val, [this.next]); // H\u00e0m t\u1ea1o\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\n#[derive(Debug)]\nstruct ListNode {\n    val: i32, // Gi\u00e1 tr\u1ecb n\u00fat\n    next: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n}\n</code></pre> <pre><code>/* C\u1ea5u tr\u00fac n\u00fat danh s\u00e1ch li\u00ean k\u1ebft */\ntypedef struct ListNode {\n    int val;               // Gi\u00e1 tr\u1ecb n\u00fat\n    struct ListNode *next; // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n} ListNode;\n\n/* H\u00e0m t\u1ea1o */\nListNode *newListNode(int val) {\n    ListNode *node;\n    node = (ListNode *) malloc(sizeof(ListNode));\n    node-&gt;val = val;\n    node-&gt;next = NULL;\n    return node;\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft\npub fn ListNode(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        val: T = 0, // Gi\u00e1 tr\u1ecb n\u00fat\n        next: ?*Self = null, // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n\n        // H\u00e0m t\u1ea1o\n        pub fn init(self: *Self, x: i32) void {\n            self.val = x;\n            self.next = null;\n        }\n    };\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#cac-thao-tac-pho-bien-tren-danh-sach-lien-ket","title":"C\u00e1c thao t\u00e1c ph\u1ed5 bi\u1ebfn tr\u00ean danh s\u00e1ch li\u00ean k\u1ebft","text":""},{"location":"chapter_array_and_linkedlist/linked_list/#khoi-tao-mot-danh-sach-lien-ket","title":"Kh\u1edfi t\u1ea1o m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft","text":"<p>X\u00e2y d\u1ef1ng m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft l\u00e0 m\u1ed9t qu\u00e1 tr\u00ecnh hai b\u01b0\u1edbc: \u0111\u1ea7u ti\u00ean, kh\u1edfi t\u1ea1o m\u1ed7i \u0111\u1ed1i t\u01b0\u1ee3ng n\u00fat, v\u00e0 th\u1ee9 hai, t\u1ea1o c\u00e1c li\u00ean k\u1ebft tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat. Sau khi kh\u1edfi t\u1ea1o, ch\u00fang ta c\u00f3 th\u1ec3 duy\u1ec7t qua t\u1ea5t c\u1ea3 c\u00e1c n\u00fat tu\u1ea7n t\u1ef1 t\u1eeb n\u00fat \u0111\u1ea7u b\u1eb1ng c\u00e1ch theo tham chi\u1ebfu <code>next</code>.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig linked_list.py<pre><code># Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4\n# Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nn0 = ListNode(1)\nn1 = ListNode(3)\nn2 = ListNode(2)\nn3 = ListNode(5)\nn4 = ListNode(4)\n# X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n</code></pre> linked_list.cpp<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nListNode* n0 = new ListNode(1);\nListNode* n1 = new ListNode(3);\nListNode* n2 = new ListNode(2);\nListNode* n3 = new ListNode(5);\nListNode* n4 = new ListNode(4);\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0-&gt;next = n1;\nn1-&gt;next = n2;\nn2-&gt;next = n3;\nn3-&gt;next = n4;\n</code></pre> linked_list.java<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nListNode n0 = new ListNode(1);\nListNode n1 = new ListNode(3);\nListNode n2 = new ListNode(2);\nListNode n3 = new ListNode(5);\nListNode n4 = new ListNode(4);\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.cs<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nListNode n0 = new(1);\nListNode n1 = new(3);\nListNode n2 = new(2);\nListNode n3 = new(5);\nListNode n4 = new(4);\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.go<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nn0 := NewListNode(1)\nn1 := NewListNode(3)\nn2 := NewListNode(2)\nn3 := NewListNode(5)\nn4 := NewListNode(4)\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.Next = n1\nn1.Next = n2\nn2.Next = n3\nn3.Next = n4\n</code></pre> linked_list.swift<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nlet n0 = ListNode(x: 1)\nlet n1 = ListNode(x: 3)\nlet n2 = ListNode(x: 2)\nlet n3 = ListNode(x: 5)\nlet n4 = ListNode(x: 4)\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.next = n1\nn1.next = n2\nn2.next = n3\nn3.next = n4\n</code></pre> linked_list.js<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nconst n0 = new ListNode(1);\nconst n1 = new ListNode(3);\nconst n2 = new ListNode(2);\nconst n3 = new ListNode(5);\nconst n4 = new ListNode(4);\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.ts<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nconst n0 = new ListNode(1);\nconst n1 = new ListNode(3);\nconst n2 = new ListNode(2);\nconst n3 = new ListNode(5);\nconst n4 = new ListNode(4);\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.dart<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nListNode n0 = ListNode(1);\nListNode n1 = ListNode(3);\nListNode n2 = ListNode(2);\nListNode n3 = ListNode(5);\nListNode n4 = ListNode(4);\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.next = n1;\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\n</code></pre> linked_list.rs<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nlet n0 = Rc::new(RefCell::new(ListNode { val: 1, next: None }));\nlet n1 = Rc::new(RefCell::new(ListNode { val: 3, next: None }));\nlet n2 = Rc::new(RefCell::new(ListNode { val: 2, next: None }));\nlet n3 = Rc::new(RefCell::new(ListNode { val: 5, next: None }));\nlet n4 = Rc::new(RefCell::new(ListNode { val: 4, next: None }));\n\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.borrow_mut().next = Some(n1.clone());\nn1.borrow_mut().next = Some(n2.clone());\nn2.borrow_mut().next = Some(n3.clone());\nn3.borrow_mut().next = Some(n4.clone());\n</code></pre> linked_list.c<pre><code>/* Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft: 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nListNode* n0 = newListNode(1);\nListNode* n1 = newListNode(3);\nListNode* n2 = newListNode(2);\nListNode* n3 = newListNode(5);\nListNode* n4 = newListNode(4);\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0-&gt;next = n1;\nn1-&gt;next = n2;\nn2-&gt;next = n3;\nn3-&gt;next = n4;\n</code></pre> linked_list.kt<pre><code>\n</code></pre> linked_list.zig<pre><code>// Kh\u1edfi t\u1ea1o danh s\u00e1ch li\u00ean k\u1ebft\n// Kh\u1edfi t\u1ea1o m\u1ed7i n\u00fat\nvar n0 = inc.ListNode(i32){.val = 1};\nvar n1 = inc.ListNode(i32){.val = 3};\nvar n2 = inc.ListNode(i32){.val = 2};\nvar n3 = inc.ListNode(i32){.val = 5};\nvar n4 = inc.ListNode(i32){.val = 4};\n// X\u00e2y d\u1ef1ng tham chi\u1ebfu gi\u1eefa c\u00e1c n\u00fat\nn0.next = &amp;n1;\nn1.next = &amp;n2;\nn2.next = &amp;n3;\nn3.next = &amp;n4;\n</code></pre> <p>M\u1ea3ng n\u00f3i chung l\u00e0 m\u1ed9t bi\u1ebfn, v\u00ed d\u1ee5: m\u1ea3ng <code>nums</code> bao g\u1ed3m c\u00e1c ph\u1ea7n t\u1eed nh\u01b0 <code>nums[0]</code>, <code>nums[1]</code>, v.v., trong khi m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft \u0111\u01b0\u1ee3c t\u1ea1o th\u00e0nh t\u1eeb m\u1ed9t s\u1ed1 \u0111\u1ed1i t\u01b0\u1ee3ng n\u00fat ri\u00eang bi\u1ec7t. Ch\u00fang ta th\u01b0\u1eddng tham chi\u1ebfu \u0111\u1ebfn m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft b\u1eb1ng n\u00fat \u0111\u1ea7u c\u1ee7a n\u00f3, v\u00ed d\u1ee5: danh s\u00e1ch li\u00ean k\u1ebft trong \u0111o\u1ea1n code tr\u01b0\u1edbc \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 <code>n0</code>.</p>"},{"location":"chapter_array_and_linkedlist/linked_list/#chen-nut","title":"Ch\u00e8n n\u00fat","text":"<p>Ch\u00e8n m\u1ed9t n\u00fat v\u00e0o m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft r\u1ea5t d\u1ec5 d\u00e0ng. Nh\u01b0 trong h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y, gi\u1ea3 s\u1eed ch\u00fang ta mu\u1ed1n ch\u00e8n m\u1ed9t n\u00fat m\u1edbi <code>P</code> gi\u1eefa hai n\u00fat li\u1ec1n k\u1ec1 <code>n0</code> v\u00e0 <code>n1</code>. \u0110i\u1ec1u n\u00e0y c\u00f3 th\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c b\u1eb1ng c\u00e1ch ch\u1ec9 c\u1ea7n s\u1eeda \u0111\u1ed5i hai tham chi\u1ebfu n\u00fat (con tr\u1ecf), v\u1edbi \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian l\u00e0 \\(O(1)\\).</p> <p>So s\u00e1nh, vi\u1ec7c ch\u00e8n m\u1ed9t ph\u1ea7n t\u1eed v\u00e0o m\u1ed9t m\u1ea3ng c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian l\u00e0 \\(O(n)\\), \u0111i\u1ec1u n\u00e0y tr\u1edf n\u00ean k\u00e9m hi\u1ec7u qu\u1ea3 h\u01a1n khi x\u1eed l\u00fd kh\u1ed1i l\u01b0\u1ee3ng d\u1eef li\u1ec7u l\u1edbn.</p> <p></p> <pre><code>[file]{linked_list}-[class]{}-[func]{insert}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#xoa-nut","title":"X\u00f3a n\u00fat","text":"<p>Nh\u01b0 trong h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y, vi\u1ec7c x\u00f3a m\u1ed9t n\u00fat kh\u1ecfi m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft c\u0169ng r\u1ea5t d\u1ec5 d\u00e0ng, ch\u1ec9 li\u00ean quan \u0111\u1ebfn vi\u1ec7c s\u1eeda \u0111\u1ed5i tham chi\u1ebfu (con tr\u1ecf) c\u1ee7a m\u1ed9t n\u00fat duy nh\u1ea5t.</p> <p>\u0110i\u1ec1u quan tr\u1ecdng c\u1ea7n l\u01b0u \u00fd l\u00e0 ngay c\u1ea3 khi n\u00fat <code>P</code> ti\u1ebfp t\u1ee5c tr\u1ecf \u0111\u1ebfn <code>n1</code> sau khi b\u1ecb x\u00f3a, n\u00f3 s\u1ebd tr\u1edf n\u00ean kh\u00f4ng th\u1ec3 truy c\u1eadp \u0111\u01b0\u1ee3c trong qu\u00e1 tr\u00ecnh duy\u1ec7t danh s\u00e1ch li\u00ean k\u1ebft. \u0110i\u1ec1u n\u00e0y c\u00f3 ngh\u0129a l\u00e0 <code>P</code> kh\u00f4ng c\u00f2n l\u00e0 m\u1ed9t ph\u1ea7n c\u1ee7a danh s\u00e1ch li\u00ean k\u1ebft.</p> <p></p> <pre><code>[file]{linked_list}-[class]{}-[func]{remove}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#truy-cap-nut","title":"Truy c\u1eadp n\u00fat","text":"<p>Truy c\u1eadp c\u00e1c n\u00fat trong m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft k\u00e9m hi\u1ec7u qu\u1ea3 h\u01a1n. Nh\u01b0 \u0111\u00e3 \u0111\u1ec1 c\u1eadp tr\u01b0\u1edbc \u0111\u00f3, b\u1ea5t k\u1ef3 ph\u1ea7n t\u1eed n\u00e0o trong m\u1ed9t m\u1ea3ng c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c truy c\u1eadp trong th\u1eddi gian \\(O(1)\\). Ng\u01b0\u1ee3c l\u1ea1i, v\u1edbi m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft, ch\u01b0\u01a1ng tr\u00ecnh li\u00ean quan \u0111\u1ebfn vi\u1ec7c b\u1eaft \u0111\u1ea7u t\u1eeb n\u00fat \u0111\u1ea7u v\u00e0 tu\u1ea7n t\u1ef1 duy\u1ec7t qua c\u00e1c n\u00fat cho \u0111\u1ebfn khi t\u00ecm th\u1ea5y n\u00fat mong mu\u1ed1n. N\u00f3i c\u00e1ch kh\u00e1c, \u0111\u1ec3 truy c\u1eadp n\u00fat th\u1ee9 \\(i\\) trong m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft, ch\u01b0\u01a1ng tr\u00ecnh ph\u1ea3i l\u1eb7p qua \\(i - 1\\) n\u00fat, d\u1eabn \u0111\u1ebfn \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian l\u00e0 \\(O(n)\\).</p> <pre><code>[file]{linked_list}-[class]{}-[func]{access}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#tim-kiem-nut","title":"T\u00ecm ki\u1ebfm n\u00fat","text":"<p>Duy\u1ec7t danh s\u00e1ch li\u00ean k\u1ebft \u0111\u1ec3 \u0111\u1ecbnh v\u1ecb m\u1ed9t n\u00fat c\u00f3 gi\u00e1 tr\u1ecb kh\u1edbp v\u1edbi <code>target</code>, v\u00e0 sau \u0111\u00f3 xu\u1ea5t ch\u1ec9 m\u1ee5c c\u1ee7a n\u00fat \u0111\u00f3 trong danh s\u00e1ch li\u00ean k\u1ebft. Th\u1ee7 t\u1ee5c n\u00e0y c\u0169ng l\u00e0 m\u1ed9t v\u00ed d\u1ee5 v\u1ec1 t\u00ecm ki\u1ebfm tuy\u1ebfn t\u00ednh. Code t\u01b0\u01a1ng \u1ee9ng \u0111\u01b0\u1ee3c cung c\u1ea5p d\u01b0\u1edbi \u0111\u00e2y:</p> <pre><code>[file]{linked_list}-[class]{}-[func]{find}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/linked_list/#mang-so-voi-danh-sach-lien-ket","title":"M\u1ea3ng so v\u1edbi danh s\u00e1ch li\u00ean k\u1ebft","text":"<p>B\u1ea3ng d\u01b0\u1edbi \u0111\u00e2y t\u00f3m t\u1eaft c\u00e1c \u0111\u1eb7c \u0111i\u1ec3m c\u1ee7a m\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft, v\u00e0 n\u00f3 c\u0169ng so s\u00e1nh hi\u1ec7u qu\u1ea3 c\u1ee7a ch\u00fang trong c\u00e1c ho\u1ea1t \u0111\u1ed9ng kh\u00e1c nhau. V\u00ec ch\u00fang s\u1eed d\u1ee5ng c\u00e1c chi\u1ebfn l\u01b0\u1ee3c l\u01b0u tr\u1eef \u0111\u1ed1i l\u1eadp, c\u00e1c thu\u1ed9c t\u00ednh v\u00e0 hi\u1ec7u qu\u1ea3 ho\u1ea1t \u0111\u1ed9ng t\u01b0\u01a1ng \u1ee9ng c\u1ee7a ch\u00fang th\u1ec3 hi\u1ec7n s\u1ef1 t\u01b0\u01a1ng ph\u1ea3n r\u00f5 r\u1ec7t.</p> <p> B\u1ea3ng  \u00a0 So s\u00e1nh hi\u1ec7u qu\u1ea3 c\u1ee7a m\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft </p> M\u1ea3ng Danh s\u00e1ch li\u00ean k\u1ebft L\u01b0u tr\u1eef Kh\u00f4ng gian b\u1ed9 nh\u1edb li\u1ec1n k\u1ec1 Kh\u00f4ng gian b\u1ed9 nh\u1edb ph\u00e2n t\u00e1n M\u1edf r\u1ed9ng dung l\u01b0\u1ee3ng \u0110\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh M\u1edf r\u1ed9ng linh ho\u1ea1t Hi\u1ec7u qu\u1ea3 b\u1ed9 nh\u1edb \u00cdt b\u1ed9 nh\u1edb tr\u00ean m\u1ed7i ph\u1ea7n t\u1eed, l\u00e3ng ph\u00ed kh\u00f4ng gian ti\u1ec1m n\u0103ng Nhi\u1ec1u b\u1ed9 nh\u1edb tr\u00ean m\u1ed7i ph\u1ea7n t\u1eed Truy c\u1eadp ph\u1ea7n t\u1eed \\(O(1)\\) \\(O(n)\\) Th\u00eam ph\u1ea7n t\u1eed \\(O(n)\\) \\(O(1)\\) X\u00f3a ph\u1ea7n t\u1eed \\(O(n)\\) \\(O(1)\\)"},{"location":"chapter_array_and_linkedlist/linked_list/#cac-loai-danh-sach-lien-ket-pho-bien","title":"C\u00e1c lo\u1ea1i danh s\u00e1ch li\u00ean k\u1ebft ph\u1ed5 bi\u1ebfn","text":"<p>Nh\u01b0 trong h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y, c\u00f3 ba lo\u1ea1i danh s\u00e1ch li\u00ean k\u1ebft ph\u1ed5 bi\u1ebfn.</p> <ul> <li>Danh s\u00e1ch li\u00ean k\u1ebft \u0111\u01a1n: \u0110\u00e2y l\u00e0 danh s\u00e1ch li\u00ean k\u1ebft ti\u00eau chu\u1ea9n \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 tr\u01b0\u1edbc \u0111\u00f3. C\u00e1c n\u00fat trong m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft \u0111\u01a1n bao g\u1ed3m m\u1ed9t gi\u00e1 tr\u1ecb v\u00e0 m\u1ed9t tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo. N\u00fat \u0111\u1ea7u ti\u00ean \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 n\u00fat \u0111\u1ea7u v\u00e0 n\u00fat cu\u1ed1i c\u00f9ng, tr\u1ecf \u0111\u1ebfn null (<code>None</code>), l\u00e0 n\u00fat \u0111u\u00f4i.</li> <li>Danh s\u00e1ch li\u00ean k\u1ebft v\u00f2ng: \u0110i\u1ec1u n\u00e0y \u0111\u01b0\u1ee3c h\u00ecnh th\u00e0nh khi n\u00fat \u0111u\u00f4i c\u1ee7a m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft \u0111\u01a1n tr\u1ecf ng\u01b0\u1ee3c l\u1ea1i n\u00fat \u0111\u1ea7u, t\u1ea1o ra m\u1ed9t v\u00f2ng l\u1eb7p. Trong m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft v\u00f2ng, b\u1ea5t k\u1ef3 n\u00fat n\u00e0o c\u0169ng c\u00f3 th\u1ec3 ho\u1ea1t \u0111\u1ed9ng nh\u01b0 n\u00fat \u0111\u1ea7u.</li> <li>Danh s\u00e1ch li\u00ean k\u1ebft \u0111\u00f4i: Ng\u01b0\u1ee3c l\u1ea1i v\u1edbi m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft \u0111\u01a1n, m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft \u0111\u00f4i duy tr\u00ec c\u00e1c tham chi\u1ebfu theo hai h\u01b0\u1edbng. M\u1ed7i n\u00fat ch\u1ee9a c\u00e1c tham chi\u1ebfu (con tr\u1ecf) \u0111\u1ebfn c\u1ea3 n\u00fat k\u1ebf nhi\u1ec7m (n\u00fat ti\u1ebfp theo) v\u00e0 n\u00fat ti\u1ec1n nhi\u1ec7m (n\u00fat tr\u01b0\u1edbc \u0111\u00f3). M\u1eb7c d\u00f9 danh s\u00e1ch li\u00ean k\u1ebft \u0111\u00f4i cung c\u1ea5p s\u1ef1 linh ho\u1ea1t h\u01a1n \u0111\u1ec3 duy\u1ec7t theo c\u1ea3 hai h\u01b0\u1edbng, nh\u01b0ng ch\u00fang c\u0169ng ti\u00eau th\u1ee5 nhi\u1ec1u kh\u00f4ng gian b\u1ed9 nh\u1edb h\u01a1n.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>class ListNode:\n    \"\"\"L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                # Gi\u00e1 tr\u1ecb n\u00fat\n        self.next: ListNode | None = None  # Tham chi\u1ebfu \u0111\u1ebfn n\u00fat k\u1ebf nhi\u1ec7m\n        self.prev: ListNode | None = None  # Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n</code></pre> <pre><code>/* C\u1ea5u tr\u00fac n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\nstruct ListNode {\n    int val;         // Gi\u00e1 tr\u1ecb n\u00fat\n    ListNode *next;  // Con tr\u1ecf \u0111\u1ebfn n\u00fat k\u1ebf nhi\u1ec7m\n    ListNode *prev;  // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n    ListNode(int x) : val(x), next(nullptr), prev(nullptr) {}  // H\u00e0m t\u1ea1o\n};\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\nclass ListNode {\n    int val;        // Gi\u00e1 tr\u1ecb n\u00fat\n    ListNode next;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n    ListNode prev;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n    ListNode(int x) { val = x; }  // H\u00e0m t\u1ea1o\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\nclass ListNode(int x) {  // H\u00e0m t\u1ea1o\n    int val = x;    // Gi\u00e1 tr\u1ecb n\u00fat\n    ListNode next;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n    ListNode prev;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n}\n</code></pre> <pre><code>/* C\u1ea5u tr\u00fac n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\ntype DoublyListNode struct {\n    Val  int             // Gi\u00e1 tr\u1ecb n\u00fat\n    Next *DoublyListNode // Con tr\u1ecf \u0111\u1ebfn n\u00fat k\u1ebf nhi\u1ec7m\n    Prev *DoublyListNode // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n}\n\n// Kh\u1edfi t\u1ea1o NewDoublyListNode\nfunc NewDoublyListNode(val int) *DoublyListNode {\n    return &amp;DoublyListNode{\n        Val:  val,\n        Next: nil,\n        Prev: nil,\n    }\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\nclass ListNode {\n    var val: Int // Gi\u00e1 tr\u1ecb n\u00fat\n    var next: ListNode? // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n    var prev: ListNode? // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n\n    init(x: Int) { // H\u00e0m t\u1ea1o\n        val = x\n    }\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\nclass ListNode {\n    constructor(val, next, prev) {\n        this.val = val  ===  undefined ? 0 : val;        // Gi\u00e1 tr\u1ecb n\u00fat\n        this.next = next  ===  undefined ? null : next;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat k\u1ebf nhi\u1ec7m\n        this.prev = prev  ===  undefined ? null : prev;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n    }\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\nclass ListNode {\n    val: number;\n    next: ListNode | null;\n    prev: ListNode | null;\n    constructor(val?: number, next?: ListNode | null, prev?: ListNode | null) {\n        this.val = val  ===  undefined ? 0 : val;        // Gi\u00e1 tr\u1ecb n\u00fat\n        this.next = next  ===  undefined ? null : next;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat k\u1ebf nhi\u1ec7m\n        this.prev = prev  ===  undefined ? null : prev;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n    }\n}\n</code></pre> <pre><code>/* L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\nclass ListNode {\n    int val;        // Gi\u00e1 tr\u1ecb n\u00fat\n    ListNode next;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ebfp theo\n    ListNode prev;  // Tham chi\u1ebfu \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n    ListNode(this.val, [this.next, this.prev]);  // H\u00e0m t\u1ea1o\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Ki\u1ec3u n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\n#[derive(Debug)]\nstruct ListNode {\n    val: i32, // Gi\u00e1 tr\u1ecb n\u00fat\n    next: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Con tr\u1ecf \u0111\u1ebfn n\u00fat k\u1ebf nhi\u1ec7m\n    prev: Option&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;, // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n}\n\n/* H\u00e0m t\u1ea1o */\nimpl ListNode {\n    fn new(val: i32) -&gt; Self {\n        ListNode {\n            val,\n            next: None,\n            prev: None,\n        }\n    }\n}\n</code></pre> <pre><code>/* C\u1ea5u tr\u00fac n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u */\ntypedef struct ListNode {\n    int val;               // Gi\u00e1 tr\u1ecb n\u00fat\n    struct ListNode *next; // Con tr\u1ecf \u0111\u1ebfn n\u00fat k\u1ebf nhi\u1ec7m\n    struct ListNode *prev; // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n} ListNode;\n\n/* H\u00e0m t\u1ea1o */\nListNode *newListNode(int val) {\n    ListNode *node, *next;\n    node = (ListNode *) malloc(sizeof(ListNode));\n    node-&gt;val = val;\n    node-&gt;next = NULL;\n    node-&gt;prev = NULL;\n    return node;\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// L\u1edbp n\u00fat danh s\u00e1ch li\u00ean k\u1ebft hai chi\u1ec1u\npub fn ListNode(comptime T: type) type {\n    return struct {\n        const Self = @This();\n\n        val: T = 0, // Gi\u00e1 tr\u1ecb n\u00fat\n        next: ?*Self = null, // Con tr\u1ecf \u0111\u1ebfn n\u00fat k\u1ebf nhi\u1ec7m\n        prev: ?*Self = null, // Con tr\u1ecf \u0111\u1ebfn n\u00fat ti\u1ec1n nhi\u1ec7m\n\n        // H\u00e0m t\u1ea1o\n        pub fn init(self: *Self, x: i32) void {\n            self.val = x;\n            self.next = null;\n            self.prev = null;\n        }\n    };\n}\n</code></pre> <p></p>"},{"location":"chapter_array_and_linkedlist/linked_list/#cac-ung-dung-ien-hinh-cua-danh-sach-lien-ket","title":"C\u00e1c \u1ee9ng d\u1ee5ng \u0111i\u1ec3n h\u00ecnh c\u1ee7a danh s\u00e1ch li\u00ean k\u1ebft","text":"<p>Danh s\u00e1ch li\u00ean k\u1ebft \u0111\u01a1n th\u01b0\u1eddng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 tri\u1ec3n khai ng\u0103n x\u1ebfp, h\u00e0ng \u0111\u1ee3i, b\u1ea3ng b\u0103m v\u00e0 \u0111\u1ed3 th\u1ecb.</p> <ul> <li>Ng\u0103n x\u1ebfp v\u00e0 h\u00e0ng \u0111\u1ee3i: Trong danh s\u00e1ch li\u00ean k\u1ebft \u0111\u01a1n, n\u1ebfu c\u00e1c thao t\u00e1c ch\u00e8n v\u00e0 x\u00f3a x\u1ea3y ra \u1edf c\u00f9ng m\u1ed9t \u0111\u1ea7u, n\u00f3 ho\u1ea1t \u0111\u1ed9ng nh\u01b0 m\u1ed9t ng\u0103n x\u1ebfp (v\u00e0o sau ra tr\u01b0\u1edbc). Ng\u01b0\u1ee3c l\u1ea1i, n\u1ebfu c\u00e1c thao t\u00e1c ch\u00e8n \u1edf m\u1ed9t \u0111\u1ea7u v\u00e0 x\u00f3a \u1edf \u0111\u1ea7u kia, n\u00f3 ho\u1ea1t \u0111\u1ed9ng nh\u01b0 m\u1ed9t h\u00e0ng \u0111\u1ee3i (v\u00e0o tr\u01b0\u1edbc ra tr\u01b0\u1edbc).</li> <li>B\u1ea3ng b\u0103m: Danh s\u00e1ch li\u00ean k\u1ebft \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng trong ph\u01b0\u01a1ng ph\u00e1p k\u1ebft n\u1ed1i, m\u1ed9t ph\u01b0\u01a1ng ph\u00e1p ph\u1ed5 bi\u1ebfn \u0111\u1ec3 gi\u1ea3i quy\u1ebft xung \u0111\u1ed9t b\u0103m. \u1ede \u0111\u00e2y, t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed b\u1ecb xung \u0111\u1ed9t \u0111\u01b0\u1ee3c nh\u00f3m v\u00e0o m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft.</li> <li>\u0110\u1ed3 th\u1ecb: Danh s\u00e1ch k\u1ec1, m\u1ed9t ph\u01b0\u01a1ng ph\u00e1p ti\u00eau chu\u1ea9n \u0111\u1ec3 bi\u1ec3u di\u1ec5n \u0111\u1ed3 th\u1ecb, li\u00ean k\u1ebft m\u1ed7i \u0111\u1ec9nh \u0111\u1ed3 th\u1ecb v\u1edbi m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft. Danh s\u00e1ch n\u00e0y ch\u1ee9a c\u00e1c ph\u1ea7n t\u1eed \u0111\u1ea1i di\u1ec7n cho c\u00e1c \u0111\u1ec9nh \u0111\u01b0\u1ee3c k\u1ebft n\u1ed1i v\u1edbi \u0111\u1ec9nh t\u01b0\u01a1ng \u1ee9ng.</li> </ul> <p>Danh s\u00e1ch li\u00ean k\u1ebft \u0111\u00f4i l\u00e0 l\u00fd t\u01b0\u1edfng cho c\u00e1c t\u00ecnh hu\u1ed1ng y\u00eau c\u1ea7u truy c\u1eadp nhanh v\u00e0o c\u00e1c ph\u1ea7n t\u1eed tr\u01b0\u1edbc v\u00e0 sau.</p> <ul> <li>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u n\u00e2ng cao: Trong c\u00e1c c\u1ea5u tr\u00fac nh\u01b0 c\u00e2y \u0111\u1ecf-\u0111en v\u00e0 c\u00e2y B, vi\u1ec7c truy c\u1eadp v\u00e0o n\u00fat cha l\u00e0 r\u1ea5t c\u1ea7n thi\u1ebft. \u0110i\u1ec1u n\u00e0y \u0111\u1ea1t \u0111\u01b0\u1ee3c b\u1eb1ng c\u00e1ch k\u1ebft h\u1ee3p m\u1ed9t tham chi\u1ebfu \u0111\u1ebfn n\u00fat cha trong m\u1ed7i n\u00fat, t\u01b0\u01a1ng t\u1ef1 nh\u01b0 m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft \u0111\u00f4i.</li> <li>L\u1ecbch s\u1eed tr\u00ecnh duy\u1ec7t: Trong tr\u00ecnh duy\u1ec7t web, danh s\u00e1ch li\u00ean k\u1ebft \u0111\u00f4i t\u1ea1o \u0111i\u1ec1u ki\u1ec7n \u0111i\u1ec1u h\u01b0\u1edbng l\u1ecbch s\u1eed c\u00e1c trang \u0111\u00e3 truy c\u1eadp khi ng\u01b0\u1eddi d\u00f9ng nh\u1ea5p v\u00e0o ti\u1ebfn ho\u1eb7c l\u00f9i.</li> <li>Thu\u1eadt to\u00e1n LRU: Danh s\u00e1ch li\u00ean k\u1ebft \u0111\u00f4i ph\u00f9 h\u1ee3p v\u1edbi c\u00e1c thu\u1eadt to\u00e1n lo\u1ea1i b\u1ecf b\u1ed9 nh\u1edb cache \u00cdt \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng g\u1ea7n \u0111\u00e2y nh\u1ea5t (LRU), cho ph\u00e9p x\u00e1c \u0111\u1ecbnh nhanh ch\u00f3ng d\u1eef li\u1ec7u \u00edt \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng g\u1ea7n \u0111\u00e2y nh\u1ea5t v\u00e0 t\u1ea1o \u0111i\u1ec1u ki\u1ec7n th\u00eam v\u00e0 x\u00f3a n\u00fat nhanh ch\u00f3ng.</li> </ul> <p>Danh s\u00e1ch li\u00ean k\u1ebft v\u00f2ng l\u00e0 l\u00fd t\u01b0\u1edfng cho c\u00e1c \u1ee9ng d\u1ee5ng y\u00eau c\u1ea7u c\u00e1c ho\u1ea1t \u0111\u1ed9ng \u0111\u1ecbnh k\u1ef3, ch\u1eb3ng h\u1ea1n nh\u01b0 l\u1eadp l\u1ecbch t\u00e0i nguy\u00ean trong h\u1ec7 \u0111i\u1ec1u h\u00e0nh.</p> <ul> <li>Thu\u1eadt to\u00e1n l\u1eadp l\u1ecbch v\u00f2ng tr\u00f2n: Trong h\u1ec7 \u0111i\u1ec1u h\u00e0nh, thu\u1eadt to\u00e1n l\u1eadp l\u1ecbch v\u00f2ng tr\u00f2n l\u00e0 m\u1ed9t ph\u01b0\u01a1ng ph\u00e1p l\u1eadp l\u1ecbch CPU ph\u1ed5 bi\u1ebfn, y\u00eau c\u1ea7u lu\u00e2n phi\u00ean qua m\u1ed9t nh\u00f3m c\u00e1c ti\u1ebfn tr\u00ecnh. M\u1ed7i ti\u1ebfn tr\u00ecnh \u0111\u01b0\u1ee3c g\u00e1n m\u1ed9t l\u00e1t th\u1eddi gian v\u00e0 khi h\u1ebft h\u1ea1n, CPU s\u1ebd xoay v\u00f2ng sang ti\u1ebfn tr\u00ecnh ti\u1ebfp theo. Ho\u1ea1t \u0111\u1ed9ng tu\u1ea7n ho\u00e0n n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n hi\u1ec7u qu\u1ea3 b\u1eb1ng c\u00e1ch s\u1eed d\u1ee5ng m\u1ed9t danh s\u00e1ch li\u00ean k\u1ebft v\u00f2ng, cho ph\u00e9p m\u1ed9t h\u1ec7 th\u1ed1ng c\u00f4ng b\u1eb1ng v\u00e0 chia s\u1ebb th\u1eddi gian gi\u1eefa t\u1ea5t c\u1ea3 c\u00e1c ti\u1ebfn tr\u00ecnh.</li> <li>B\u1ed9 \u0111\u1ec7m d\u1eef li\u1ec7u: Danh s\u00e1ch li\u00ean k\u1ebft v\u00f2ng c\u0169ng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng trong b\u1ed9 \u0111\u1ec7m d\u1eef li\u1ec7u, nh\u01b0 trong tr\u00ecnh ph\u00e1t \u00e2m thanh v\u00e0 video, n\u01a1i lu\u1ed3ng d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c chia th\u00e0nh nhi\u1ec1u kh\u1ed1i b\u1ed9 \u0111\u1ec7m \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo h\u00ecnh tr\u00f2n \u0111\u1ec3 ph\u00e1t l\u1ea1i li\u1ec1n m\u1ea1ch.</li> </ul>"},{"location":"chapter_array_and_linkedlist/list/","title":"4.3 List","text":""},{"location":"chapter_array_and_linkedlist/list/#list","title":"List","text":"<p>List l\u00e0 m\u1ed9t kh\u00e1i ni\u1ec7m c\u1ea5u tr\u00fac d\u1eef li\u1ec7u tr\u1eebu t\u01b0\u1ee3ng, \u0111\u1ea1i di\u1ec7n cho m\u1ed9t t\u1eadp h\u1ee3p c\u00e1c ph\u1ea7n t\u1eed c\u00f3 th\u1ee9 t\u1ef1, h\u1ed7 tr\u1ee3 c\u00e1c thao t\u00e1c nh\u01b0 truy c\u1eadp ph\u1ea7n t\u1eed, s\u1eeda \u0111\u1ed5i, th\u00eam, x\u00f3a v\u00e0 duy\u1ec7t, m\u00e0 kh\u00f4ng y\u00eau c\u1ea7u ng\u01b0\u1eddi d\u00f9ng ph\u1ea3i xem x\u00e9t gi\u1edbi h\u1ea1n v\u1ec1 dung l\u01b0\u1ee3ng. List c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c tri\u1ec3n khai d\u1ef1a tr\u00ean linked list ho\u1eb7c array.</p> <ul> <li>B\u1ea3n th\u00e2n linked list \u0111\u00e3 l\u00e0 m\u1ed9t list, h\u1ed7 tr\u1ee3 c\u00e1c thao t\u00e1c th\u00eam, x\u00f3a, t\u00ecm ki\u1ebfm v\u00e0 s\u1eeda \u0111\u1ed5i ph\u1ea7n t\u1eed, v\u1edbi s\u1ef1 linh ho\u1ea1t \u0111\u1ec3 \u0111i\u1ec1u ch\u1ec9nh k\u00edch th\u01b0\u1edbc m\u1ed9t c\u00e1ch \u0111\u1ed9ng.</li> <li>Array c\u0169ng h\u1ed7 tr\u1ee3 c\u00e1c thao t\u00e1c n\u00e0y, nh\u01b0ng do \u0111\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh c\u1ee7a ch\u00fang, ch\u00fang c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c coi l\u00e0 m\u1ed9t list c\u00f3 gi\u1edbi h\u1ea1n v\u1ec1 \u0111\u1ed9 d\u00e0i.</li> </ul> <p>Khi tri\u1ec3n khai list b\u1eb1ng array, t\u00ednh b\u1ea5t bi\u1ebfn v\u1ec1 \u0111\u1ed9 d\u00e0i l\u00e0m gi\u1ea3m t\u00ednh th\u1ef1c t\u1ebf c\u1ee7a list. \u0110i\u1ec1u n\u00e0y l\u00e0 do vi\u1ec7c d\u1ef1 \u0111o\u00e1n l\u01b0\u1ee3ng d\u1eef li\u1ec7u c\u1ea7n l\u01b0u tr\u1eef tr\u01b0\u1edbc l\u00e0 r\u1ea5t kh\u00f3, khi\u1ebfn cho vi\u1ec7c ch\u1ecdn \u0111\u1ed9 d\u00e0i list ph\u00f9 h\u1ee3p tr\u1edf n\u00ean kh\u00f3 kh\u0103n. N\u1ebfu \u0111\u1ed9 d\u00e0i qu\u00e1 nh\u1ecf, n\u00f3 c\u00f3 th\u1ec3 kh\u00f4ng \u0111\u00e1p \u1ee9ng \u0111\u01b0\u1ee3c y\u00eau c\u1ea7u; n\u1ebfu qu\u00e1 l\u1edbn, n\u00f3 c\u00f3 th\u1ec3 l\u00e3ng ph\u00ed kh\u00f4ng gian b\u1ed9 nh\u1edb.</p> <p>\u0110\u1ec3 gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 n\u00e0y, ch\u00fang ta c\u00f3 th\u1ec3 tri\u1ec3n khai list b\u1eb1ng dynamic array. N\u00f3 k\u1ebf th\u1eeba nh\u1eefng \u01b0u \u0111i\u1ec3m c\u1ee7a array v\u00e0 c\u00f3 th\u1ec3 m\u1edf r\u1ed9ng m\u1ed9t c\u00e1ch \u0111\u1ed9ng trong qu\u00e1 tr\u00ecnh th\u1ef1c thi ch\u01b0\u01a1ng tr\u00ecnh.</p> <p>Tr\u00ean th\u1ef1c t\u1ebf, th\u01b0 vi\u1ec7n chu\u1ea9n c\u1ee7a nhi\u1ec1u ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh tri\u1ec3n khai list b\u1eb1ng dynamic array, ch\u1eb3ng h\u1ea1n nh\u01b0 <code>list</code> c\u1ee7a Python, <code>ArrayList</code> c\u1ee7a Java, <code>vector</code> c\u1ee7a C++ v\u00e0 <code>List</code> c\u1ee7a C#. Trong c\u00e1c th\u1ea3o lu\u1eadn sau \u0111\u00e2y, ch\u00fang ta s\u1ebd coi \"list\" v\u00e0 \"dynamic array\" l\u00e0 c\u00e1c kh\u00e1i ni\u1ec7m \u0111\u1ed3ng ngh\u0129a.</p>"},{"location":"chapter_array_and_linkedlist/list/#cac-thao-tac-list-pho-bien","title":"C\u00e1c thao t\u00e1c list ph\u1ed5 bi\u1ebfn","text":""},{"location":"chapter_array_and_linkedlist/list/#khoi-tao-list","title":"Kh\u1edfi t\u1ea1o list","text":"<p>Ch\u00fang ta th\u01b0\u1eddng s\u1eed d\u1ee5ng hai ph\u01b0\u01a1ng ph\u00e1p kh\u1edfi t\u1ea1o: \"kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\" v\u00e0 \"c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\".</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># Kh\u1edfi t\u1ea1o list\n# Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nnums1: list[int] = []\n# C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nnums: list[int] = [1, 3, 2, 5, 4]\n</code></pre> list.cpp<pre><code>/* Kh\u1edfi t\u1ea1o list */\n// L\u01b0u \u00fd, trong C++ vector t\u01b0\u01a1ng \u0111\u01b0\u01a1ng v\u1edbi nums \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 \u1edf \u0111\u00e2y\n// Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nvector&lt;int&gt; nums1;\n// C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nvector&lt;int&gt; nums = { 1, 3, 2, 5, 4 };\n</code></pre> list.java<pre><code>/* Kh\u1edfi t\u1ea1o list */\n// Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nList&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;();\n// C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u (l\u01b0u \u00fd ki\u1ec3u ph\u1ea7n t\u1eed ph\u1ea3i l\u00e0 l\u1edbp wrapper Integer[] cho int[])\nInteger[] numbers = new Integer[] { 1, 3, 2, 5, 4 };\nList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(Arrays.asList(numbers));\n</code></pre> list.cs<pre><code>/* Kh\u1edfi t\u1ea1o list */\n// Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nList&lt;int&gt; nums1 = [];\n// C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nint[] numbers = [1, 3, 2, 5, 4];\nList&lt;int&gt; nums = [.. numbers];\n</code></pre> list_test.go<pre><code>/* Kh\u1edfi t\u1ea1o list */\n// Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nnums1 := []int{}\n// C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nnums := []int{1, 3, 2, 5, 4}\n</code></pre> list.swift<pre><code>/* Kh\u1edfi t\u1ea1o list */\n// Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nlet nums1: [Int] = []\n// C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nvar nums = [1, 3, 2, 5, 4]\n</code></pre> list.js<pre><code>/* Kh\u1edfi t\u1ea1o list */\n// Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nconst nums1 = [];\n// C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nconst nums = [1, 3, 2, 5, 4];\n</code></pre> list.ts<pre><code>/* Kh\u1edfi t\u1ea1o list */\n// Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nconst nums1: number[] = [];\n// C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nconst nums: number[] = [1, 3, 2, 5, 4];\n</code></pre> list.dart<pre><code>/* Kh\u1edfi t\u1ea1o list */\n// Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nList&lt;int&gt; nums1 = [];\n// C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nList&lt;int&gt; nums = [1, 3, 2, 5, 4];\n</code></pre> list.rs<pre><code>/* Kh\u1edfi t\u1ea1o list */\n// Kh\u00f4ng c\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nlet nums1: Vec&lt;i32&gt; = Vec::new();\n// C\u00f3 gi\u00e1 tr\u1ecb ban \u0111\u1ea7u\nlet nums: Vec&lt;i32&gt; = vec![1, 3, 2, 5, 4];\n</code></pre> list.c<pre><code>// C kh\u00f4ng cung c\u1ea5p dynamic array t\u00edch h\u1ee3p s\u1eb5n\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// Kh\u1edfi t\u1ea1o list\nvar nums = std.ArrayList(i32).init(std.heap.page_allocator);\ndefer nums.deinit();\ntry nums.appendSlice(&amp;[_]i32{ 1, 3, 2, 5, 4 });\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#truy-cap-cac-phan-tu","title":"Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed","text":"<p>List v\u1ec1 c\u01a1 b\u1ea3n l\u00e0 array, do \u0111\u00f3 ch\u00fang c\u00f3 th\u1ec3 truy c\u1eadp v\u00e0 c\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed trong th\u1eddi gian \\(O(1)\\), r\u1ea5t hi\u1ec7u qu\u1ea3.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed\nnum: int = nums[1]  # Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n# C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed\nnums[1] = 0    # C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list.cpp<pre><code>/* Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed */\nint num = nums[1];  // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n/* C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed */\nnums[1] = 0;  // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list.java<pre><code>/* Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed */\nint num = nums.get(1);  // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n/* C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed */\nnums.set(1, 0);  // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list.cs<pre><code>/* Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed */\nint num = nums[1];  // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n/* C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed */\nnums[1] = 0;  // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list_test.go<pre><code>/* Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed */\nnum := nums[1]  // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n/* C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed */\nnums[1] = 0     // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list.swift<pre><code>/* Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed */\nlet num = nums[1] // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n/* C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed */\nnums[1] = 0 // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list.js<pre><code>/* Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed */\nconst num = nums[1];  // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n/* C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed */\nnums[1] = 0;  // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list.ts<pre><code>/* Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed */\nconst num: number = nums[1];  // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n/* C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed */\nnums[1] = 0;  // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list.dart<pre><code>/* Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed */\nint num = nums[1];  // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n/* C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed */\nnums[1] = 0;  // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list.rs<pre><code>/* Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed */\nlet num: i32 = nums[1];  // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n/* C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed */\nnums[1] = 0;             // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0\n</code></pre> list.c<pre><code>// C kh\u00f4ng cung c\u1ea5p dynamic array t\u00edch h\u1ee3p s\u1eb5n\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// Truy c\u1eadp c\u00e1c ph\u1ea7n t\u1eed\nvar num = nums.items[1]; // Truy c\u1eadp ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1\n\n// C\u1eadp nh\u1eadt c\u00e1c ph\u1ea7n t\u1eed\nnums.items[1] = 0; // C\u1eadp nh\u1eadt ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 1 th\u00e0nh 0  \n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#chen-va-xoa-cac-phan-tu","title":"Ch\u00e8n v\u00e0 x\u00f3a c\u00e1c ph\u1ea7n t\u1eed","text":"<p>So v\u1edbi array, list cung c\u1ea5p s\u1ef1 linh ho\u1ea1t h\u01a1n trong vi\u1ec7c th\u00eam v\u00e0 x\u00f3a c\u00e1c ph\u1ea7n t\u1eed. M\u1eb7c d\u00f9 vi\u1ec7c th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i list l\u00e0 m\u1ed9t thao t\u00e1c \\(O(1)\\), hi\u1ec7u qu\u1ea3 c\u1ee7a vi\u1ec7c ch\u00e8n v\u00e0 x\u00f3a c\u00e1c ph\u1ea7n t\u1eed \u1edf nh\u1eefng n\u01a1i kh\u00e1c trong list v\u1eabn gi\u1ed1ng nh\u01b0 trong array, v\u1edbi \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian l\u00e0 \\(O(n)\\).</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># X\u00f3a list\nnums.clear()\n\n# Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i\nnums.append(1)\nnums.append(3)\nnums.append(2)\nnums.append(5)\nnums.append(4)\n\n# Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa\nnums.insert(3, 6)  # Ch\u00e8n s\u1ed1 6 v\u00e0o ch\u1ec9 s\u1ed1 3\n\n# X\u00f3a c\u00e1c ph\u1ea7n t\u1eed\nnums.pop(3)        # X\u00f3a ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 3\n</code></pre> list.cpp<pre><code>/* X\u00f3a list */\nnums.clear();\n\n/* Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i */\nnums.push_back(1);\nnums.push_back(3);\nnums.push_back(2);\nnums.push_back(5);\nnums.push_back(4);\n\n/* Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa */\nnums.insert(nums.begin() + 3, 6);  // Ch\u00e8n s\u1ed1 6 v\u00e0o ch\u1ec9 s\u1ed1 3\n\n/* X\u00f3a c\u00e1c ph\u1ea7n t\u1eed */\nnums.erase(nums.begin() + 3);      // X\u00f3a ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 3\n</code></pre> list.java<pre><code>/* X\u00f3a list */\nnums.clear();\n\n/* Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i */\nnums.add(1);\nnums.add(3);\nnums.add(2);\nnums.add(5);\nnums.add(4);\n\n/* Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa */\nnums.add(3, 6);  // Ch\u00e8n s\u1ed1 6 v\u00e0o ch\u1ec9 s\u1ed1 3\n\n/* X\u00f3a c\u00e1c ph\u1ea7n t\u1eed */\nnums.remove(3);  // X\u00f3a ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 3\n</code></pre> list.cs<pre><code>/* X\u00f3a list */\nnums.Clear();\n\n/* Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i */\nnums.Add(1);\nnums.Add(3);\nnums.Add(2);\nnums.Add(5);\nnums.Add(4);\n\n/* Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa */\nnums.Insert(3, 6);\n\n/* X\u00f3a c\u00e1c ph\u1ea7n t\u1eed */\nnums.RemoveAt(3);\n</code></pre> list_test.go<pre><code>/* X\u00f3a list */\nnums = nil\n\n/* Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i */\nnums = append(nums, 1)\nnums = append(nums, 3)\nnums = append(nums, 2)\nnums = append(nums, 5)\nnums = append(nums, 4)\n\n/* Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa */\nnums = append(nums[:3], append([]int{6}, nums[3:]...)...) // Ch\u00e8n s\u1ed1 6 v\u00e0o ch\u1ec9 s\u1ed1 3\n\n/* X\u00f3a c\u00e1c ph\u1ea7n t\u1eed */\nnums = append(nums[:3], nums[4:]...) // X\u00f3a ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 3\n</code></pre> list.swift<pre><code>/* X\u00f3a list */\nnums.removeAll()\n\n/* Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i */\nnums.append(1)\nnums.append(3)\nnums.append(2)\nnums.append(5)\nnums.append(4)\n\n/* Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa */\nnums.insert(6, at: 3) // Ch\u00e8n s\u1ed1 6 v\u00e0o ch\u1ec9 s\u1ed1 3\n\n/* X\u00f3a c\u00e1c ph\u1ea7n t\u1eed */\nnums.remove(at: 3) // X\u00f3a ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 3\n</code></pre> list.js<pre><code>/* X\u00f3a list */\nnums.length = 0;\n\n/* Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa */\nnums.splice(3, 0, 6);\n\n/* X\u00f3a c\u00e1c ph\u1ea7n t\u1eed */\nnums.splice(3, 1);\n</code></pre> list.ts<pre><code>/* X\u00f3a list */\nnums.length = 0;\n\n/* Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa */\nnums.splice(3, 0, 6);\n\n/* X\u00f3a c\u00e1c ph\u1ea7n t\u1eed */\nnums.splice(3, 1);\n</code></pre> list.dart<pre><code>/* X\u00f3a list */\nnums.clear();\n\n/* Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i */\nnums.add(1);\nnums.add(3);\nnums.add(2);\nnums.add(5);\nnums.add(4);\n\n/* Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa */\nnums.insert(3, 6); // Ch\u00e8n s\u1ed1 6 v\u00e0o ch\u1ec9 s\u1ed1 3\n\n/* X\u00f3a c\u00e1c ph\u1ea7n t\u1eed */\nnums.removeAt(3); // X\u00f3a ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 3\n</code></pre> list.rs<pre><code>/* X\u00f3a list */\nnums.clear();\n\n/* Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i */\nnums.push(1);\nnums.push(3);\nnums.push(2);\nnums.push(5);\nnums.push(4);\n\n/* Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa */\nnums.insert(3, 6);  // Ch\u00e8n s\u1ed1 6 v\u00e0o ch\u1ec9 s\u1ed1 3\n\n/* X\u00f3a c\u00e1c ph\u1ea7n t\u1eed */\nnums.remove(3);    // X\u00f3a ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 3\n</code></pre> list.c<pre><code>// C kh\u00f4ng cung c\u1ea5p dynamic array t\u00edch h\u1ee3p s\u1eb5n\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// X\u00f3a list\nnums.clearRetainingCapacity();\n\n// Th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i\ntry nums.append(1);\ntry nums.append(3);\ntry nums.append(2);\ntry nums.append(5);\ntry nums.append(4);\n\n// Ch\u00e8n ph\u1ea7n t\u1eed v\u00e0o gi\u1eefa\ntry nums.insert(3, 6); // Ch\u00e8n s\u1ed1 6 v\u00e0o ch\u1ec9 s\u1ed1 3\n\n// X\u00f3a c\u00e1c ph\u1ea7n t\u1eed\n_ = nums.orderedRemove(3); // X\u00f3a ph\u1ea7n t\u1eed t\u1ea1i ch\u1ec9 s\u1ed1 3\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#duyet-list","title":"Duy\u1ec7t list","text":"<p>T\u01b0\u01a1ng t\u1ef1 nh\u01b0 array, list c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c duy\u1ec7t b\u1eb1ng c\u00e1ch s\u1eed d\u1ee5ng ch\u1ec9 s\u1ed1 ho\u1eb7c b\u1eb1ng c\u00e1ch duy\u1ec7t tr\u1ef1c ti\u1ebfp qua t\u1eebng ph\u1ea7n t\u1eed.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1\ncount = 0\nfor i in range(len(nums)):\n    count += nums[i]\n\n# Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list\nfor num in nums:\n    count += num\n</code></pre> list.cpp<pre><code>/* Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1 */\nint count = 0;\nfor (int i = 0; i &lt; nums.size(); i++) {\n    count += nums[i];\n}\n\n/* Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list */\ncount = 0;\nfor (int num : nums) {\n    count += num;\n}\n</code></pre> list.java<pre><code>/* Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1 */\nint count = 0;\nfor (int i = 0; i &lt; nums.size(); i++) {\n    count += nums.get(i);\n}\n\n/* Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list */\nfor (int num : nums) {\n    count += num;\n}\n</code></pre> list.cs<pre><code>/* Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1 */\nint count = 0;\nfor (int i = 0; i &lt; nums.Count; i++) {\n    count += nums[i];\n}\n\n/* Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list */\ncount = 0;\nforeach (int num in nums) {\n    count += num;\n}\n</code></pre> list_test.go<pre><code>/* Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1 */\ncount := 0\nfor i := 0; i &lt; len(nums); i++ {\n    count += nums[i]\n}\n\n/* Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list */\ncount = 0\nfor _, num := range nums {\n    count += num\n}\n</code></pre> list.swift<pre><code>/* Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1 */\nvar count = 0\nfor i in nums.indices {\n    count += nums[i]\n}\n\n/* Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list */\ncount = 0\nfor num in nums {\n    count += num\n}\n</code></pre> list.js<pre><code>/* Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1 */\nlet count = 0;\nfor (let i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list */\ncount = 0;\nfor (const num of nums) {\n    count += num;\n}\n</code></pre> list.ts<pre><code>/* Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1 */\nlet count = 0;\nfor (let i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list */\ncount = 0;\nfor (const num of nums) {\n    count += num;\n}\n</code></pre> list.dart<pre><code>/* Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1 */\nint count = 0;\nfor (var i = 0; i &lt; nums.length; i++) {\n    count += nums[i];\n}\n\n/* Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list */\ncount = 0;\nfor (var num in nums) {\n    count += num;\n}\n</code></pre> list.rs<pre><code>// Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1\nlet mut _count = 0;\nfor i in 0..nums.len() {\n    _count += nums[i];\n}\n\n// Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list\n_count = 0;\nfor num in &amp;nums {\n    _count += num;\n}\n</code></pre> list.c<pre><code>// C kh\u00f4ng cung c\u1ea5p dynamic array t\u00edch h\u1ee3p s\u1eb5n\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// Duy\u1ec7t list b\u1eb1ng ch\u1ec9 s\u1ed1\nvar count: i32 = 0;\nvar i: i32 = 0;\nwhile (i &lt; nums.items.len) : (i += 1) {\n    count += nums[i];\n}\n\n// Duy\u1ec7t tr\u1ef1c ti\u1ebfp qua c\u00e1c ph\u1ea7n t\u1eed list\ncount = 0;\nfor (nums.items) |num| {\n    count += num;\n}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#noi-cac-list","title":"N\u1ed1i c\u00e1c list","text":"<p>Cho m\u1ed9t list m\u1edbi <code>nums1</code>, ch\u00fang ta c\u00f3 th\u1ec3 n\u1ed1i n\u00f3 v\u00e0o cu\u1ed1i list ban \u0111\u1ea7u.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># N\u1ed1i hai list\nnums1: list[int] = [6, 8, 7, 10, 9]\nnums += nums1  # N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\n</code></pre> list.cpp<pre><code>/* N\u1ed1i hai list */\nvector&lt;int&gt; nums1 = { 6, 8, 7, 10, 9 };\n// N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\nnums.insert(nums.end(), nums1.begin(), nums1.end());\n</code></pre> list.java<pre><code>/* N\u1ed1i hai list */\nList&lt;Integer&gt; nums1 = new ArrayList&lt;&gt;(Arrays.asList(new Integer[] { 6, 8, 7, 10, 9 }));\nnums.addAll(nums1);  // N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\n</code></pre> list.cs<pre><code>/* N\u1ed1i hai list */\nList&lt;int&gt; nums1 = [6, 8, 7, 10, 9];\nnums.AddRange(nums1);  // N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\n</code></pre> list_test.go<pre><code>/* N\u1ed1i hai list */\nnums1 := []int{6, 8, 7, 10, 9}\nnums = append(nums, nums1...)  // N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\n</code></pre> list.swift<pre><code>/* N\u1ed1i hai list */\nlet nums1 = [6, 8, 7, 10, 9]\nnums.append(contentsOf: nums1) // N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\n</code></pre> list.js<pre><code>/* N\u1ed1i hai list */\nconst nums1 = [6, 8, 7, 10, 9];\nnums.push(...nums1);  // N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\n</code></pre> list.ts<pre><code>/* N\u1ed1i hai list */\nconst nums1: number[] = [6, 8, 7, 10, 9];\nnums.push(...nums1);  // N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\n</code></pre> list.dart<pre><code>/* N\u1ed1i hai list */\nList&lt;int&gt; nums1 = [6, 8, 7, 10, 9];\nnums.addAll(nums1);  // N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\n</code></pre> list.rs<pre><code>/* N\u1ed1i hai list */\nlet nums1: Vec&lt;i32&gt; = vec![6, 8, 7, 10, 9];\nnums.extend(nums1);\n</code></pre> list.c<pre><code>// C kh\u00f4ng cung c\u1ea5p dynamic array t\u00edch h\u1ee3p s\u1eb5n\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// N\u1ed1i hai list\nvar nums1 = std.ArrayList(i32).init(std.heap.page_allocator);\ndefer nums1.deinit();\ntry nums1.appendSlice(&amp;[_]i32{ 6, 8, 7, 10, 9 });\ntry nums.insertSlice(nums.items.len, nums1.items); // N\u1ed1i nums1 v\u00e0o cu\u1ed1i nums\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#sap-xep-list","title":"S\u1eafp x\u1ebfp list","text":"<p>Sau khi list \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp, ch\u00fang ta c\u00f3 th\u1ec3 s\u1eed d\u1ee5ng c\u00e1c thu\u1eadt to\u00e1n th\u01b0\u1eddng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng trong c\u00e1c b\u00e0i to\u00e1n thu\u1eadt to\u00e1n li\u00ean quan \u0111\u1ebfn array, ch\u1eb3ng h\u1ea1n nh\u01b0 thu\u1eadt to\u00e1n \"t\u00ecm ki\u1ebfm nh\u1ecb ph\u00e2n\" v\u00e0 \"two-pointer\".</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig list.py<pre><code># S\u1eafp x\u1ebfp list\nnums.sort()  # Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list.cpp<pre><code>/* S\u1eafp x\u1ebfp list */\nsort(nums.begin(), nums.end());  // Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list.java<pre><code>/* S\u1eafp x\u1ebfp list */\nCollections.sort(nums);  // Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list.cs<pre><code>/* S\u1eafp x\u1ebfp list */\nnums.Sort(); // Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list_test.go<pre><code>/* S\u1eafp x\u1ebfp list */\nsort.Ints(nums)  // Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list.swift<pre><code>/* S\u1eafp x\u1ebfp list */\nnums.sort() // Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list.js<pre><code>/* S\u1eafp x\u1ebfp list */  \nnums.sort((a, b) =&gt; a - b);  // Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list.ts<pre><code>/* S\u1eafp x\u1ebfp list */\nnums.sort((a, b) =&gt; a - b);  // Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list.dart<pre><code>/* S\u1eafp x\u1ebfp list */\nnums.sort(); // Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list.rs<pre><code>/* S\u1eafp x\u1ebfp list */\nnums.sort(); // Sau khi s\u1eafp x\u1ebfp, c\u00e1c ph\u1ea7n t\u1eed list theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n\n</code></pre> list.c<pre><code>// C kh\u00f4ng cung c\u1ea5p dynamic array t\u00edch h\u1ee3p s\u1eb5n\n</code></pre> list.kt<pre><code>\n</code></pre> list.zig<pre><code>// S\u1eafp x\u1ebfp list\nstd.sort.sort(i32, nums.items, {}, comptime std.sort.asc(i32));\n</code></pre>"},{"location":"chapter_array_and_linkedlist/list/#trien-khai-list","title":"Tri\u1ec3n khai list","text":"<p>Nhi\u1ec1u ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh \u0111i k\u00e8m v\u1edbi list t\u00edch h\u1ee3p s\u1eb5n, bao g\u1ed3m Java, C++, Python, v.v. Vi\u1ec7c tri\u1ec3n khai c\u1ee7a ch\u00fang c\u00f3 xu h\u01b0\u1edbng ph\u1ee9c t\u1ea1p, c\u00f3 c\u00e1c c\u00e0i \u0111\u1eb7t \u0111\u01b0\u1ee3c c\u00e2n nh\u1eafc c\u1ea9n th\u1eadn cho c\u00e1c tham s\u1ed1 kh\u00e1c nhau, nh\u01b0 dung l\u01b0\u1ee3ng ban \u0111\u1ea7u v\u00e0 h\u1ec7 s\u1ed1 m\u1edf r\u1ed9ng. \u0110\u1ed9c gi\u1ea3 n\u00e0o t\u00f2 m\u00f2 c\u00f3 th\u1ec3 \u0111i s\u00e2u v\u00e0o m\u00e3 ngu\u1ed3n \u0111\u1ec3 t\u00ecm hi\u1ec3u th\u00eam.</p> <p>\u0110\u1ec3 n\u00e2ng cao hi\u1ec3u bi\u1ebft c\u1ee7a ch\u00fang ta v\u1ec1 c\u00e1ch list ho\u1ea1t \u0111\u1ed9ng, ch\u00fang ta s\u1ebd th\u1eed tri\u1ec3n khai m\u1ed9t phi\u00ean b\u1ea3n \u0111\u01a1n gi\u1ea3n c\u1ee7a list, t\u1eadp trung v\u00e0o ba kh\u00eda c\u1ea1nh thi\u1ebft k\u1ebf quan tr\u1ecdng:</p> <ul> <li>Dung l\u01b0\u1ee3ng ban \u0111\u1ea7u: Ch\u1ecdn dung l\u01b0\u1ee3ng ban \u0111\u1ea7u h\u1ee3p l\u00fd cho array. Trong v\u00ed d\u1ee5 n\u00e0y, ch\u00fang ta ch\u1ecdn 10 l\u00e0m dung l\u01b0\u1ee3ng ban \u0111\u1ea7u.</li> <li>Ghi l\u1ea1i k\u00edch th\u01b0\u1edbc: Khai b\u00e1o m\u1ed9t bi\u1ebfn <code>size</code> \u0111\u1ec3 ghi l\u1ea1i s\u1ed1 l\u01b0\u1ee3ng ph\u1ea7n t\u1eed hi\u1ec7n t\u1ea1i trong list, c\u1eadp nh\u1eadt theo th\u1eddi gian th\u1ef1c khi ch\u00e8n v\u00e0 x\u00f3a ph\u1ea7n t\u1eed. V\u1edbi bi\u1ebfn n\u00e0y, ch\u00fang ta c\u00f3 th\u1ec3 x\u00e1c \u0111\u1ecbnh v\u1ecb tr\u00ed cu\u1ed1i list v\u00e0 x\u00e1c \u0111\u1ecbnh xem c\u00f3 c\u1ea7n m\u1edf r\u1ed9ng hay kh\u00f4ng.</li> <li>C\u01a1 ch\u1ebf m\u1edf r\u1ed9ng: N\u1ebfu list \u0111\u1ea1t \u0111\u1ebfn dung l\u01b0\u1ee3ng t\u1ed1i \u0111a khi ch\u00e8n m\u1ed9t ph\u1ea7n t\u1eed, c\u1ea7n c\u00f3 m\u1ed9t quy tr\u00ecnh m\u1edf r\u1ed9ng. \u0110i\u1ec1u n\u00e0y bao g\u1ed3m vi\u1ec7c t\u1ea1o m\u1ed9t array l\u1edbn h\u01a1n d\u1ef1a tr\u00ean h\u1ec7 s\u1ed1 m\u1edf r\u1ed9ng, v\u00e0 sau \u0111\u00f3 chuy\u1ec3n t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed t\u1eeb array hi\u1ec7n t\u1ea1i sang array m\u1edbi. Trong v\u00ed d\u1ee5 n\u00e0y, ch\u00fang ta quy \u0111\u1ecbnh r\u1eb1ng k\u00edch th\u01b0\u1edbc array s\u1ebd t\u0103ng g\u1ea5p \u0111\u00f4i sau m\u1ed7i l\u1ea7n m\u1edf r\u1ed9ng.</li> </ul> <pre><code>[file]{my_list}-[class]{my_list}-[func]{}\n</code></pre>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/","title":"4.4 Memory and cache *","text":""},{"location":"chapter_array_and_linkedlist/ram_and_cache/#bo-nho-va-cache","title":"B\u1ed9 nh\u1edb v\u00e0 cache *","text":"<p>Trong hai ph\u1ea7n \u0111\u1ea7u c\u1ee7a ch\u01b0\u01a1ng n\u00e0y, ch\u00fang ta \u0111\u00e3 kh\u00e1m ph\u00e1 m\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft, hai c\u1ea5u tr\u00fac d\u1eef li\u1ec7u c\u01a1 b\u1ea3n \u0111\u1ea1i di\u1ec7n cho \"l\u01b0u tr\u1eef li\u00ean t\u1ee5c\" v\u00e0 \"l\u01b0u tr\u1eef ph\u00e2n t\u00e1n\".</p> <p>Tr\u00ean th\u1ef1c t\u1ebf, c\u1ea5u tr\u00fac v\u1eadt l\u00fd ph\u1ea7n l\u1edbn quy\u1ebft \u0111\u1ecbnh m\u1ee9c \u0111\u1ed9 hi\u1ec7u qu\u1ea3 c\u1ee7a ch\u01b0\u01a1ng tr\u00ecnh trong vi\u1ec7c s\u1eed d\u1ee5ng b\u1ed9 nh\u1edb v\u00e0 cache, t\u1eeb \u0111\u00f3 \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn hi\u1ec7u su\u1ea5t t\u1ed5ng th\u1ec3 c\u1ee7a thu\u1eadt to\u00e1n.</p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#thiet-bi-luu-tru-may-tinh","title":"Thi\u1ebft b\u1ecb l\u01b0u tr\u1eef m\u00e1y t\u00ednh","text":"<p>C\u00f3 ba lo\u1ea1i thi\u1ebft b\u1ecb l\u01b0u tr\u1eef trong m\u00e1y t\u00ednh: \u1ed5 c\u1ee9ng, b\u1ed9 nh\u1edb truy c\u1eadp ng\u1eabu nhi\u00ean (RAM) v\u00e0 b\u1ed9 nh\u1edb cache. B\u1ea3ng sau \u0111\u00e2y cho th\u1ea5y vai tr\u00f2 v\u00e0 \u0111\u1eb7c \u0111i\u1ec3m hi\u1ec7u su\u1ea5t t\u01b0\u01a1ng \u1ee9ng c\u1ee7a ch\u00fang trong h\u1ec7 th\u1ed1ng m\u00e1y t\u00ednh.</p> <p> B\u1ea3ng  \u00a0 Thi\u1ebft b\u1ecb l\u01b0u tr\u1eef m\u00e1y t\u00ednh </p> \u1ed4 c\u1ee9ng B\u1ed9 nh\u1edb Cache S\u1eed d\u1ee5ng L\u01b0u tr\u1eef d\u1eef li\u1ec7u d\u00e0i h\u1ea1n, bao g\u1ed3m H\u0110H, ch\u01b0\u01a1ng tr\u00ecnh, t\u1ec7p, v.v. L\u01b0u tr\u1eef t\u1ea1m th\u1eddi c\u00e1c ch\u01b0\u01a1ng tr\u00ecnh \u0111ang ch\u1ea1y v\u00e0 d\u1eef li\u1ec7u \u0111ang \u0111\u01b0\u1ee3c x\u1eed l\u00fd L\u01b0u tr\u1eef d\u1eef li\u1ec7u v\u00e0 l\u1ec7nh th\u01b0\u1eddng xuy\u00ean \u0111\u01b0\u1ee3c truy c\u1eadp, gi\u1ea3m s\u1ed1 l\u1ea7n CPU truy c\u1eadp v\u00e0o b\u1ed9 nh\u1edb T\u00ednh kh\u1ea3 bi\u1ebfn D\u1eef li\u1ec7u kh\u00f4ng b\u1ecb m\u1ea5t sau khi t\u1eaft ngu\u1ed3n D\u1eef li\u1ec7u b\u1ecb m\u1ea5t sau khi t\u1eaft ngu\u1ed3n D\u1eef li\u1ec7u b\u1ecb m\u1ea5t sau khi t\u1eaft ngu\u1ed3n Dung l\u01b0\u1ee3ng L\u1edbn h\u01a1n, m\u1ee9c TB Nh\u1ecf h\u01a1n, m\u1ee9c GB R\u1ea5t nh\u1ecf, m\u1ee9c MB T\u1ed1c \u0111\u1ed9 Ch\u1eadm h\u01a1n, v\u00e0i tr\u0103m \u0111\u1ebfn h\u00e0ng ngh\u00ecn MB/s Nhanh h\u01a1n, v\u00e0i ch\u1ee5c GB/s R\u1ea5t nhanh, v\u00e0i ch\u1ee5c \u0111\u1ebfn h\u00e0ng tr\u0103m GB/s Gi\u00e1 (USD) R\u1ebb h\u01a1n, v\u00e0i xu / GB \u0110\u1eaft h\u01a1n, v\u00e0i \u0111\u00f4 la / GB R\u1ea5t \u0111\u1eaft, \u0111\u01b0\u1ee3c \u0111\u1ecbnh gi\u00e1 c\u00f9ng v\u1edbi CPU <p>H\u1ec7 th\u1ed1ng l\u01b0u tr\u1eef m\u00e1y t\u00ednh c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c h\u00ecnh dung nh\u01b0 m\u1ed9t kim t\u1ef1 th\u00e1p, nh\u01b0 trong h\u00ecnh b\u00ean d\u01b0\u1edbi. C\u00e1c thi\u1ebft b\u1ecb l\u01b0u tr\u1eef \u1edf \u0111\u1ec9nh kim t\u1ef1 th\u00e1p nhanh h\u01a1n, c\u00f3 dung l\u01b0\u1ee3ng nh\u1ecf h\u01a1n v\u00e0 \u0111\u1eaft h\u01a1n. Thi\u1ebft k\u1ebf \u0111a c\u1ea5p n\u00e0y kh\u00f4ng ph\u1ea3i l\u00e0 ng\u1eabu nhi\u00ean, m\u00e0 l\u00e0 k\u1ebft qu\u1ea3 c\u00f3 ch\u1ee7 \u00fd t\u1eeb s\u1ef1 c\u00e2n nh\u1eafc c\u1ea9n th\u1eadn c\u1ee7a c\u00e1c nh\u00e0 khoa h\u1ecdc m\u00e1y t\u00ednh v\u00e0 k\u1ef9 s\u01b0.</p> <ul> <li>Vi\u1ec7c thay th\u1ebf \u1ed5 c\u1ee9ng b\u1eb1ng b\u1ed9 nh\u1edb l\u00e0 kh\u00f3 kh\u0103n. Th\u1ee9 nh\u1ea5t, d\u1eef li\u1ec7u trong b\u1ed9 nh\u1edb b\u1ecb m\u1ea5t sau khi t\u1eaft ngu\u1ed3n, khi\u1ebfn n\u00f3 kh\u00f4ng ph\u00f9 h\u1ee3p \u0111\u1ec3 l\u01b0u tr\u1eef d\u1eef li\u1ec7u d\u00e0i h\u1ea1n; th\u1ee9 hai, b\u1ed9 nh\u1edb \u0111\u1eaft h\u01a1n \u0111\u00e1ng k\u1ec3 so v\u1edbi \u1ed5 c\u1ee9ng, h\u1ea1n ch\u1ebf t\u00ednh kh\u1ea3 thi c\u1ee7a n\u00f3 \u0111\u1ec3 s\u1eed d\u1ee5ng r\u1ed9ng r\u00e3i tr\u00ean th\u1ecb tr\u01b0\u1eddng ti\u00eau d\u00f9ng.</li> <li>Cache ph\u1ea3i \u0111\u1ed1i m\u1eb7t v\u1edbi s\u1ef1 \u0111\u00e1nh \u0111\u1ed5i gi\u1eefa dung l\u01b0\u1ee3ng l\u1edbn v\u00e0 t\u1ed1c \u0111\u1ed9 cao. Khi dung l\u01b0\u1ee3ng c\u1ee7a b\u1ed9 nh\u1edb cache L1, L2 v\u00e0 L3 t\u0103ng l\u00ean, k\u00edch th\u01b0\u1edbc v\u1eadt l\u00fd c\u1ee7a ch\u00fang t\u0103ng l\u00ean, l\u00e0m t\u0103ng kho\u1ea3ng c\u00e1ch t\u1eeb l\u00f5i CPU. \u0110i\u1ec1u n\u00e0y d\u1eabn \u0111\u1ebfn th\u1eddi gian truy\u1ec1n d\u1eef li\u1ec7u d\u00e0i h\u01a1n v\u00e0 \u0111\u1ed9 tr\u1ec5 truy c\u1eadp cao h\u01a1n. V\u1edbi c\u00f4ng ngh\u1ec7 hi\u1ec7n t\u1ea1i, c\u1ea5u tr\u00fac b\u1ed9 nh\u1edb cache \u0111a c\u1ea5p mang l\u1ea1i s\u1ef1 c\u00e2n b\u1eb1ng t\u1ed1i \u01b0u gi\u1eefa dung l\u01b0\u1ee3ng, t\u1ed1c \u0111\u1ed9 v\u00e0 chi ph\u00ed.</li> </ul> <p></p> <p>Tip</p> <p>H\u1ec7 th\u1ed1ng ph\u00e2n c\u1ea5p l\u01b0u tr\u1eef trong m\u00e1y t\u00ednh ph\u1ea3n \u00e1nh s\u1ef1 c\u00e2n b\u1eb1ng c\u1ea9n th\u1eadn gi\u1eefa t\u1ed1c \u0111\u1ed9, dung l\u01b0\u1ee3ng v\u00e0 chi ph\u00ed. Lo\u1ea1i \u0111\u00e1nh \u0111\u1ed5i n\u00e0y l\u00e0 ph\u1ed5 bi\u1ebfn trong nhi\u1ec1u ng\u00e0nh c\u00f4ng nghi\u1ec7p kh\u00e1c nhau, n\u01a1i vi\u1ec7c t\u00ecm ki\u1ebfm s\u1ef1 c\u00e2n b\u1eb1ng t\u1ed1i \u01b0u gi\u1eefa l\u1ee3i \u00edch v\u00e0 h\u1ea1n ch\u1ebf l\u00e0 r\u1ea5t quan tr\u1ecdng.</p> <p>Nh\u00ecn chung, \u1ed5 c\u1ee9ng cung c\u1ea5p b\u1ed9 nh\u1edb d\u00e0i h\u1ea1n cho kh\u1ed1i l\u01b0\u1ee3ng l\u1edbn d\u1eef li\u1ec7u, b\u1ed9 nh\u1edb \u0111\u00f3ng vai tr\u00f2 l\u00e0 b\u1ed9 nh\u1edb t\u1ea1m th\u1eddi cho d\u1eef li\u1ec7u \u0111ang \u0111\u01b0\u1ee3c x\u1eed l\u00fd trong qu\u00e1 tr\u00ecnh th\u1ef1c thi ch\u01b0\u01a1ng tr\u00ecnh v\u00e0 cache l\u01b0u tr\u1eef d\u1eef li\u1ec7u v\u00e0 l\u1ec7nh th\u01b0\u1eddng xuy\u00ean \u0111\u01b0\u1ee3c truy c\u1eadp \u0111\u1ec3 n\u00e2ng cao hi\u1ec7u qu\u1ea3 th\u1ef1c thi. C\u00f9ng nhau, ch\u00fang \u0111\u1ea3m b\u1ea3o ho\u1ea1t \u0111\u1ed9ng hi\u1ec7u qu\u1ea3 c\u1ee7a h\u1ec7 th\u1ed1ng m\u00e1y t\u00ednh.</p> <p>Nh\u01b0 trong h\u00ecnh b\u00ean d\u01b0\u1edbi, trong qu\u00e1 tr\u00ecnh th\u1ef1c thi ch\u01b0\u01a1ng tr\u00ecnh, d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c \u0111\u1ecdc t\u1eeb \u1ed5 c\u1ee9ng v\u00e0o b\u1ed9 nh\u1edb \u0111\u1ec3 CPU t\u00ednh to\u00e1n. Cache, \u0111\u00f3ng vai tr\u00f2 l\u00e0 m\u1ed9t ph\u1ea7n m\u1edf r\u1ed9ng c\u1ee7a CPU, t\u1ef1 \u0111\u1ed9ng t\u1ea3i tr\u01b0\u1edbc d\u1eef li\u1ec7u t\u1eeb b\u1ed9 nh\u1edb, cho ph\u00e9p CPU truy c\u1eadp d\u1eef li\u1ec7u nhanh h\u01a1n. \u0110i\u1ec1u n\u00e0y c\u1ea3i thi\u1ec7n \u0111\u00e1ng k\u1ec3 hi\u1ec7u qu\u1ea3 th\u1ef1c thi ch\u01b0\u01a1ng tr\u00ecnh \u0111\u1ed3ng th\u1eddi gi\u1ea3m s\u1ef1 ph\u1ee5 thu\u1ed9c v\u00e0o b\u1ed9 nh\u1edb ch\u1eadm h\u01a1n.</p> <p></p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#hieu-qua-bo-nho-cua-cau-truc-du-lieu","title":"Hi\u1ec7u qu\u1ea3 b\u1ed9 nh\u1edb c\u1ee7a c\u1ea5u tr\u00fac d\u1eef li\u1ec7u","text":"<p>V\u1ec1 m\u1eb7t s\u1eed d\u1ee5ng kh\u00f4ng gian b\u1ed9 nh\u1edb, m\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft c\u00f3 nh\u1eefng \u01b0u \u0111i\u1ec3m v\u00e0 h\u1ea1n ch\u1ebf ri\u00eang.</p> <p>M\u1ed9t m\u1eb7t, b\u1ed9 nh\u1edb c\u00f3 gi\u1edbi h\u1ea1n v\u00e0 kh\u00f4ng th\u1ec3 \u0111\u01b0\u1ee3c chia s\u1ebb b\u1edfi nhi\u1ec1u ch\u01b0\u01a1ng tr\u00ecnh, v\u00ec v\u1eady vi\u1ec7c t\u1ed1i \u01b0u h\u00f3a vi\u1ec7c s\u1eed d\u1ee5ng kh\u00f4ng gian trong c\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u00e0 r\u1ea5t quan tr\u1ecdng. M\u1ea3ng ti\u1ebft ki\u1ec7m kh\u00f4ng gian v\u00ec c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a ch\u00fang \u0111\u01b0\u1ee3c \u0111\u00f3ng g\u00f3i ch\u1eb7t ch\u1ebd, kh\u00f4ng y\u00eau c\u1ea7u th\u00eam b\u1ed9 nh\u1edb cho c\u00e1c tham chi\u1ebfu (con tr\u1ecf) nh\u01b0 trong danh s\u00e1ch li\u00ean k\u1ebft. Tuy nhi\u00ean, m\u1ea3ng y\u00eau c\u1ea7u ph\u00e2n b\u1ed5 tr\u01b0\u1edbc m\u1ed9t kh\u1ed1i b\u1ed9 nh\u1edb li\u1ec1n k\u1ec1, \u0111i\u1ec1u n\u00e0y c\u00f3 th\u1ec3 d\u1eabn \u0111\u1ebfn l\u00e3ng ph\u00ed n\u1ebfu kh\u00f4ng gian \u0111\u01b0\u1ee3c ph\u00e2n b\u1ed5 v\u01b0\u1ee3t qu\u00e1 nhu c\u1ea7u th\u1ef1c t\u1ebf. M\u1edf r\u1ed9ng m\u1ed9t m\u1ea3ng c\u0169ng ph\u00e1t sinh th\u00eam chi ph\u00ed v\u1ec1 th\u1eddi gian v\u00e0 kh\u00f4ng gian. Ng\u01b0\u1ee3c l\u1ea1i, danh s\u00e1ch li\u00ean k\u1ebft ph\u00e2n b\u1ed5 v\u00e0 gi\u1ea3i ph\u00f3ng b\u1ed9 nh\u1edb \u0111\u1ed9ng cho m\u1ed7i n\u00fat, mang l\u1ea1i s\u1ef1 linh ho\u1ea1t cao h\u01a1n v\u1edbi chi ph\u00ed th\u00eam b\u1ed9 nh\u1edb cho con tr\u1ecf.</p> <p>M\u1eb7t kh\u00e1c, trong qu\u00e1 tr\u00ecnh th\u1ef1c thi ch\u01b0\u01a1ng tr\u00ecnh, vi\u1ec7c ph\u00e2n b\u1ed5 v\u00e0 gi\u1ea3i ph\u00f3ng b\u1ed9 nh\u1edb l\u1eb7p \u0111i l\u1eb7p l\u1ea1i l\u00e0m t\u0103ng s\u1ef1 ph\u00e2n m\u1ea3nh b\u1ed9 nh\u1edb, l\u00e0m gi\u1ea3m hi\u1ec7u qu\u1ea3 s\u1eed d\u1ee5ng b\u1ed9 nh\u1edb. M\u1ea3ng, do ph\u01b0\u01a1ng ph\u00e1p l\u01b0u tr\u1eef li\u00ean t\u1ee5c c\u1ee7a ch\u00fang, \u00edt c\u00f3 kh\u1ea3 n\u0103ng g\u00e2y ra ph\u00e2n m\u1ea3nh b\u1ed9 nh\u1edb h\u01a1n. Ng\u01b0\u1ee3c l\u1ea1i, danh s\u00e1ch li\u00ean k\u1ebft l\u01b0u tr\u1eef c\u00e1c ph\u1ea7n t\u1eed \u1edf c\u00e1c v\u1ecb tr\u00ed kh\u00f4ng li\u1ec1n k\u1ec1 v\u00e0 vi\u1ec7c ch\u00e8n v\u00e0 x\u00f3a th\u01b0\u1eddng xuy\u00ean c\u00f3 th\u1ec3 l\u00e0m tr\u1ea7m tr\u1ecdng th\u00eam s\u1ef1 ph\u00e2n m\u1ea3nh b\u1ed9 nh\u1edb.</p>"},{"location":"chapter_array_and_linkedlist/ram_and_cache/#hieu-qua-cache-cua-cau-truc-du-lieu","title":"Hi\u1ec7u qu\u1ea3 cache c\u1ee7a c\u1ea5u tr\u00fac d\u1eef li\u1ec7u","text":"<p>M\u1eb7c d\u00f9 b\u1ed9 nh\u1edb cache c\u00f3 dung l\u01b0\u1ee3ng nh\u1ecf h\u01a1n nhi\u1ec1u so v\u1edbi b\u1ed9 nh\u1edb, nh\u01b0ng ch\u00fang nhanh h\u01a1n nhi\u1ec1u v\u00e0 \u0111\u00f3ng m\u1ed9t vai tr\u00f2 quan tr\u1ecdng trong t\u1ed1c \u0111\u1ed9 th\u1ef1c thi ch\u01b0\u01a1ng tr\u00ecnh. Do dung l\u01b0\u1ee3ng h\u1ea1n ch\u1ebf, b\u1ed9 nh\u1edb cache ch\u1ec9 c\u00f3 th\u1ec3 l\u01b0u tr\u1eef m\u1ed9t t\u1eadp h\u1ee3p con d\u1eef li\u1ec7u th\u01b0\u1eddng xuy\u00ean \u0111\u01b0\u1ee3c truy c\u1eadp. Khi CPU c\u1ed1 g\u1eafng truy c\u1eadp d\u1eef li\u1ec7u kh\u00f4ng c\u00f3 trong b\u1ed9 nh\u1edb cache, s\u1ebd x\u1ea3y ra l\u1ed7i cache, y\u00eau c\u1ea7u CPU truy xu\u1ea5t d\u1eef li\u1ec7u c\u1ea7n thi\u1ebft t\u1eeb b\u1ed9 nh\u1edb ch\u1eadm h\u01a1n, \u0111i\u1ec1u n\u00e0y c\u00f3 th\u1ec3 \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn hi\u1ec7u su\u1ea5t.</p> <p>R\u00f5 r\u00e0ng, c\u00e0ng \u00edt l\u1ed7i cache, hi\u1ec7u qu\u1ea3 \u0111\u1ecdc-ghi d\u1eef li\u1ec7u c\u1ee7a CPU c\u00e0ng cao v\u00e0 hi\u1ec7u su\u1ea5t ch\u01b0\u01a1ng tr\u00ecnh c\u00e0ng t\u1ed1t. T\u1ef7 l\u1ec7 truy xu\u1ea5t d\u1eef li\u1ec7u th\u00e0nh c\u00f4ng t\u1eeb b\u1ed9 nh\u1edb cache c\u1ee7a CPU \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 t\u1ef7 l\u1ec7\u547d\u4e2dcache, m\u1ed9t s\u1ed1 li\u1ec7u th\u01b0\u1eddng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111o l\u01b0\u1eddng hi\u1ec7u qu\u1ea3 c\u1ee7a b\u1ed9 nh\u1edb cache.</p> <p>\u0110\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c hi\u1ec7u qu\u1ea3 cao h\u01a1n, b\u1ed9 nh\u1edb cache \u00e1p d\u1ee5ng c\u00e1c c\u01a1 ch\u1ebf t\u1ea3i d\u1eef li\u1ec7u sau.</p> <ul> <li>Cache lines: B\u1ed9 nh\u1edb cache ho\u1ea1t \u0111\u1ed9ng b\u1eb1ng c\u00e1ch l\u01b0u tr\u1eef v\u00e0 t\u1ea3i d\u1eef li\u1ec7u theo c\u00e1c \u0111\u01a1n v\u1ecb g\u1ecdi l\u00e0 cache lines, thay v\u00ec c\u00e1c byte ri\u00eang l\u1ebb. C\u00e1ch ti\u1ebfp c\u1eadn n\u00e0y c\u1ea3i thi\u1ec7n hi\u1ec7u qu\u1ea3 b\u1eb1ng c\u00e1ch truy\u1ec1n c\u00e1c kh\u1ed1i d\u1eef li\u1ec7u l\u1edbn h\u01a1n c\u00f9ng m\u1ed9t l\u00fac.</li> <li>C\u01a1 ch\u1ebf t\u00ecm n\u1ea1p tr\u01b0\u1edbc: B\u1ed9 x\u1eed l\u00fd d\u1ef1 \u0111o\u00e1n c\u00e1c m\u1eabu truy c\u1eadp d\u1eef li\u1ec7u (v\u00ed d\u1ee5: truy c\u1eadp tu\u1ea7n t\u1ef1 ho\u1eb7c b\u01b0\u1edbc c\u1ed1 \u0111\u1ecbnh) v\u00e0 t\u1ea3i tr\u01b0\u1edbc d\u1eef li\u1ec7u v\u00e0o b\u1ed9 nh\u1edb cache d\u1ef1a tr\u00ean c\u00e1c m\u1eabu n\u00e0y \u0111\u1ec3 t\u0103ng t\u1ef7 l\u1ec7\u547d\u4e2dcache.</li> <li>T\u00ednh c\u1ee5c b\u1ed9 kh\u00f4ng gian: Khi m\u1ed9t ph\u1ea7n d\u1eef li\u1ec7u c\u1ee5 th\u1ec3 \u0111\u01b0\u1ee3c truy c\u1eadp, d\u1eef li\u1ec7u l\u00e2n c\u1eadn c\u00f3 kh\u1ea3 n\u0103ng \u0111\u01b0\u1ee3c truy c\u1eadp s\u1edbm. \u0110\u1ec3 t\u1eadn d\u1ee5ng \u0111i\u1ec1u n\u00e0y, b\u1ed9 nh\u1edb cache t\u1ea3i d\u1eef li\u1ec7u li\u1ec1n k\u1ec1 c\u00f9ng v\u1edbi d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c y\u00eau c\u1ea7u, c\u1ea3i thi\u1ec7n t\u1ef7 l\u1ec7\u547d\u4e2d.</li> <li>T\u00ednh c\u1ee5c b\u1ed9 th\u1eddi gian: N\u1ebfu d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c truy c\u1eadp, n\u00f3 c\u00f3 kh\u1ea3 n\u0103ng \u0111\u01b0\u1ee3c truy c\u1eadp l\u1ea1i trong t\u01b0\u01a1ng lai g\u1ea7n. B\u1ed9 nh\u1edb cache s\u1eed d\u1ee5ng nguy\u00ean t\u1eafc n\u00e0y \u0111\u1ec3 gi\u1eef l\u1ea1i d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c truy c\u1eadp g\u1ea7n \u0111\u00e2y \u0111\u1ec3 c\u1ea3i thi\u1ec7n t\u1ef7 l\u1ec7\u547d\u4e2d.</li> </ul> <p>Tr\u00ean th\u1ef1c t\u1ebf, m\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft c\u00f3 hi\u1ec7u qu\u1ea3 s\u1eed d\u1ee5ng b\u1ed9 nh\u1edb cache kh\u00e1c nhau, \u0111i\u1ec1u n\u00e0y ch\u1ee7 y\u1ebfu \u0111\u01b0\u1ee3c ph\u1ea3n \u00e1nh trong c\u00e1c kh\u00eda c\u1ea1nh sau.</p> <ul> <li>Kh\u00f4ng gian chi\u1ebfm d\u1ee5ng: C\u00e1c ph\u1ea7n t\u1eed danh s\u00e1ch li\u00ean k\u1ebft chi\u1ebfm nhi\u1ec1u kh\u00f4ng gian h\u01a1n c\u00e1c ph\u1ea7n t\u1eed m\u1ea3ng, d\u1eabn \u0111\u1ebfn \u00edt d\u1eef li\u1ec7u hi\u1ec7u qu\u1ea3 h\u01a1n \u0111\u01b0\u1ee3c gi\u1eef trong b\u1ed9 nh\u1edb cache.</li> <li>Cache lines: D\u1eef li\u1ec7u danh s\u00e1ch li\u00ean k\u1ebft n\u1eb1m r\u1ea3i r\u00e1c trong b\u1ed9 nh\u1edb v\u00e0 b\u1ed9 nh\u1edb cache \u0111\u01b0\u1ee3c \"t\u1ea3i theo h\u00e0ng\", v\u00ec v\u1eady t\u1ef7 l\u1ec7 d\u1eef li\u1ec7u kh\u00f4ng h\u1ee3p l\u1ec7 \u0111\u01b0\u1ee3c t\u1ea3i cao h\u01a1n.</li> <li>C\u01a1 ch\u1ebf t\u00ecm n\u1ea1p tr\u01b0\u1edbc: M\u1eabu truy c\u1eadp d\u1eef li\u1ec7u c\u1ee7a m\u1ea3ng \"d\u1ec5 \u0111o\u00e1n\" h\u01a1n so v\u1edbi danh s\u00e1ch li\u00ean k\u1ebft, t\u1ee9c l\u00e0 h\u1ec7 th\u1ed1ng d\u1ec5 d\u00e0ng \u0111o\u00e1n d\u1eef li\u1ec7u s\u1eafp \u0111\u01b0\u1ee3c t\u1ea3i h\u01a1n.</li> <li>T\u00ednh c\u1ee5c b\u1ed9 kh\u00f4ng gian: M\u1ea3ng \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong m\u1ed9t kh\u00f4ng gian b\u1ed9 nh\u1edb li\u00ean t\u1ee5c, v\u00ec v\u1eady d\u1eef li\u1ec7u g\u1ea7n d\u1eef li\u1ec7u \u0111ang \u0111\u01b0\u1ee3c t\u1ea3i c\u00f3 nhi\u1ec1u kh\u1ea3 n\u0103ng \u0111\u01b0\u1ee3c truy c\u1eadp s\u1edbm.</li> </ul> <p>Nh\u00ecn chung, m\u1ea3ng c\u00f3 t\u1ef7 l\u1ec7\u547d\u4e2dcache cao h\u01a1n v\u00e0 th\u01b0\u1eddng hi\u1ec7u qu\u1ea3 h\u01a1n trong ho\u1ea1t \u0111\u1ed9ng so v\u1edbi danh s\u00e1ch li\u00ean k\u1ebft. \u0110i\u1ec1u n\u00e0y l\u00e0m cho c\u00e1c c\u1ea5u tr\u00fac d\u1eef li\u1ec7u d\u1ef1a tr\u00ean m\u1ea3ng tr\u1edf n\u00ean ph\u1ed5 bi\u1ebfn h\u01a1n trong vi\u1ec7c gi\u1ea3i quy\u1ebft c\u00e1c b\u00e0i to\u00e1n thu\u1eadt to\u00e1n.</p> <p>C\u1ea7n l\u01b0u \u00fd r\u1eb1ng hi\u1ec7u qu\u1ea3 cache cao kh\u00f4ng c\u00f3 ngh\u0129a l\u00e0 m\u1ea3ng lu\u00f4n t\u1ed1t h\u01a1n danh s\u00e1ch li\u00ean k\u1ebft. Vi\u1ec7c l\u1ef1a ch\u1ecdn c\u1ea5u tr\u00fac d\u1eef li\u1ec7u n\u00ean ph\u1ee5 thu\u1ed9c v\u00e0o c\u00e1c y\u00eau c\u1ea7u \u1ee9ng d\u1ee5ng c\u1ee5 th\u1ec3. V\u00ed d\u1ee5: c\u1ea3 m\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft \u0111\u1ec1u c\u00f3 th\u1ec3 tri\u1ec3n khai c\u1ea5u tr\u00fac d\u1eef li\u1ec7u \"stack\" (s\u1ebd \u0111\u01b0\u1ee3c tr\u00ecnh b\u00e0y chi ti\u1ebft trong ch\u01b0\u01a1ng ti\u1ebfp theo), nh\u01b0ng ch\u00fang ph\u00f9 h\u1ee3p v\u1edbi c\u00e1c t\u00ecnh hu\u1ed1ng kh\u00e1c nhau.</p> <ul> <li>Trong c\u00e1c b\u00e0i to\u00e1n thu\u1eadt to\u00e1n, ch\u00fang ta c\u00f3 xu h\u01b0\u1edbng ch\u1ecdn stack d\u1ef1a tr\u00ean m\u1ea3ng v\u00ec ch\u00fang cung c\u1ea5p hi\u1ec7u qu\u1ea3 ho\u1ea1t \u0111\u1ed9ng v\u00e0 kh\u1ea3 n\u0103ng truy c\u1eadp ng\u1eabu nhi\u00ean cao h\u01a1n, v\u1edbi chi ph\u00ed duy nh\u1ea5t l\u00e0 c\u1ea7n ph\u00e2n b\u1ed5 tr\u01b0\u1edbc m\u1ed9t l\u01b0\u1ee3ng kh\u00f4ng gian b\u1ed9 nh\u1edb nh\u1ea5t \u0111\u1ecbnh cho m\u1ea3ng.</li> <li>N\u1ebfu kh\u1ed1i l\u01b0\u1ee3ng d\u1eef li\u1ec7u r\u1ea5t l\u1edbn, c\u00f3 t\u00ednh \u0111\u1ed9ng cao v\u00e0 k\u00edch th\u01b0\u1edbc d\u1ef1 ki\u1ebfn c\u1ee7a stack kh\u00f3 \u01b0\u1edbc t\u00ednh, th\u00ec stack d\u1ef1a tr\u00ean danh s\u00e1ch li\u00ean k\u1ebft l\u00e0 m\u1ed9t l\u1ef1a ch\u1ecdn t\u1ed1t h\u01a1n. Danh s\u00e1ch li\u00ean k\u1ebft c\u00f3 th\u1ec3 ph\u00e2n ph\u1ed1i m\u1ed9t l\u01b0\u1ee3ng l\u1edbn d\u1eef li\u1ec7u \u1edf c\u00e1c ph\u1ea7n kh\u00e1c nhau c\u1ee7a b\u1ed9 nh\u1edb v\u00e0 tr\u00e1nh \u0111\u01b0\u1ee3c chi ph\u00ed b\u1ed5 sung c\u1ee7a vi\u1ec7c m\u1edf r\u1ed9ng m\u1ea3ng.</li> </ul>"},{"location":"chapter_array_and_linkedlist/summary/","title":"4.5 Summary","text":""},{"location":"chapter_array_and_linkedlist/summary/#tom-tat","title":"T\u00f3m t\u1eaft","text":""},{"location":"chapter_array_and_linkedlist/summary/#on-tap-cac-iem-chinh","title":"\u00d4n t\u1eadp c\u00e1c \u0111i\u1ec3m ch\u00ednh","text":"<ul> <li>M\u1ea3ng (Array) v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft (Linked List) l\u00e0 hai c\u1ea5u tr\u00fac d\u1eef li\u1ec7u c\u01a1 b\u1ea3n, \u0111\u1ea1i di\u1ec7n cho hai ph\u01b0\u01a1ng ph\u00e1p l\u01b0u tr\u1eef trong b\u1ed9 nh\u1edb m\u00e1y t\u00ednh: l\u01b0u tr\u1eef kh\u00f4ng gian li\u1ec1n k\u1ec1 v\u00e0 l\u01b0u tr\u1eef kh\u00f4ng gian kh\u00f4ng li\u1ec1n k\u1ec1. \u0110\u1eb7c \u0111i\u1ec3m c\u1ee7a ch\u00fang b\u1ed5 sung cho nhau.</li> <li>M\u1ea3ng h\u1ed7 tr\u1ee3 truy c\u1eadp ng\u1eabu nhi\u00ean v\u00e0 s\u1eed d\u1ee5ng \u00edt b\u1ed9 nh\u1edb h\u01a1n; tuy nhi\u00ean, ch\u00fang k\u00e9m hi\u1ec7u qu\u1ea3 trong vi\u1ec7c ch\u00e8n v\u00e0 x\u00f3a c\u00e1c ph\u1ea7n t\u1eed v\u00e0 c\u00f3 \u0111\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh sau khi kh\u1edfi t\u1ea1o.</li> <li>Danh s\u00e1ch li\u00ean k\u1ebft th\u1ef1c hi\u1ec7n ch\u00e8n v\u00e0 x\u00f3a n\u00fat hi\u1ec7u qu\u1ea3 th\u00f4ng qua thay \u0111\u1ed5i tham chi\u1ebfu (con tr\u1ecf) v\u00e0 c\u00f3 th\u1ec3 \u0111i\u1ec1u ch\u1ec9nh \u0111\u1ed9 d\u00e0i m\u1ed9t c\u00e1ch linh ho\u1ea1t; tuy nhi\u00ean, ch\u00fang c\u00f3 hi\u1ec7u qu\u1ea3 truy c\u1eadp n\u00fat th\u1ea5p h\u01a1n v\u00e0 ti\u00eau th\u1ee5 nhi\u1ec1u b\u1ed9 nh\u1edb h\u01a1n.</li> <li>C\u00e1c lo\u1ea1i danh s\u00e1ch li\u00ean k\u1ebft ph\u1ed5 bi\u1ebfn bao g\u1ed3m danh s\u00e1ch li\u00ean k\u1ebft \u0111\u01a1n, danh s\u00e1ch li\u00ean k\u1ebft v\u00f2ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft \u0111\u00f4i, m\u1ed7i lo\u1ea1i c\u00f3 c\u00e1c t\u00ecnh hu\u1ed1ng \u1ee9ng d\u1ee5ng ri\u00eang.</li> <li>Danh s\u00e1ch (List) l\u00e0 c\u00e1c t\u1eadp h\u1ee3p c\u00e1c ph\u1ea7n t\u1eed c\u00f3 th\u1ee9 t\u1ef1, h\u1ed7 tr\u1ee3 th\u00eam, x\u00f3a v\u00e0 s\u1eeda \u0111\u1ed5i, th\u01b0\u1eddng \u0111\u01b0\u1ee3c tri\u1ec3n khai d\u1ef1a tr\u00ean m\u1ea3ng \u0111\u1ed9ng, gi\u1eef l\u1ea1i nh\u1eefng \u01b0u \u0111i\u1ec3m c\u1ee7a m\u1ea3ng \u0111\u1ed3ng th\u1eddi cho ph\u00e9p \u0111i\u1ec1u ch\u1ec9nh \u0111\u1ed9 d\u00e0i linh ho\u1ea1t.</li> <li>S\u1ef1 ra \u0111\u1eddi c\u1ee7a danh s\u00e1ch \u0111\u00e3 c\u1ea3i thi\u1ec7n \u0111\u00e1ng k\u1ec3 t\u00ednh th\u1ef1c t\u1ebf c\u1ee7a m\u1ea3ng nh\u01b0ng c\u00f3 th\u1ec3 d\u1eabn \u0111\u1ebfn l\u00e3ng ph\u00ed m\u1ed9t s\u1ed1 kh\u00f4ng gian b\u1ed9 nh\u1edb.</li> <li>Trong qu\u00e1 tr\u00ecnh th\u1ef1c thi ch\u01b0\u01a1ng tr\u00ecnh, d\u1eef li\u1ec7u ch\u1ee7 y\u1ebfu \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong b\u1ed9 nh\u1edb. M\u1ea3ng cung c\u1ea5p hi\u1ec7u qu\u1ea3 kh\u00f4ng gian b\u1ed9 nh\u1edb cao h\u01a1n, trong khi danh s\u00e1ch li\u00ean k\u1ebft linh ho\u1ea1t h\u01a1n trong vi\u1ec7c s\u1eed d\u1ee5ng b\u1ed9 nh\u1edb.</li> <li>B\u1ed9 nh\u1edb cache (Cache) cung c\u1ea5p kh\u1ea3 n\u0103ng truy c\u1eadp d\u1eef li\u1ec7u nhanh ch\u00f3ng cho CPU th\u00f4ng qua c\u00e1c c\u01a1 ch\u1ebf nh\u01b0 d\u00f2ng cache, t\u00ecm n\u1ea1p tr\u01b0\u1edbc, t\u00ednh c\u1ee5c b\u1ed9 kh\u00f4ng gian v\u00e0 t\u00ednh c\u1ee5c b\u1ed9 th\u1eddi gian, gi\u00fap t\u0103ng c\u01b0\u1eddng \u0111\u00e1ng k\u1ec3 hi\u1ec7u qu\u1ea3 th\u1ef1c thi ch\u01b0\u01a1ng tr\u00ecnh.</li> <li>Do t\u1ef7 l\u1ec7\u547d\u4e2dcache cao h\u01a1n, m\u1ea3ng th\u01b0\u1eddng hi\u1ec7u qu\u1ea3 h\u01a1n danh s\u00e1ch li\u00ean k\u1ebft. Khi ch\u1ecdn c\u1ea5u tr\u00fac d\u1eef li\u1ec7u, n\u00ean \u0111\u01b0a ra l\u1ef1a ch\u1ecdn ph\u00f9 h\u1ee3p d\u1ef1a tr\u00ean nhu c\u1ea7u v\u00e0 t\u00ecnh hu\u1ed1ng c\u1ee5 th\u1ec3.</li> </ul>"},{"location":"chapter_array_and_linkedlist/summary/#hoi-ap","title":"H\u1ecfi &amp; \u0110\u00e1p","text":"<p>H: Vi\u1ec7c l\u01b0u tr\u1eef m\u1ea3ng tr\u00ean stack so v\u1edbi heap c\u00f3 \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn hi\u1ec7u qu\u1ea3 th\u1eddi gian v\u00e0 kh\u00f4ng gian kh\u00f4ng?</p> <p>M\u1ea3ng \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef tr\u00ean c\u1ea3 stack v\u00e0 heap \u0111\u1ec1u \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong kh\u00f4ng gian b\u1ed9 nh\u1edb li\u1ec1n k\u1ec1 v\u00e0 hi\u1ec7u qu\u1ea3 ho\u1ea1t \u0111\u1ed9ng d\u1eef li\u1ec7u v\u1ec1 c\u01a1 b\u1ea3n l\u00e0 gi\u1ed1ng nhau. Tuy nhi\u00ean, stack v\u00e0 heap c\u00f3 nh\u1eefng \u0111\u1eb7c \u0111i\u1ec3m ri\u00eang, d\u1eabn \u0111\u1ebfn nh\u1eefng kh\u00e1c bi\u1ec7t sau.</p> <ol> <li>Hi\u1ec7u qu\u1ea3 c\u1ea5p ph\u00e1t v\u00e0 gi\u1ea3i ph\u00f3ng: Stack l\u00e0 m\u1ed9t kh\u1ed1i b\u1ed9 nh\u1edb nh\u1ecf h\u01a1n, \u0111\u01b0\u1ee3c tr\u00ecnh bi\u00ean d\u1ecbch t\u1ef1 \u0111\u1ed9ng c\u1ea5p ph\u00e1t; b\u1ed9 nh\u1edb heap t\u01b0\u01a1ng \u0111\u1ed1i l\u1edbn h\u01a1n v\u00e0 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c c\u1ea5p ph\u00e1t \u0111\u1ed9ng trong code, d\u1ec5 b\u1ecb ph\u00e2n m\u1ea3nh h\u01a1n. Do \u0111\u00f3, c\u00e1c ho\u1ea1t \u0111\u1ed9ng c\u1ea5p ph\u00e1t v\u00e0 gi\u1ea3i ph\u00f3ng tr\u00ean heap th\u01b0\u1eddng ch\u1eadm h\u01a1n so v\u1edbi tr\u00ean stack.</li> <li>Gi\u1edbi h\u1ea1n k\u00edch th\u01b0\u1edbc: B\u1ed9 nh\u1edb stack t\u01b0\u01a1ng \u0111\u1ed1i nh\u1ecf, trong khi k\u00edch th\u01b0\u1edbc heap th\u01b0\u1eddng b\u1ecb gi\u1edbi h\u1ea1n b\u1edfi b\u1ed9 nh\u1edb kh\u1ea3 d\u1ee5ng. Do \u0111\u00f3, heap ph\u00f9 h\u1ee3p h\u01a1n \u0111\u1ec3 l\u01b0u tr\u1eef c\u00e1c m\u1ea3ng l\u1edbn.</li> <li>T\u00ednh linh ho\u1ea1t: K\u00edch th\u01b0\u1edbc c\u1ee7a m\u1ea3ng tr\u00ean stack c\u1ea7n \u0111\u01b0\u1ee3c x\u00e1c \u0111\u1ecbnh t\u1ea1i th\u1eddi \u0111i\u1ec3m bi\u00ean d\u1ecbch, trong khi k\u00edch th\u01b0\u1edbc c\u1ee7a m\u1ea3ng tr\u00ean heap c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c x\u00e1c \u0111\u1ecbnh \u0111\u1ed9ng t\u1ea1i th\u1eddi \u0111i\u1ec3m ch\u1ea1y.</li> </ol> <p>H: T\u1ea1i sao m\u1ea3ng y\u00eau c\u1ea7u c\u00e1c ph\u1ea7n t\u1eed c\u00f9ng lo\u1ea1i, trong khi danh s\u00e1ch li\u00ean k\u1ebft kh\u00f4ng nh\u1ea5n m\u1ea1nh c\u00e1c ph\u1ea7n t\u1eed c\u00f9ng lo\u1ea1i?</p> <p>Danh s\u00e1ch li\u00ean k\u1ebft bao g\u1ed3m c\u00e1c n\u00fat \u0111\u01b0\u1ee3c k\u1ebft n\u1ed1i b\u1eb1ng c\u00e1c tham chi\u1ebfu (con tr\u1ecf) v\u00e0 m\u1ed7i n\u00fat c\u00f3 th\u1ec3 l\u01b0u tr\u1eef d\u1eef li\u1ec7u thu\u1ed9c c\u00e1c lo\u1ea1i kh\u00e1c nhau, ch\u1eb3ng h\u1ea1n nh\u01b0 int, double, string, object, v.v.</p> <p>Ng\u01b0\u1ee3c l\u1ea1i, c\u00e1c ph\u1ea7n t\u1eed m\u1ea3ng ph\u1ea3i c\u00f9ng lo\u1ea1i, cho ph\u00e9p t\u00ednh to\u00e1n offset \u0111\u1ec3 truy c\u1eadp c\u00e1c v\u1ecb tr\u00ed ph\u1ea7n t\u1eed t\u01b0\u01a1ng \u1ee9ng. V\u00ed d\u1ee5: m\u1ed9t m\u1ea3ng ch\u1ee9a c\u1ea3 ki\u1ec3u int v\u00e0 long, v\u1edbi c\u00e1c ph\u1ea7n t\u1eed \u0111\u01a1n chi\u1ebfm l\u1ea7n l\u01b0\u1ee3t 4 byte v\u00e0 8 byte, kh\u00f4ng th\u1ec3 s\u1eed d\u1ee5ng c\u00f4ng th\u1ee9c sau \u0111\u1ec3 t\u00ednh to\u00e1n offset, v\u00ec m\u1ea3ng ch\u1ee9a c\u00e1c ph\u1ea7n t\u1eed c\u00f3 hai \u0111\u1ed9 d\u00e0i kh\u00e1c nhau.</p> <pre><code># \u0110\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb ph\u1ea7n t\u1eed = \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb m\u1ea3ng + \u0111\u1ed9 d\u00e0i ph\u1ea7n t\u1eed * ch\u1ec9 s\u1ed1 ph\u1ea7n t\u1eed\n</code></pre> <p>H: Sau khi x\u00f3a m\u1ed9t n\u00fat, c\u00f3 c\u1ea7n thi\u1ebft ph\u1ea3i \u0111\u1eb7t <code>P.next</code> th\u00e0nh <code>None</code> kh\u00f4ng?</p> <p>Kh\u00f4ng s\u1eeda \u0111\u1ed5i <code>P.next</code> c\u0169ng c\u00f3 th\u1ec3 ch\u1ea5p nh\u1eadn \u0111\u01b0\u1ee3c. T\u1eeb g\u00f3c \u0111\u1ed9 c\u1ee7a danh s\u00e1ch li\u00ean k\u1ebft, vi\u1ec7c duy\u1ec7t t\u1eeb n\u00fat \u0111\u1ea7u \u0111\u1ebfn n\u00fat cu\u1ed1i s\u1ebd kh\u00f4ng c\u00f2n g\u1eb7p <code>P</code>. \u0110i\u1ec1u n\u00e0y c\u00f3 ngh\u0129a l\u00e0 n\u00fat <code>P</code> \u0111\u00e3 \u0111\u01b0\u1ee3c lo\u1ea1i b\u1ecf kh\u1ecfi danh s\u00e1ch m\u1ed9t c\u00e1ch hi\u1ec7u qu\u1ea3 v\u00e0 n\u01a1i <code>P</code> tr\u1ecf \u0111\u1ebfn kh\u00f4ng c\u00f2n \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn danh s\u00e1ch n\u1eefa.</p> <p>T\u1eeb g\u00f3c \u0111\u1ed9 thu gom r\u00e1c, \u0111\u1ed1i v\u1edbi c\u00e1c ng\u00f4n ng\u1eef c\u00f3 c\u01a1 ch\u1ebf thu gom r\u00e1c t\u1ef1 \u0111\u1ed9ng nh\u01b0 Java, Python v\u00e0 Go, vi\u1ec7c n\u00fat <code>P</code> c\u00f3 \u0111\u01b0\u1ee3c thu gom hay kh\u00f4ng ph\u1ee5 thu\u1ed9c v\u00e0o vi\u1ec7c c\u00f3 c\u00f2n tham chi\u1ebfu n\u00e0o tr\u1ecf \u0111\u1ebfn n\u00f3 hay kh\u00f4ng, ch\u1ee9 kh\u00f4ng ph\u1ea3i v\u00e0o gi\u00e1 tr\u1ecb c\u1ee7a <code>P.next</code>. Trong c\u00e1c ng\u00f4n ng\u1eef nh\u01b0 C v\u00e0 C++, ch\u00fang ta c\u1ea7n gi\u1ea3i ph\u00f3ng b\u1ed9 nh\u1edb c\u1ee7a n\u00fat theo c\u00e1ch th\u1ee7 c\u00f4ng.</p> <p>H: Trong danh s\u00e1ch li\u00ean k\u1ebft, \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian cho c\u00e1c thao t\u00e1c ch\u00e8n v\u00e0 x\u00f3a l\u00e0 <code>O(1)</code>. Nh\u01b0ng vi\u1ec7c t\u00ecm ki\u1ebfm ph\u1ea7n t\u1eed tr\u01b0\u1edbc khi ch\u00e8n ho\u1eb7c x\u00f3a m\u1ea5t th\u1eddi gian <code>O(n)</code>, v\u1eady t\u1ea1i sao \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian kh\u00f4ng ph\u1ea3i l\u00e0 <code>O(n)</code>?</p> <p>N\u1ebfu m\u1ed9t ph\u1ea7n t\u1eed \u0111\u01b0\u1ee3c t\u00ecm ki\u1ebfm tr\u01b0\u1edbc v\u00e0 sau \u0111\u00f3 b\u1ecb x\u00f3a, th\u00ec \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian th\u1ef1c s\u1ef1 l\u00e0 <code>O(n)</code>. Tuy nhi\u00ean, l\u1ee3i th\u1ebf <code>O(1)</code> c\u1ee7a danh s\u00e1ch li\u00ean k\u1ebft trong vi\u1ec7c ch\u00e8n v\u00e0 x\u00f3a c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c nh\u1eadn ra trong c\u00e1c \u1ee9ng d\u1ee5ng kh\u00e1c. V\u00ed d\u1ee5: trong vi\u1ec7c tri\u1ec3n khai h\u00e0ng \u0111\u1ee3i hai \u0111\u1ea7u b\u1eb1ng danh s\u00e1ch li\u00ean k\u1ebft, ch\u00fang ta duy tr\u00ec c\u00e1c con tr\u1ecf lu\u00f4n tr\u1ecf \u0111\u1ebfn c\u00e1c n\u00fat \u0111\u1ea7u v\u00e0 cu\u1ed1i, l\u00e0m cho m\u1ed7i thao t\u00e1c ch\u00e8n v\u00e0 x\u00f3a l\u00e0 <code>O(1)</code>.</p> <p>H: Trong h\u00ecnh \"\u0110\u1ecbnh ngh\u0129a danh s\u00e1ch li\u00ean k\u1ebft v\u00e0 ph\u01b0\u01a1ng ph\u00e1p l\u01b0u tr\u1eef\", c\u00e1c n\u00fat l\u01b0u tr\u1eef m\u00e0u xanh lam nh\u1ea1t c\u00f3 chi\u1ebfm m\u1ed9t \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb duy nh\u1ea5t hay ch\u00fang chia s\u1ebb m\u1ed9t n\u1eeda v\u1edbi gi\u00e1 tr\u1ecb n\u00fat?</p> <p>H\u00ecnh \u1ea3nh ch\u1ec9 l\u00e0 m\u1ed9t bi\u1ec3u di\u1ec5n \u0111\u1ecbnh t\u00ednh; ph\u00e2n t\u00edch \u0111\u1ecbnh l\u01b0\u1ee3ng ph\u1ee5 thu\u1ed9c v\u00e0o c\u00e1c t\u00ecnh hu\u1ed1ng c\u1ee5 th\u1ec3.</p> <ul> <li>C\u00e1c lo\u1ea1i gi\u00e1 tr\u1ecb n\u00fat kh\u00e1c nhau chi\u1ebfm dung l\u01b0\u1ee3ng kh\u00e1c nhau, ch\u1eb3ng h\u1ea1n nh\u01b0 int, long, double v\u00e0 c\u00e1c th\u1ec3 hi\u1ec7n \u0111\u1ed1i t\u01b0\u1ee3ng.</li> <li>Dung l\u01b0\u1ee3ng b\u1ed9 nh\u1edb m\u00e0 c\u00e1c bi\u1ebfn con tr\u1ecf chi\u1ebfm ph\u1ee5 thu\u1ed9c v\u00e0o h\u1ec7 \u0111i\u1ec1u h\u00e0nh v\u00e0 m\u00f4i tr\u01b0\u1eddng bi\u00ean d\u1ecbch \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng, th\u01b0\u1eddng l\u00e0 8 byte ho\u1eb7c 4 byte.</li> </ul> <p>H: Vi\u1ec7c th\u00eam c\u00e1c ph\u1ea7n t\u1eed v\u00e0o cu\u1ed1i danh s\u00e1ch c\u00f3 lu\u00f4n l\u00e0 <code>O(1)</code> kh\u00f4ng?</p> <p>N\u1ebfu vi\u1ec7c th\u00eam m\u1ed9t ph\u1ea7n t\u1eed v\u01b0\u1ee3t qu\u00e1 \u0111\u1ed9 d\u00e0i danh s\u00e1ch, danh s\u00e1ch c\u1ea7n \u0111\u01b0\u1ee3c m\u1edf r\u1ed9ng tr\u01b0\u1edbc. H\u1ec7 th\u1ed1ng s\u1ebd y\u00eau c\u1ea7u m\u1ed9t kh\u1ed1i b\u1ed9 nh\u1edb m\u1edbi v\u00e0 di chuy\u1ec3n t\u1ea5t c\u1ea3 c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a danh s\u00e1ch ban \u0111\u1ea7u sang, trong tr\u01b0\u1eddng h\u1ee3p \u0111\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian tr\u1edf th\u00e0nh <code>O(n)</code>.</p> <p>H: C\u00e2u n\u00f3i \"S\u1ef1 ra \u0111\u1eddi c\u1ee7a danh s\u00e1ch c\u1ea3i thi\u1ec7n \u0111\u00e1ng k\u1ec3 t\u00ednh th\u1ef1c t\u1ebf c\u1ee7a m\u1ea3ng, nh\u01b0ng c\u00f3 th\u1ec3 d\u1eabn \u0111\u1ebfn l\u00e3ng ph\u00ed m\u1ed9t s\u1ed1 kh\u00f4ng gian b\u1ed9 nh\u1edb\" - \u0111i\u1ec1u n\u00e0y c\u00f3 \u0111\u1ec1 c\u1eadp \u0111\u1ebfn b\u1ed9 nh\u1edb b\u1ecb chi\u1ebfm b\u1edfi c\u00e1c bi\u1ebfn b\u1ed5 sung nh\u01b0 capacity, length v\u00e0 h\u1ec7 s\u1ed1 m\u1edf r\u1ed9ng kh\u00f4ng?</p> <p>S\u1ef1 l\u00e3ng ph\u00ed kh\u00f4ng gian \u1edf \u0111\u00e2y ch\u1ee7 y\u1ebfu \u0111\u1ec1 c\u1eadp \u0111\u1ebfn hai kh\u00eda c\u1ea1nh: m\u1ed9t m\u1eb7t, danh s\u00e1ch \u0111\u01b0\u1ee3c \u0111\u1eb7t v\u1edbi \u0111\u1ed9 d\u00e0i ban \u0111\u1ea7u, m\u00e0 ch\u00fang ta c\u00f3 th\u1ec3 kh\u00f4ng ph\u1ea3i l\u00fac n\u00e0o c\u0169ng c\u1ea7n; m\u1eb7t kh\u00e1c, \u0111\u1ec3 ng\u0103n ch\u1eb7n vi\u1ec7c m\u1edf r\u1ed9ng th\u01b0\u1eddng xuy\u00ean, vi\u1ec7c m\u1edf r\u1ed9ng th\u01b0\u1eddng nh\u00e2n v\u1edbi m\u1ed9t h\u1ec7 s\u1ed1, ch\u1eb3ng h\u1ea1n nh\u01b0 \\(\\times 1.5\\). \u0110i\u1ec1u n\u00e0y d\u1eabn \u0111\u1ebfn nhi\u1ec1u v\u1ecb tr\u00ed tr\u1ed1ng m\u00e0 ch\u00fang ta th\u01b0\u1eddng kh\u00f4ng th\u1ec3 l\u1ea5p \u0111\u1ea7y ho\u00e0n to\u00e0n.</p> <p>H: Trong Python, sau khi kh\u1edfi t\u1ea1o <code>n = [1, 2, 3]</code>, \u0111\u1ecba ch\u1ec9 c\u1ee7a 3 ph\u1ea7n t\u1eed n\u00e0y l\u00e0 li\u1ec1n k\u1ec1, nh\u01b0ng vi\u1ec7c kh\u1edfi t\u1ea1o <code>m = [2, 1, 3]</code> cho th\u1ea5y r\u1eb1ng <code>id</code> c\u1ee7a m\u1ed7i ph\u1ea7n t\u1eed kh\u00f4ng li\u00ean ti\u1ebfp m\u00e0 gi\u1ed1ng v\u1edbi c\u00e1c ph\u1ea7n t\u1eed trong <code>n</code>. N\u1ebfu \u0111\u1ecba ch\u1ec9 c\u1ee7a c\u00e1c ph\u1ea7n t\u1eed n\u00e0y kh\u00f4ng li\u1ec1n k\u1ec1, th\u00ec <code>m</code> c\u00f3 c\u00f2n l\u00e0 m\u1ed9t m\u1ea3ng kh\u00f4ng?</p> <p>N\u1ebfu ch\u00fang ta thay th\u1ebf c\u00e1c ph\u1ea7n t\u1eed danh s\u00e1ch b\u1eb1ng c\u00e1c n\u00fat danh s\u00e1ch li\u00ean k\u1ebft <code>n = [n1, n2, n3, n4, n5]</code>, th\u00ec 5 \u0111\u1ed1i t\u01b0\u1ee3ng n\u00fat n\u00e0y c\u0169ng th\u01b0\u1eddng \u0111\u01b0\u1ee3c ph\u00e2n t\u00e1n kh\u1eafp b\u1ed9 nh\u1edb. Tuy nhi\u00ean, v\u1edbi m\u1ed9t ch\u1ec9 s\u1ed1 danh s\u00e1ch, ch\u00fang ta v\u1eabn c\u00f3 th\u1ec3 truy c\u1eadp \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb c\u1ee7a n\u00fat trong th\u1eddi gian <code>O(1)</code>, do \u0111\u00f3 truy c\u1eadp n\u00fat t\u01b0\u01a1ng \u1ee9ng. \u0110i\u1ec1u n\u00e0y l\u00e0 do m\u1ea3ng l\u01b0u tr\u1eef c\u00e1c tham chi\u1ebfu \u0111\u1ebfn c\u00e1c n\u00fat, ch\u1ee9 kh\u00f4ng ph\u1ea3i ch\u00ednh c\u00e1c n\u00fat.</p> <p>Kh\u00f4ng gi\u1ed1ng nh\u01b0 nhi\u1ec1u ng\u00f4n ng\u1eef, trong Python, c\u00e1c s\u1ed1 c\u0169ng \u0111\u01b0\u1ee3c bao b\u1ecdc d\u01b0\u1edbi d\u1ea1ng \u0111\u1ed1i t\u01b0\u1ee3ng v\u00e0 danh s\u00e1ch l\u01b0u tr\u1eef c\u00e1c tham chi\u1ebfu \u0111\u1ebfn c\u00e1c s\u1ed1 n\u00e0y, ch\u1ee9 kh\u00f4ng ph\u1ea3i ch\u00ednh c\u00e1c s\u1ed1 \u0111\u00f3. Do \u0111\u00f3, ch\u00fang ta th\u1ea5y r\u1eb1ng c\u00f9ng m\u1ed9t s\u1ed1 trong hai m\u1ea3ng c\u00f3 c\u00f9ng <code>id</code> v\u00e0 \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb c\u1ee7a c\u00e1c s\u1ed1 n\u00e0y kh\u00f4ng c\u1ea7n ph\u1ea3i li\u1ec1n k\u1ec1.</p> <p>H: <code>std::list</code> trong C++ STL \u0111\u00e3 tri\u1ec3n khai danh s\u00e1ch li\u00ean k\u1ebft \u0111\u00f4i, nh\u01b0ng c\u00f3 v\u1ebb nh\u01b0 m\u1ed9t s\u1ed1 s\u00e1ch thu\u1eadt to\u00e1n kh\u00f4ng s\u1eed d\u1ee5ng tr\u1ef1c ti\u1ebfp n\u00f3. C\u00f3 b\u1ea5t k\u1ef3 h\u1ea1n ch\u1ebf n\u00e0o kh\u00f4ng?</p> <p>M\u1ed9t m\u1eb7t, ch\u00fang ta th\u01b0\u1eddng th\u00edch s\u1eed d\u1ee5ng m\u1ea3ng \u0111\u1ec3 tri\u1ec3n khai c\u00e1c thu\u1eadt to\u00e1n, ch\u1ec9 s\u1eed d\u1ee5ng danh s\u00e1ch li\u00ean k\u1ebft khi c\u1ea7n thi\u1ebft, ch\u1ee7 y\u1ebfu v\u00ec hai l\u00fd do.</p> <ul> <li>Chi ph\u00ed kh\u00f4ng gian: V\u00ec m\u1ed7i ph\u1ea7n t\u1eed y\u00eau c\u1ea7u hai con tr\u1ecf b\u1ed5 sung (m\u1ed9t cho ph\u1ea7n t\u1eed tr\u01b0\u1edbc v\u00e0 m\u1ed9t cho ph\u1ea7n t\u1eed ti\u1ebfp theo), <code>std::list</code> th\u01b0\u1eddng chi\u1ebfm nhi\u1ec1u kh\u00f4ng gian h\u01a1n <code>std::vector</code>.</li> <li>Kh\u00f4ng th\u00e2n thi\u1ec7n v\u1edbi b\u1ed9 nh\u1edb cache: V\u00ec d\u1eef li\u1ec7u kh\u00f4ng \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef li\u00ean t\u1ee5c, <code>std::list</code> c\u00f3 t\u1ef7 l\u1ec7 s\u1eed d\u1ee5ng b\u1ed9 nh\u1edb cache th\u1ea5p h\u01a1n. N\u00f3i chung, <code>std::vector</code> ho\u1ea1t \u0111\u1ed9ng t\u1ed1t h\u01a1n.</li> </ul> <p>M\u1eb7t kh\u00e1c, danh s\u00e1ch li\u00ean k\u1ebft ch\u1ee7 y\u1ebfu c\u1ea7n thi\u1ebft cho c\u00e2y nh\u1ecb ph\u00e2n v\u00e0 \u0111\u1ed3 th\u1ecb. Stack v\u00e0 queue th\u01b0\u1eddng \u0111\u01b0\u1ee3c tri\u1ec3n khai b\u1eb1ng c\u00e1c l\u1edbp <code>stack</code> v\u00e0 <code>queue</code> c\u1ee7a ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh, thay v\u00ec danh s\u00e1ch li\u00ean k\u1ebft.</p> <p>H: Vi\u1ec7c kh\u1edfi t\u1ea1o m\u1ed9t danh s\u00e1ch <code>res = [0] * self.size()</code> c\u00f3 d\u1eabn \u0111\u1ebfn vi\u1ec7c m\u1ed7i ph\u1ea7n t\u1eed c\u1ee7a <code>res</code> tham chi\u1ebfu \u0111\u1ebfn c\u00f9ng m\u1ed9t \u0111\u1ecba ch\u1ec9 kh\u00f4ng?</p> <p>Kh\u00f4ng. Tuy nhi\u00ean, v\u1ea5n \u0111\u1ec1 n\u00e0y ph\u00e1t sinh v\u1edbi m\u1ea3ng hai chi\u1ec1u, v\u00ed d\u1ee5: vi\u1ec7c kh\u1edfi t\u1ea1o m\u1ed9t danh s\u00e1ch hai chi\u1ec1u <code>res = [[0]] * self.size()</code> s\u1ebd tham chi\u1ebfu \u0111\u1ebfn c\u00f9ng m\u1ed9t danh s\u00e1ch <code>[0]</code> nhi\u1ec1u l\u1ea7n.</p> <p>H: Khi x\u00f3a m\u1ed9t n\u00fat, c\u00f3 c\u1ea7n thi\u1ebft ph\u1ea3i ph\u00e1 v\u1ee1 tham chi\u1ebfu \u0111\u1ebfn n\u00fat k\u1ebf nhi\u1ec7m c\u1ee7a n\u00f3 kh\u00f4ng?</p> <p>T\u1eeb g\u00f3c \u0111\u1ed9 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n (gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1), vi\u1ec7c kh\u00f4ng ph\u00e1 v\u1ee1 li\u00ean k\u1ebft l\u00e0 \u1ed5n, mi\u1ec5n l\u00e0 logic c\u1ee7a ch\u01b0\u01a1ng tr\u00ecnh l\u00e0 ch\u00ednh x\u00e1c. T\u1eeb g\u00f3c \u0111\u1ed9 c\u1ee7a c\u00e1c th\u01b0 vi\u1ec7n ti\u00eau chu\u1ea9n, vi\u1ec7c ph\u00e1 v\u1ee1 li\u00ean k\u1ebft an to\u00e0n h\u01a1n v\u00e0 r\u00f5 r\u00e0ng h\u01a1n v\u1ec1 m\u1eb7t logic. N\u1ebfu li\u00ean k\u1ebft kh\u00f4ng b\u1ecb ph\u00e1 v\u1ee1 v\u00e0 n\u00fat b\u1ecb x\u00f3a kh\u00f4ng \u0111\u01b0\u1ee3c t\u00e1i ch\u1ebf \u0111\u00fang c\u00e1ch, n\u00f3 c\u00f3 th\u1ec3 \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn vi\u1ec7c t\u00e1i ch\u1ebf b\u1ed9 nh\u1edb c\u1ee7a n\u00fat k\u1ebf nhi\u1ec7m.</p>"},{"location":"chapter_backtracking/","title":"Backtracking","text":""},{"location":"chapter_backtracking/#backtracking","title":"Backtracking","text":"<p>Abstract</p> <p>Like explorers in a maze, we may encounter obstacles on our path forward.</p> <p>The power of backtracking lets us begin anew, keep trying, and eventually find the exit leading to the light.</p>"},{"location":"chapter_backtracking/backtracking_algorithm/","title":"13.1 Backtracking algorithms","text":""},{"location":"chapter_backtracking/backtracking_algorithm/#backtracking-algorithms","title":"Backtracking algorithms","text":"<p>Backtracking algorithm is a method to solve problems by exhaustive search. Its core concept is to start from an initial state and brutally search for all possible solutions. The algorithm records the correct ones until a solution is found or all possible solutions have been tried but no solution can be found.</p> <p>Backtracking typically employs \"depth-first search\" to traverse the solution space. In the \"Binary tree\" chapter, we mentioned that pre-order, in-order, and post-order traversals are all depth-first searches. Next, we are going to use pre-order traversal to solve a backtracking problem. This helps us to understand how the algorithm works gradually.</p> <p>Example One</p> <p>Given a binary tree, search and record all nodes with a value of \\(7\\) and return them in a list.</p> <p>To solve this problem, we traverse this tree in pre-order and check if the current node's value is \\(7\\). If it is, we add the node's value to the result list <code>res</code>. The process is shown in the figure below:</p> <pre><code>[file]{preorder_traversal_i_compact}-[class]{}-[func]{pre_order}\n</code></pre> <p></p>"},{"location":"chapter_backtracking/backtracking_algorithm/#trial-and-retreat","title":"Trial and retreat","text":"<p>It is called a backtracking algorithm because it uses a \"trial\" and \"retreat\" strategy when searching the solution space. During the search, whenever it encounters a state where it can no longer proceed to obtain a satisfying solution, it undoes the previous choice and reverts to the previous state so that other possible choices can be chosen for the next attempt.</p> <p>In Example One, visiting each node starts a \"trial\". And passing a leaf node or the <code>return</code> statement to going back to the parent node suggests \"retreat\".</p> <p>It's worth noting that retreat is not merely about function returns. We'll expand slightly on Example One question to explain what it means.</p> <p>Example Two</p> <p>In a binary tree, search for all nodes with a value of \\(7\\) and for all matching nodes, please return the paths from the root node to that node.</p> <p>Based on the code from Example One, we need to use a list called <code>path</code> to record the visited node paths. When a node with a value of \\(7\\) is reached, we copy <code>path</code> and add it to the result list <code>res</code>. After the traversal, <code>res</code> holds all the solutions. The code is as shown:</p> <pre><code>[file]{preorder_traversal_ii_compact}-[class]{}-[func]{pre_order}\n</code></pre> <p>In each \"trial\", we record the path by adding the current node to <code>path</code>. Whenever we need to \"retreat\", we pop the node from <code>path</code> to restore the state prior to this failed attempt.</p> <p>By observing the process shown in the figure below, the trial is like \"advancing\", and retreat is like \"undoing\". The later pairs can be seen as a reverse operation to their counterpart.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"chapter_backtracking/backtracking_algorithm/#prune","title":"Prune","text":"<p>Complex backtracking problems usually involve one or more constraints, which are often used for \"pruning\".</p> <p>Example Three</p> <p>In a binary tree, search for all nodes with a value of \\(7\\) and return the paths from the root to these nodes, with restriction that the paths do not contain nodes with a value of \\(3\\).</p> <p>To meet the above constraints, we need to add a pruning operation: during the search process, if a node with a value of \\(3\\) is encountered, it aborts further searching down through the path immediately. The code is as shown:</p> <pre><code>[file]{preorder_traversal_iii_compact}-[class]{}-[func]{pre_order}\n</code></pre> <p>\"Pruning\" is a very vivid noun. As shown in the figure below, in the search process, we \"cut off\" the search branches that do not meet the constraints. It avoids further unnecessary attempts, thus enhances the search efficiency.</p> <p></p>"},{"location":"chapter_backtracking/backtracking_algorithm/#framework-code","title":"Framework code","text":"<p>Now, let's try to distill the main framework of \"trial, retreat, and prune\" from backtracking to enhance the code's universality.</p> <p>In the following framework code, <code>state</code> represents the current state of the problem, <code>choices</code> represents the choices available under the current state:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig <pre><code>def backtrack(state: State, choices: list[choice], res: list[state]):\n    \"\"\"Backtracking algorithm framework\"\"\"\n    # Check if it's a solution\n    if is_solution(state):\n        # Record the solution\n        record_solution(state, res)\n        # Stop searching\n        return\n    # Iterate through all choices\n    for choice in choices:\n        # Prune: check if the choice is valid\n        if is_valid(state, choice):\n            # Trial: make a choice, update the state\n            make_choice(state, choice)\n            backtrack(state, choices, res)\n            # Retreat: undo the choice, revert to the previous state\n            undo_choice(state, choice)\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State *state, vector&lt;Choice *&gt; &amp;choices, vector&lt;State *&gt; &amp;res) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (Choice choice : choices) {\n        // Prune: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Trial: make a choice, update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (Choice choice : choices) {\n        // Prune: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Trial: make a choice, update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid Backtrack(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res) {\n    // Check if it's a solution\n    if (IsSolution(state)) {\n        // Record the solution\n        RecordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    foreach (Choice choice in choices) {\n        // Prune: check if the choice is valid\n        if (IsValid(state, choice)) {\n            // Trial: make a choice, update the state\n            MakeChoice(state, choice);\n            Backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            UndoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunc backtrack(state *State, choices []Choice, res *[]State) {\n    // Check if it's a solution\n    if isSolution(state) {\n        // Record the solution\n        recordSolution(state, res)\n        // Stop searching\n        return\n    }\n    // Iterate through all choices\n    for _, choice := range choices {\n        // Prune: check if the choice is valid\n        if isValid(state, choice) {\n            // Trial: make a choice, update the state\n            makeChoice(state, choice)\n            backtrack(state, choices, res)\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunc backtrack(state: inout State, choices: [Choice], res: inout [State]) {\n    // Check if it's a solution\n    if isSolution(state: state) {\n        // Record the solution\n        recordSolution(state: state, res: &amp;res)\n        // Stop searching\n        return\n    }\n    // Iterate through all choices\n    for choice in choices {\n        // Prune: check if the choice is valid\n        if isValid(state: state, choice: choice) {\n            // Trial: make a choice, update the state\n            makeChoice(state: &amp;state, choice: choice)\n            backtrack(state: &amp;state, choices: choices, res: &amp;res)\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state: &amp;state, choice: choice)\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunction backtrack(state, choices, res) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (let choice of choices) {\n        // Prune: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Trial: make a choice, update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfunction backtrack(state: State, choices: Choice[], res: State[]): void {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (let choice of choices) {\n        // Prune: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Trial: make a choice, update the state\n            makeChoice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State state, List&lt;Choice&gt;, List&lt;State&gt; res) {\n  // Check if it's a solution\n  if (isSolution(state)) {\n    // Record the solution\n    recordSolution(state, res);\n    // Stop searching\n    return;\n  }\n  // Iterate through all choices\n  for (Choice choice in choices) {\n    // Prune: check if the choice is valid\n    if (isValid(state, choice)) {\n      // Trial: make a choice, update the state\n      makeChoice(state, choice);\n      backtrack(state, choices, res);\n      // Retreat: undo the choice, revert to the previous state\n      undoChoice(state, choice);\n    }\n  }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfn backtrack(state: &amp;mut State, choices: &amp;Vec&lt;Choice&gt;, res: &amp;mut Vec&lt;State&gt;) {\n    // Check if it's a solution\n    if is_solution(state) {\n        // Record the solution\n        record_solution(state, res);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for choice in choices {\n        // Prune: check if the choice is valid\n        if is_valid(state, choice) {\n            // Trial: make a choice, update the state\n            make_choice(state, choice);\n            backtrack(state, choices, res);\n            // Retreat: undo the choice, revert to the previous state\n            undo_choice(state, choice);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nvoid backtrack(State *state, Choice *choices, int numChoices, State *res, int numRes) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res, numRes);\n        // Stop searching\n        return;\n    }\n    // Iterate through all choices\n    for (int i = 0; i &lt; numChoices; i++) {\n        // Prune: check if the choice is valid\n        if (isValid(state, &amp;choices[i])) {\n            // Trial: make a choice, update the state\n            makeChoice(state, &amp;choices[i]);\n            backtrack(state, choices, numChoices, res, numRes);\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, &amp;choices[i]);\n        }\n    }\n}\n</code></pre> <pre><code>/* Backtracking algorithm framework */\nfun backtrack(state: State?, choices: List&lt;Choice?&gt;, res: List&lt;State?&gt;?) {\n    // Check if it's a solution\n    if (isSolution(state)) {\n        // Record the solution\n        recordSolution(state, res)\n        // Stop searching\n        return\n    }\n    // Iterate through all choices\n    for (choice in choices) {\n        // Prune: check if the choice is valid\n        if (isValid(state, choice)) {\n            // Trial: make a choice, update the state\n            makeChoice(state, choice)\n            backtrack(state, choices, res)\n            // Retreat: undo the choice, revert to the previous state\n            undoChoice(state, choice)\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>Now, we are able to solve Example Three using the framework code. The <code>state</code> is the node traversal path, <code>choices</code> are the current node's left and right children, and the result <code>res</code> is the list of paths:</p> <pre><code>[file]{preorder_traversal_iii_template}-[class]{}-[func]{backtrack}\n</code></pre> <p>As per the requirements, after finding a node with a value of \\(7\\), the search should continue. As a result, the <code>return</code> statement after recording the solution should be removed. The figure below compares the search processes with and without retaining the <code>return</code> statement.</p> <p></p> <p>Compared to the implementation based on pre-order traversal, the code using the backtracking algorithm framework seems verbose. However, it has better universality. In fact, many backtracking problems can be solved within this framework. We just need to define <code>state</code> and <code>choices</code> according to the specific problem and implement the methods in the framework.</p>"},{"location":"chapter_backtracking/backtracking_algorithm/#common-terminology","title":"Common terminology","text":"<p>To analyze algorithmic problems more clearly, we summarize the meanings of commonly used terminology in backtracking algorithms and provide corresponding examples from Example Three as shown in the table below.</p> <p> Table  \u00a0 Common backtracking algorithm terminology </p> Term Definition Example Three Solution A solution is an answer that satisfies specific conditions of the problem, which may have one or more All paths from the root node to node \\(7\\) that meet the constraint Constraint Constraints are conditions in the problem that limit the feasibility of solutions, often used for pruning Paths do not contain node \\(3\\) State State represents the situation of the problem at a certain moment, including choices made Current visited node path, i.e., <code>path</code> node list Trial A trial is the process of exploring the solution space based on available choices, including making choices, updating the state, and checking if it's a solution Recursively visiting left (right) child nodes, adding nodes to <code>path</code>, checking if the node's value is \\(7\\) Retreat Retreat refers to the action of undoing previous choices and returning to the previous state when encountering states that do not meet the constraints When passing leaf nodes, ending node visits, encountering nodes with a value of \\(3\\), terminating the search, and the recursion function returns Prune Prune is a method to avoid meaningless search paths based on the characteristics and constraints of the problem, which can enhance search efficiency When encountering a node with a value of \\(3\\), no further search is required <p>Tip</p> <p>Concepts like problems, solutions, states, etc., are universal, and are involved in divide and conquer, backtracking, dynamic programming, and greedy algorithms, among others.</p>"},{"location":"chapter_backtracking/backtracking_algorithm/#advantages-and-limitations","title":"Advantages and limitations","text":"<p>The backtracking algorithm is essentially a depth-first search algorithm that attempts all possible solutions until a satisfying solution is found. The advantage of this method is that it can find all possible solutions, and with reasonable pruning operations, it can be highly efficient.</p> <p>However, when dealing with large-scale or complex problems, the running efficiency of backtracking algorithm may not be acceptable.</p> <ul> <li>Time complexity: Backtracking algorithms usually need to traverse all possible states in the state space, which can reach exponential or factorial time complexity.</li> <li>Space complexity: In recursive calls, it is necessary to save the current state (such as paths, auxiliary variables for pruning, etc.). When the depth is very large, the space need may become significantly bigger.</li> </ul> <p>Even so, backtracking remains the best solution for certain search problems and constraint satisfaction problems. For these problems, there is no way to predict which choices can generate valid solutions. We have to traverse all possible choices. In this case, the key is about how to optimize the efficiency. There are two common efficiency optimization methods.</p> <ul> <li>Prune: Avoid searching paths that definitely will not produce a solution, thus saving time and space.</li> <li>Heuristic search: Introduce some strategies or estimates during the search process to prioritize the paths that are most likely to produce valid solutions.</li> </ul>"},{"location":"chapter_backtracking/backtracking_algorithm/#typical-backtracking-problems","title":"Typical backtracking problems","text":"<p>Backtracking algorithms can be used to solve many search problems, constraint satisfaction problems, and combinatorial optimization problems.</p> <p>Search problems: The goal of these problems is to find solutions that meet specific conditions.</p> <ul> <li>Full permutation problem: Given a set, find all possible permutations and combinations of it.</li> <li>Subset sum problem: Given a set and a target sum, find all subsets of the set that sum to the target.</li> <li>Tower of Hanoi problem: Given three rods and a series of different-sized discs, the goal is to move all the discs from one rod to another, moving only one disc at a time, and never placing a larger disc on a smaller one.</li> </ul> <p>Constraint satisfaction problems: The goal of these problems is to find solutions that satisfy all the constraints.</p> <ul> <li>\\(n\\) queens: Place \\(n\\) queens on an \\(n \\times n\\) chessboard so that they do not attack each other.</li> <li>Sudoku: Fill a \\(9 \\times 9\\) grid with the numbers \\(1\\) to \\(9\\), ensuring that the numbers do not repeat in each row, each column, and each \\(3 \\times 3\\) subgrid.</li> <li>Graph coloring problem: Given an undirected graph, color each vertex with the fewest possible colors so that adjacent vertices have different colors.</li> </ul> <p>Combinatorial optimization problems: The goal of these problems is to find the optimal solution within a combination space that meets certain conditions.</p> <ul> <li>0-1 knapsack problem: Given a set of items and a backpack, each item has a certain value and weight. The goal is to choose items to maximize the total value within the backpack's capacity limit.</li> <li>Traveling salesman problem: In a graph, starting from one point, visit all other points exactly once and then return to the starting point, seeking the shortest path.</li> <li>Maximum clique problem: Given an undirected graph, find the largest complete subgraph, i.e., a subgraph where any two vertices are connected by an edge.</li> </ul> <p>Please note that for many combinatorial optimization problems, backtracking is not the optimal solution.</p> <ul> <li>The 0-1 knapsack problem is usually solved using dynamic programming to achieve higher time efficiency.</li> <li>The traveling salesman is a well-known NP-Hard problem, commonly solved using genetic algorithms and ant colony algorithms, among others.</li> <li>The maximum clique problem is a classic problem in graph theory, which can be solved using greedy algorithms and other heuristic methods.</li> </ul>"},{"location":"chapter_backtracking/n_queens_problem/","title":"13.4 n queens problem","text":""},{"location":"chapter_backtracking/n_queens_problem/#n-queens-problem","title":"n queens problem","text":"<p>Question</p> <p>According to the rules of chess, a queen can attack pieces in the same row, column, or diagonal line. Given \\(n\\) queens and an \\(n \\times n\\) chessboard, find arrangements where no two queens can attack each other.</p> <p>As shown in the figure below, there are two solutions when \\(n = 4\\). From the perspective of the backtracking algorithm, an \\(n \\times n\\) chessboard has \\(n^2\\) squares, presenting all possible choices <code>choices</code>. The state of the chessboard <code>state</code> changes continuously as each queen is placed.</p> <p></p> <p>The figure below shows the three constraints of this problem: multiple queens cannot occupy the same row, column, or diagonal. It is important to note that diagonals are divided into the main diagonal <code>\\</code> and the secondary diagonal <code>/</code>.</p> <p></p>"},{"location":"chapter_backtracking/n_queens_problem/#row-by-row-placing-strategy","title":"Row-by-row placing strategy","text":"<p>As the number of queens equals the number of rows on the chessboard, both being \\(n\\), it is easy to conclude that each row on the chessboard allows and only allows one queen to be placed.</p> <p>This means that we can adopt a row-by-row placing strategy: starting from the first row, place one queen per row until the last row is reached.</p> <p>The figure below shows the row-by-row placing process for the 4 queens problem. Due to space limitations, the figure only expands one search branch of the first row, and prunes any placements that do not meet the column and diagonal constraints.</p> <p></p> <p>Essentially, the row-by-row placing strategy serves as a pruning function, eliminating all search branches that would place multiple queens in the same row.</p>"},{"location":"chapter_backtracking/n_queens_problem/#column-and-diagonal-pruning","title":"Column and diagonal pruning","text":"<p>To satisfy column constraints, we can use a boolean array <code>cols</code> of length \\(n\\) to track whether a queen occupies each column. Before each placement decision, <code>cols</code> is used to prune the columns that already have queens, and it is dynamically updated during backtracking.</p> <p>Tip</p> <p>Note that the origin of the matrix is located in the upper left corner, where the row index increases from top to bottom, and the column index increases from left to right.</p> <p>How about the diagonal constraints? Let the row and column indices of a certain cell on the chessboard be \\((row, col)\\). By selecting a specific main diagonal, we notice that the difference \\(row - col\\) is the same for all cells on that diagonal, meaning that \\(row - col\\) is a constant value on the main diagonal.</p> <p>In other words, if two cells satisfy \\(row_1 - col_1 = row_2 - col_2\\), they are definitely on the same main diagonal. Using this pattern, we can utilize the array <code>diags1</code> shown in the figure below to track whether a queen is on any main diagonal.</p> <p>Similarly, the sum of \\(row + col\\) is a constant value for all cells on the secondary diagonal. We can also use the array <code>diags2</code> to handle secondary diagonal constraints.</p> <p></p>"},{"location":"chapter_backtracking/n_queens_problem/#code-implementation","title":"Code implementation","text":"<p>Please note, in an \\(n\\)-dimensional square matrix, the range of \\(row - col\\) is \\([-n + 1, n - 1]\\), and the range of \\(row + col\\) is \\([0, 2n - 2]\\). Consequently, the number of both main and secondary diagonals is \\(2n - 1\\), meaning the length of the arrays <code>diags1</code> and <code>diags2</code> is \\(2n - 1\\).</p> <pre><code>[file]{n_queens}-[class]{}-[func]{n_queens}\n</code></pre> <p>Placing \\(n\\) queens row-by-row, considering column constraints, from the first row to the last row, there are \\(n\\), \\(n-1\\), \\(\\dots\\), \\(2\\), \\(1\\) choices, using \\(O(n!)\\) time. When recording a solution, it is necessary to copy the matrix <code>state</code> and add it to <code>res</code>, with the copying operation using \\(O(n^2)\\) time. Therefore, the overall time complexity is \\(O(n! \\cdot n^2)\\). In practice, pruning based on diagonal constraints can significantly reduce the search space, thus often the search efficiency is better than the aforementioned time complexity.</p> <p>Array <code>state</code> uses \\(O(n^2)\\) space, and arrays <code>cols</code>, <code>diags1</code>, and <code>diags2</code> each use \\(O(n)\\) space as well. The maximum recursion depth is \\(n\\), using \\(O(n)\\) stack frame space. Therefore, the space complexity is \\(O(n^2)\\).</p>"},{"location":"chapter_backtracking/permutations_problem/","title":"13.2 Permutation problem","text":""},{"location":"chapter_backtracking/permutations_problem/#permutation-problem","title":"Permutation problem","text":"<p>The permutation problem is a typical application of the backtracking algorithm. It involves finding all possible arrangements (permutations) of elements from a given set, such as an array or a string.</p> <p>The table below shows several examples, including input arrays and their corresponding permutations.</p> <p> Table  \u00a0 Permutation examples </p> Input array Permutations \\([1]\\) \\([1]\\) \\([1, 2]\\) \\([1, 2], [2, 1]\\) \\([1, 2, 3]\\) \\([1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]\\)"},{"location":"chapter_backtracking/permutations_problem/#cases-without-duplicate-elements","title":"Cases without duplicate elements","text":"<p>Question</p> <p>Given an integer array with no duplicate elements, return all possible permutations.</p> <p>From a backtracking perspective, we can view the process of generating permutations as a series of choices. Suppose the input array is \\([1, 2, 3]\\). If we choose \\(1\\) first, then \\(3\\), and finally \\(2\\), we get the permutation \\([1, 3, 2]\\). \"Backtracking\" means undoing a previous choice and exploring alternative options.</p> <p>From a coding perspective, the candidate set <code>choices</code> consists of all elements in the input array, while <code>state</code> holds the elements selected so far. Since each element can only be chosen once, all elements in <code>state</code> must be unique.</p> <p>As illustrated in the figure below, we can expand the search process into a recursive tree, where each node represents the current <code>state</code>. Starting from the root node, after three rounds of selections, we reach the leaf nodes\u2014each corresponding to a permutation.</p> <p></p>"},{"location":"chapter_backtracking/permutations_problem/#repeated-choice-pruning","title":"Repeated-choice pruning","text":"<p>To ensure each element is selected only once, we introduce a boolean array <code>selected</code>, where <code>selected[i]</code> indicates whether <code>choices[i]</code> has been chosen. We then base our pruning steps on this array:</p> <ul> <li>After choosing <code>choice[i]</code>, set <code>selected[i]</code> to \\(\\text{True}\\) to mark it as chosen.</li> <li>While iterating through <code>choices</code>, skip all elements marked as chosen (i.e., prune those branches).</li> </ul> <p>As shown in the figure below, suppose we choose 1 in the first round, then 3 in the second round, and finally 2 in the third round. We need to prune the branch for element 1 in the second round and the branches for elements 1 and 3 in the third round.</p> <p></p> <p>From the figure, we can see that this pruning process reduces the search space from \\(O(n^n)\\) to \\(O(n!)\\).</p>"},{"location":"chapter_backtracking/permutations_problem/#code-implementation","title":"Code implementation","text":"<p>With this understanding, we can \"fill in the blanks\" of our framework code. To keep the overall code concise, we won\u2019t implement each part of the framework separately but instead expand everything in the <code>backtrack()</code> function:</p> <pre><code>[file]{permutations_i}-[class]{}-[func]{permutations_i}\n</code></pre>"},{"location":"chapter_backtracking/permutations_problem/#considering-duplicate-elements","title":"Considering duplicate elements","text":"<p>Question</p> <p>Given an integer array**that may contain duplicate elements**, return all unique permutations.</p> <p>Suppose the input array is \\([1, 1, 2]\\). To distinguish between the two identical elements \\(1\\), we label the second one as \\(\\hat{1}\\).</p> <p>As shown in the figure below, half of the permutations produced by this method are duplicates:</p> <p></p> <p>So how can we eliminate these duplicate permutations? One direct approach is to use a hash set to remove duplicates after generating all permutations. However, this is less elegant because branches that produce duplicates are inherently unnecessary and should be pruned in advance, thus improving the algorithm\u2019s efficiency.</p>"},{"location":"chapter_backtracking/permutations_problem/#equal-element-pruning","title":"Equal-element pruning","text":"<p>Looking at the figure below, in the first round, choosing \\(1\\) or \\(\\hat{1}\\) leads to the same permutations, so we prune \\(\\hat{1}\\).</p> <p>Similarly, after choosing \\(2\\) in the first round, choosing \\(1\\) or \\(\\hat{1}\\) in the second round also leads to duplicate branches, so we prune \\(\\hat{1}\\) then as well.</p> <p>Essentially, our goal is to ensure that multiple identical elements are only selected once per round of choices.</p> <p></p>"},{"location":"chapter_backtracking/permutations_problem/#code-implementation_1","title":"Code implementation","text":"<p>Based on the code from the previous problem, we introduce a hash set <code>duplicated</code> in each round. This set keeps track of elements we have already attempted, so we can prune duplicates:</p> <pre><code>[file]{permutations_ii}-[class]{}-[func]{permutations_ii}\n</code></pre> <p>Assuming all elements are distinct, there are \\(n!\\) (factorial) permutations of \\(n\\) elements. Recording each result requires copying a list of length \\(n\\), which takes \\(O(n)\\) time. Hence, the total time complexity is \\(O(n!n)\\).</p> <p>The maximum recursion depth is \\(n\\), using \\(O(n)\\) stack space. The <code>selected</code> array also requires \\(O(n)\\) space. Because there can be up to \\(n\\) separate <code>duplicated</code> sets at any one time, they collectively occupy \\(O(n^2)\\) space. Therefore, the space complexity is \\(O(n^2)\\).</p>"},{"location":"chapter_backtracking/permutations_problem/#comparing-the-two-pruning-methods","title":"Comparing the two pruning methods","text":"<p>Although both <code>selected</code> and <code>duplicated</code> serve as pruning mechanisms, they target different issues:</p> <ul> <li>Repeated-choice pruning(via <code>selected</code>): There is a single <code>selected</code> array for the entire search, indicating which elements are already in the current state. This prevents the same element from appearing more than once in <code>state</code>.</li> <li>Equal-element pruning(via <code>duplicated</code>): Each call to the <code>backtrack</code> function uses its own <code>duplicated</code> set, recording which elements have already been chosen in that specific iteration (<code>for</code> loop). This ensures that equal elements are selected only once per round of choices.</li> </ul> <p>The figure below shows the scope of these two pruning strategies. Each node in the tree represents a choice; the path from the root to any leaf corresponds to one complete permutation.</p> <p></p>"},{"location":"chapter_backtracking/subset_sum_problem/","title":"13.3 Subset sum problem","text":""},{"location":"chapter_backtracking/subset_sum_problem/#subset-sum-problem","title":"Subset sum problem","text":""},{"location":"chapter_backtracking/subset_sum_problem/#case-without-duplicate-elements","title":"Case without duplicate elements","text":"<p>Question</p> <p>Given an array of positive integers <code>nums</code> and a target positive integer <code>target</code>, find all possible combinations such that the sum of the elements in the combination equals <code>target</code>. The given array has no duplicate elements, and each element can be chosen multiple times. Please return these combinations as a list, which should not contain duplicate combinations.</p> <p>For example, for the input set \\(\\{3, 4, 5\\}\\) and target integer \\(9\\), the solutions are \\(\\{3, 3, 3\\}, \\{4, 5\\}\\). Note the following two points.</p> <ul> <li>Elements in the input set can be chosen an unlimited number of times.</li> <li>Subsets do not distinguish the order of elements, for example \\(\\{4, 5\\}\\) and \\(\\{5, 4\\}\\) are the same subset.</li> </ul>"},{"location":"chapter_backtracking/subset_sum_problem/#reference-permutation-solution","title":"Reference permutation solution","text":"<p>Similar to the permutation problem, we can imagine the generation of subsets as a series of choices, updating the \"element sum\" in real-time during the choice process. When the element sum equals <code>target</code>, the subset is recorded in the result list.</p> <p>Unlike the permutation problem, elements in this problem can be chosen an unlimited number of times, thus there is no need to use a <code>selected</code> boolean list to record whether an element has been chosen. We can make minor modifications to the permutation code to initially solve the problem:</p> <pre><code>[file]{subset_sum_i_naive}-[class]{}-[func]{subset_sum_i_naive}\n</code></pre> <p>Inputting the array \\([3, 4, 5]\\) and target element \\(9\\) into the above code yields the results \\([3, 3, 3], [4, 5], [5, 4]\\). Although it successfully finds all subsets with a sum of \\(9\\), it includes the duplicate subset \\([4, 5]\\) and \\([5, 4]\\).</p> <p>This is because the search process distinguishes the order of choices, however, subsets do not distinguish the choice order. As shown in the figure below, choosing \\(4\\) before \\(5\\) and choosing \\(5\\) before \\(4\\) are different branches, but correspond to the same subset.</p> <p></p> <p>To eliminate duplicate subsets, a straightforward idea is to deduplicate the result list. However, this method is very inefficient for two reasons.</p> <ul> <li>When there are many array elements, especially when <code>target</code> is large, the search process produces a large number of duplicate subsets.</li> <li>Comparing subsets (arrays) for differences is very time-consuming, requiring arrays to be sorted first, then comparing the differences of each element in the arrays.</li> </ul>"},{"location":"chapter_backtracking/subset_sum_problem/#duplicate-subset-pruning","title":"Duplicate subset pruning","text":"<p>We consider deduplication during the search process through pruning. Observing the figure below, duplicate subsets are generated when choosing array elements in different orders, for example in the following situations.</p> <ol> <li>When choosing \\(3\\) in the first round and \\(4\\) in the second round, all subsets containing these two elements are generated, denoted as \\([3, 4, \\dots]\\).</li> <li>Later, when \\(4\\) is chosen in the first round, the second round should skip \\(3\\) because the subset \\([4, 3, \\dots]\\) generated by this choice completely duplicates the subset from step <code>1.</code>.</li> </ol> <p>In the search process, each layer's choices are tried one by one from left to right, so the more to the right a branch is, the more it is pruned.</p> <ol> <li>First two rounds choose \\(3\\) and \\(5\\), generating subset \\([3, 5, \\dots]\\).</li> <li>First two rounds choose \\(4\\) and \\(5\\), generating subset \\([4, 5, \\dots]\\).</li> <li>If \\(5\\) is chosen in the first round, then the second round should skip \\(3\\) and \\(4\\) as the subsets \\([5, 3, \\dots]\\) and \\([5, 4, \\dots]\\) completely duplicate the subsets described in steps <code>1.</code> and <code>2.</code>.</li> </ol> <p></p> <p>In summary, given the input array \\([x_1, x_2, \\dots, x_n]\\), the choice sequence in the search process should be \\([x_{i_1}, x_{i_2}, \\dots, x_{i_m}]\\), which needs to satisfy \\(i_1 \\leq i_2 \\leq \\dots \\leq i_m\\). Any choice sequence that does not meet this condition will cause duplicates and should be pruned.</p>"},{"location":"chapter_backtracking/subset_sum_problem/#code-implementation","title":"Code implementation","text":"<p>To implement this pruning, we initialize the variable <code>start</code>, which indicates the starting point for traversal. After making the choice \\(x_{i}\\), set the next round to start from index \\(i\\). This will ensure the choice sequence satisfies \\(i_1 \\leq i_2 \\leq \\dots \\leq i_m\\), thereby ensuring the uniqueness of the subsets.</p> <p>Besides, we have made the following two optimizations to the code.</p> <ul> <li>Before starting the search, sort the array <code>nums</code>. In the traversal of all choices, end the loop directly when the subset sum exceeds <code>target</code> as subsequent elements are larger and their subset sum will definitely exceed <code>target</code>.</li> <li>Eliminate the element sum variable <code>total</code>, by performing subtraction on <code>target</code> to count the element sum. When <code>target</code> equals \\(0\\), record the solution.</li> </ul> <pre><code>[file]{subset_sum_i}-[class]{}-[func]{subset_sum_i}\n</code></pre> <p>The figure below shows the overall backtracking process after inputting the array \\([3, 4, 5]\\) and target element \\(9\\) into the above code.</p> <p></p>"},{"location":"chapter_backtracking/subset_sum_problem/#considering-cases-with-duplicate-elements","title":"Considering cases with duplicate elements","text":"<p>Question</p> <p>Given an array of positive integers <code>nums</code> and a target positive integer <code>target</code>, find all possible combinations such that the sum of the elements in the combination equals <code>target</code>. The given array may contain duplicate elements, and each element can only be chosen once. Please return these combinations as a list, which should not contain duplicate combinations.</p> <p>Compared to the previous question, this question's input array may contain duplicate elements, introducing new problems. For example, given the array \\([4, \\hat{4}, 5]\\) and target element \\(9\\), the existing code's output results in \\([4, 5], [\\hat{4}, 5]\\), resulting in duplicate subsets.</p> <p>The reason for this duplication is that equal elements are chosen multiple times in a certain round. In the figure below, the first round has three choices, two of which are \\(4\\), generating two duplicate search branches, thus outputting duplicate subsets; similarly, the two \\(4\\)s in the second round also produce duplicate subsets.</p> <p></p>"},{"location":"chapter_backtracking/subset_sum_problem/#equal-element-pruning","title":"Equal element pruning","text":"<p>To solve this issue, we need to limit equal elements to being chosen only once per round. The implementation is quite clever: since the array is sorted, equal elements are adjacent. This means that in a certain round of choices, if the current element is equal to its left-hand element, it means it has already been chosen, so skip the current element directly.</p> <p>At the same time, this question stipulates that each array element can only be chosen once. Fortunately, we can also use the variable <code>start</code> to meet this constraint: after making the choice \\(x_{i}\\), set the next round to start from index \\(i + 1\\) going forward. This not only eliminates duplicate subsets but also avoids repeated selection of elements.</p>"},{"location":"chapter_backtracking/subset_sum_problem/#code-implementation_1","title":"Code implementation","text":"<pre><code>[file]{subset_sum_ii}-[class]{}-[func]{subset_sum_ii}\n</code></pre> <p>The figure below shows the backtracking process for the array \\([4, 4, 5]\\) and target element \\(9\\), including four types of pruning operations. Please combine the illustration with the code comments to understand the entire search process and how each type of pruning operation works.</p> <p></p>"},{"location":"chapter_backtracking/summary/","title":"13.5 Summary","text":""},{"location":"chapter_backtracking/summary/#summary","title":"Summary","text":""},{"location":"chapter_backtracking/summary/#key-review","title":"Key review","text":"<ul> <li>The essence of the backtracking algorithm is exhaustive search. It seeks solutions that meet the conditions by performing a depth-first traversal of the solution space. During the search, if a satisfying solution is found, it is recorded, until all solutions are found or the traversal is completed.</li> <li>The search process of the backtracking algorithm includes trying and backtracking. It uses depth-first search to explore various choices, and when a choice does not meet the constraints, the previous choice is undone. Then it reverts to the previous state and continues to try other options. Trying and backtracking are operations in opposite directions.</li> <li>Backtracking problems usually contain multiple constraints. These constraints can be used to perform pruning operations. Pruning can terminate unnecessary search branches in advance, greatly enhancing search efficiency.</li> <li>The backtracking algorithm is mainly used to solve search problems and constraint satisfaction problems. Although combinatorial optimization problems can be solved using backtracking, there are often more efficient or effective solutions available.</li> <li>The permutation problem aims to search for all possible permutations of the elements in a given set. We use an array to record whether each element has been chosen, avoiding repeated selection of the same element. This ensures that each element is chosen only once.</li> <li>In permutation problems, if the set contains duplicate elements, the final result will include duplicate permutations. We need to restrict that identical elements can only be selected once in each round, which is usually implemented using a hash set.</li> <li>The subset-sum problem aims to find all subsets in a given set that sum to a target value. The set does not distinguish the order of elements, but the search process may generate duplicate subsets. This occurs because the algorithm explores different element orders as unique paths. Before backtracking, we sort the data and set a variable to indicate the starting point of the traversal for each round. This allows us to prune the search branches that generate duplicate subsets.</li> <li>For the subset-sum problem, equal elements in the array can produce duplicate sets. Using the precondition that the array is already sorted, we prune by determining if adjacent elements are equal. This ensures that equal elements are only selected once per round.</li> <li>The \\(n\\) queens problem aims to find schemes to place \\(n\\) queens on an \\(n \\times n\\) chessboard such that no two queens can attack each other. The constraints of the problem include row constraints, column constraints, and constraints on the main and secondary diagonals. To meet the row constraint, we adopt a strategy of placing one queen per row, ensuring each row has one queen placed.</li> <li>The handling of column constraints and diagonal constraints is similar. For column constraints, we use an array to record whether there is a queen in each column, thereby indicating whether the selected cell is legal. For diagonal constraints, we use two arrays to respectively record the presence of queens on the main and secondary diagonals. The challenge is to determine the relationship between row and column indices for cells on the same main or secondary diagonal.</li> </ul>"},{"location":"chapter_backtracking/summary/#q-a","title":"Q &amp; A","text":"<p>Q: How can we understand the relationship between backtracking and recursion?</p> <p>Overall, backtracking is an \"algorithmic strategy,\" while recursion is more of a \"tool.\"</p> <ul> <li>Backtracking algorithms are typically based on recursion. However, backtracking is one of the application scenarios of recursion, specifically in search problems.</li> <li>The structure of recursion reflects the problem-solving paradigm of \"sub-problem decomposition.\" It is commonly used in solving problems involving divide and conquer, backtracking, and dynamic programming (memoized recursion).</li> </ul>"},{"location":"chapter_computational_complexity/","title":"Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p","text":""},{"location":"chapter_computational_complexity/#phan-tich-o-phuc-tap","title":"Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p","text":"<p>Abstract</p> <p>Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p gi\u1ed1ng nh\u01b0 m\u1ed9t nh\u00e0 \u0111i\u1ec1u h\u01b0\u1edbng kh\u00f4ng gian-th\u1eddi gian trong v\u0169 tr\u1ee5 r\u1ed9ng l\u1edbn c\u1ee7a c\u00e1c thu\u1eadt to\u00e1n.</p> <p>N\u00f3 h\u01b0\u1edbng d\u1eabn ch\u00fang ta kh\u00e1m ph\u00e1 s\u00e2u h\u01a1n trong c\u00e1c chi\u1ec1u kh\u00f4ng gian v\u00e0 th\u1eddi gian, t\u00ecm ki\u1ebfm c\u00e1c gi\u1ea3i ph\u00e1p tinh t\u1ebf h\u01a1n.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/","title":"2.2 Iteration and recursion","text":""},{"location":"chapter_computational_complexity/iteration_and_recursion/#lap-va-e-quy-iteration-and-recursion","title":"L\u1eb7p v\u00e0 \u0111\u1ec7 quy (Iteration and recursion)","text":"<p>Trong thu\u1eadt to\u00e1n, vi\u1ec7c th\u1ef1c hi\u1ec7n l\u1eb7p l\u1ea1i m\u1ed9t t\u00e1c v\u1ee5 l\u00e0 r\u1ea5t ph\u1ed5 bi\u1ebfn v\u00e0 li\u00ean quan ch\u1eb7t ch\u1ebd \u0111\u1ebfn ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p. V\u00ec v\u1eady, tr\u01b0\u1edbc khi t\u00ecm hi\u1ec3u v\u1ec1 kh\u00e1i ni\u1ec7m \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian v\u00e0 \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian, h\u00e3y c\u00f9ng kh\u00e1m ph\u00e1 c\u00e1ch tri\u1ec3n khai c\u00e1c t\u00e1c v\u1ee5 l\u1eb7p l\u1ea1i trong l\u1eadp tr\u00ecnh. \u0110i\u1ec1u n\u00e0y li\u00ean quan \u0111\u1ebfn hai c\u1ea5u tr\u00fac \u0111i\u1ec1u khi\u1ec3n c\u01a1 b\u1ea3n: l\u1eb7p (iteration) v\u00e0 \u0111\u1ec7 quy (recursion).</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#iteration","title":"Iteration","text":"<p>Iteration l\u00e0 m\u1ed9t c\u1ea5u tr\u00fac \u0111i\u1ec1u khi\u1ec3n d\u00f9ng \u0111\u1ec3 th\u1ef1c hi\u1ec7n m\u1ed9t t\u00e1c v\u1ee5 nhi\u1ec1u l\u1ea7n. Trong iteration, ch\u01b0\u01a1ng tr\u00ecnh s\u1ebd l\u1eb7p l\u1ea1i m\u1ed9t kh\u1ed1i m\u00e3 khi \u0111i\u1ec1u ki\u1ec7n n\u00e0o \u0111\u00f3 c\u00f2n \u0111\u00fang, cho \u0111\u1ebfn khi \u0111i\u1ec1u ki\u1ec7n kh\u00f4ng c\u00f2n \u0111\u01b0\u1ee3c th\u1ecfa m\u00e3n.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#vong-lap-for","title":"V\u00f2ng l\u1eb7p for","text":"<p>V\u00f2ng l\u1eb7p <code>for</code> l\u00e0 m\u1ed9t trong nh\u1eefng d\u1ea1ng l\u1eb7p ph\u1ed5 bi\u1ebfn nh\u1ea5t, \u0111\u1eb7c bi\u1ec7t ph\u00f9 h\u1ee3p khi bi\u1ebft tr\u01b0\u1edbc s\u1ed1 l\u1ea7n l\u1eb7p.</p> <p>H\u00e0m d\u01b0\u1edbi \u0111\u00e2y s\u1eed d\u1ee5ng v\u00f2ng l\u1eb7p <code>for</code> \u0111\u1ec3 t\u00ednh t\u1ed5ng \\(1 + 2 + \\dots + n\\), v\u1edbi k\u1ebft qu\u1ea3 \u0111\u01b0\u1ee3c l\u01b0u v\u00e0o bi\u1ebfn <code>res</code>. L\u01b0u \u00fd r\u1eb1ng trong Python, <code>range(a, b)</code> t\u1ea1o ra m\u1ed9t kho\u1ea3ng t\u1eeb \\(a\\) \u0111\u1ebfn \\(b-1\\), ngh\u0129a l\u00e0 bao g\u1ed3m \\(a\\) nh\u01b0ng kh\u00f4ng bao g\u1ed3m \\(b\\).</p> <pre><code>[file]{iteration}-[class]{}-[func]{for_loop}\n</code></pre> <p>H\u00ecnh d\u01b0\u1edbi minh h\u1ecda qu\u00e1 tr\u00ecnh t\u00ednh t\u1ed5ng n\u00e0y.</p> <p></p> <p>S\u1ed1 l\u01b0\u1ee3ng ph\u00e9p to\u00e1n trong h\u00e0m n\u00e0y t\u1ef7 l\u1ec7 thu\u1eadn v\u1edbi k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o \\(n\\), hay n\u00f3i c\u00e1ch kh\u00e1c, c\u00f3 m\u1ed1i quan h\u1ec7 tuy\u1ebfn t\u00ednh. \"M\u1ed1i quan h\u1ec7 tuy\u1ebfn t\u00ednh\" n\u00e0y ch\u00ednh l\u00e0 \u0111i\u1ec1u m\u00e0 \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian m\u00f4 t\u1ea3. Ch\u1ee7 \u0111\u1ec1 n\u00e0y s\u1ebd \u0111\u01b0\u1ee3c tr\u00ecnh b\u00e0y chi ti\u1ebft h\u01a1n \u1edf ph\u1ea7n sau.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#vong-lap-while","title":"V\u00f2ng l\u1eb7p while","text":"<p>T\u01b0\u01a1ng t\u1ef1 nh\u01b0 v\u00f2ng l\u1eb7p <code>for</code>, v\u00f2ng l\u1eb7p <code>while</code> c\u0169ng l\u00e0 m\u1ed9t c\u00e1ch \u0111\u1ec3 th\u1ef1c hi\u1ec7n l\u1eb7p. Trong v\u00f2ng l\u1eb7p <code>while</code>, ch\u01b0\u01a1ng tr\u00ecnh ki\u1ec3m tra \u0111i\u1ec1u ki\u1ec7n \u1edf \u0111\u1ea7u m\u1ed7i v\u00f2ng l\u1eb7p; n\u1ebfu \u0111i\u1ec1u ki\u1ec7n \u0111\u00fang th\u00ec ti\u1ebfp t\u1ee5c th\u1ef1c hi\u1ec7n, n\u1ebfu sai th\u00ec k\u1ebft th\u00fac v\u00f2ng l\u1eb7p.</p> <p>D\u01b0\u1edbi \u0111\u00e2y l\u00e0 v\u00ed d\u1ee5 s\u1eed d\u1ee5ng v\u00f2ng l\u1eb7p <code>while</code> \u0111\u1ec3 t\u00ednh t\u1ed5ng \\(1 + 2 + \\dots + n\\).</p> <pre><code>[file]{iteration}-[class]{}-[func]{while_loop}\n</code></pre> <p>V\u00f2ng l\u1eb7p <code>while</code> linh ho\u1ea1t h\u01a1n v\u00f2ng l\u1eb7p <code>for</code>, \u0111\u1eb7c bi\u1ec7t l\u00e0 cho ph\u00e9p kh\u1edfi t\u1ea1o v\u00e0 thay \u0111\u1ed5i bi\u1ebfn \u0111i\u1ec1u ki\u1ec7n m\u1ed9t c\u00e1ch t\u00f9y \u00fd \u1edf m\u1ed7i b\u01b0\u1edbc.</p> <p>V\u00ed d\u1ee5, trong \u0111o\u1ea1n m\u00e3 sau, bi\u1ebfn \u0111i\u1ec1u ki\u1ec7n \\(i\\) \u0111\u01b0\u1ee3c c\u1eadp nh\u1eadt hai l\u1ea7n m\u1ed7i v\u00f2ng, \u0111i\u1ec1u n\u00e0y s\u1ebd kh\u00f3 th\u1ef1c hi\u1ec7n v\u1edbi v\u00f2ng l\u1eb7p <code>for</code>.</p> <pre><code>[file]{iteration}-[class]{}-[func]{while_loop_ii}\n</code></pre> <p>Nh\u00ecn chung, v\u00f2ng l\u1eb7p <code>for</code> ng\u1eafn g\u1ecdn h\u01a1n, c\u00f2n v\u00f2ng l\u1eb7p <code>while</code> linh ho\u1ea1t h\u01a1n. C\u1ea3 hai \u0111\u1ec1u c\u00f3 th\u1ec3 tri\u1ec3n khai c\u1ea5u tr\u00fac l\u1eb7p. Vi\u1ec7c l\u1ef1a ch\u1ecdn lo\u1ea1i v\u00f2ng l\u1eb7p n\u00ean d\u1ef1a v\u00e0o y\u00eau c\u1ea7u c\u1ee5 th\u1ec3 c\u1ee7a b\u00e0i to\u00e1n.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#vong-lap-long-nhau-nested-loops","title":"V\u00f2ng l\u1eb7p l\u1ed3ng nhau (Nested loops)","text":"<p>Ta c\u00f3 th\u1ec3 l\u1ed3ng m\u1ed9t v\u00f2ng l\u1eb7p b\u00ean trong v\u00f2ng l\u1eb7p kh\u00e1c. D\u01b0\u1edbi \u0111\u00e2y l\u00e0 v\u00ed d\u1ee5 s\u1eed d\u1ee5ng v\u00f2ng l\u1eb7p <code>for</code> l\u1ed3ng nhau:</p> <pre><code>[file]{iteration}-[class]{}-[func]{nested_for_loop}\n</code></pre> <p>H\u00ecnh d\u01b0\u1edbi minh h\u1ecda qu\u00e1 tr\u00ecnh l\u1eb7p l\u1ed3ng nhau.</p> <p></p> <p>Trong tr\u01b0\u1eddng h\u1ee3p n\u00e0y, s\u1ed1 l\u01b0\u1ee3ng ph\u00e9p to\u00e1n t\u1ef7 l\u1ec7 v\u1edbi \\(n^2\\), ngh\u0129a l\u00e0 th\u1eddi gian ch\u1ea1y c\u1ee7a thu\u1eadt to\u00e1n v\u00e0 k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o \\(n\\) c\u00f3 m\u1ed1i quan h\u1ec7 \"b\u1eadc hai\".</p> <p>Ta c\u00f3 th\u1ec3 t\u0103ng \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1eb1ng c\u00e1ch th\u00eam nhi\u1ec1u v\u00f2ng l\u1eb7p l\u1ed3ng nhau, m\u1ed7i c\u1ea5p \u0111\u1ed9 l\u1ed3ng s\u1ebd \"t\u0103ng chi\u1ec1u\", l\u00e0m \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian l\u00ean \"b\u1eadc ba\", \"b\u1eadc b\u1ed1n\", v.v.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#e-quy-recursion","title":"\u0110\u1ec7 quy (Recursion)","text":"<p>\u0110\u1ec7 quy l\u00e0 chi\u1ebfn l\u01b0\u1ee3c thu\u1eadt to\u00e1n m\u00e0 m\u1ed9t h\u00e0m gi\u1ea3i quy\u1ebft b\u00e0i to\u00e1n b\u1eb1ng c\u00e1ch t\u1ef1 g\u1ecdi l\u1ea1i ch\u00ednh n\u00f3. \u0110\u1ec7 quy ch\u1ee7 y\u1ebfu g\u1ed3m hai giai \u0111o\u1ea1n:</p> <ol> <li>G\u1ecdi h\u00e0m: Ch\u01b0\u01a1ng tr\u00ecnh li\u00ean t\u1ee5c g\u1ecdi l\u1ea1i ch\u00ednh n\u00f3, th\u01b0\u1eddng v\u1edbi tham s\u1ed1 nh\u1ecf h\u01a1n ho\u1eb7c \u0111\u01a1n gi\u1ea3n h\u01a1n, ti\u1ebfn d\u1ea7n \u0111\u1ebfn \"\u0111i\u1ec1u ki\u1ec7n d\u1eebng\".</li> <li>Tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3: Khi g\u1eb7p \"\u0111i\u1ec1u ki\u1ec7n d\u1eebng\", ch\u01b0\u01a1ng tr\u00ecnh b\u1eaft \u0111\u1ea7u tr\u1ea3 v\u1ec1 t\u1eeb h\u00e0m \u0111\u1ec7 quy s\u00e2u nh\u1ea5t, t\u1ed5ng h\u1ee3p k\u1ebft qu\u1ea3 c\u1ee7a t\u1eebng l\u1edbp.</li> </ol> <p>V\u1ec1 m\u1eb7t tri\u1ec3n khai, m\u00e3 \u0111\u1ec7 quy th\u01b0\u1eddng g\u1ed3m ba y\u1ebfu t\u1ed1 ch\u00ednh:</p> <ol> <li>\u0110i\u1ec1u ki\u1ec7n d\u1eebng: X\u00e1c \u0111\u1ecbnh khi n\u00e0o chuy\u1ec3n t\u1eeb \"g\u1ecdi h\u00e0m\" sang \"tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3\".</li> <li>G\u1ecdi \u0111\u1ec7 quy: T\u01b0\u01a1ng \u1ee9ng v\u1edbi \"g\u1ecdi h\u00e0m\", n\u01a1i h\u00e0m t\u1ef1 g\u1ecdi l\u1ea1i ch\u00ednh n\u00f3, th\u01b0\u1eddng v\u1edbi tham s\u1ed1 nh\u1ecf h\u01a1n ho\u1eb7c \u0111\u01a1n gi\u1ea3n h\u01a1n.</li> <li>Tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3: T\u01b0\u01a1ng \u1ee9ng v\u1edbi \"tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3\", tr\u1ea3 v\u1ec1 k\u1ebft qu\u1ea3 c\u1ee7a l\u1edbp \u0111\u1ec7 quy hi\u1ec7n t\u1ea1i cho l\u1edbp tr\u01b0\u1edbc \u0111\u00f3.</li> </ol> <p>Quan s\u00e1t \u0111o\u1ea1n m\u00e3 sau, ch\u1ec9 c\u1ea7n g\u1ecdi h\u00e0m <code>recur(n)</code> l\u00e0 c\u00f3 th\u1ec3 t\u00ednh t\u1ed5ng \\(1 + 2 + \\dots + n\\):</p> <pre><code>[file]{recursion}-[class]{}-[func]{recur}\n</code></pre> <p>H\u00ecnh d\u01b0\u1edbi minh h\u1ecda qu\u00e1 tr\u00ecnh \u0111\u1ec7 quy c\u1ee7a h\u00e0m n\u00e0y.</p> <p></p> <p>M\u1eb7c d\u00f9 l\u1eb7p v\u00e0 \u0111\u1ec7 quy \u0111\u1ec1u c\u00f3 th\u1ec3 \u0111\u1ea1t \u0111\u01b0\u1ee3c k\u1ebft qu\u1ea3 gi\u1ed1ng nhau v\u1ec1 m\u1eb7t t\u00ednh to\u00e1n, nh\u01b0ng ch\u00fang \u0111\u1ea1i di\u1ec7n cho hai c\u00e1ch t\u01b0 duy v\u00e0 gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 ho\u00e0n to\u00e0n kh\u00e1c nhau.</p> <ul> <li>L\u1eb7p: Gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 \"t\u1eeb d\u01b0\u1edbi l\u00ean\". B\u1eaft \u0111\u1ea7u t\u1eeb b\u01b0\u1edbc c\u01a1 b\u1ea3n nh\u1ea5t, r\u1ed3i l\u1eb7p l\u1ea1i ho\u1eb7c c\u1ed9ng d\u1ed3n c\u00e1c b\u01b0\u1edbc n\u00e0y cho \u0111\u1ebfn khi ho\u00e0n th\u00e0nh t\u00e1c v\u1ee5.</li> <li>\u0110\u1ec7 quy: Gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 \"t\u1eeb tr\u00ean xu\u1ed1ng\". Chia b\u00e0i to\u00e1n g\u1ed1c th\u00e0nh c\u00e1c b\u00e0i to\u00e1n con nh\u1ecf h\u01a1n, m\u1ed7i b\u00e0i to\u00e1n con c\u00f3 d\u1ea1ng gi\u1ed1ng b\u00e0i to\u00e1n g\u1ed1c. C\u00e1c b\u00e0i to\u00e1n con ti\u1ebfp t\u1ee5c \u0111\u01b0\u1ee3c chia nh\u1ecf cho \u0111\u1ebfn khi g\u1eb7p tr\u01b0\u1eddng h\u1ee3p c\u01a1 b\u1ea3n c\u00f3 l\u1eddi gi\u1ea3i.</li> </ul> <p>L\u1ea5y v\u00ed d\u1ee5 h\u00e0m t\u00ednh t\u1ed5ng \\(f(n) = 1 + 2 + \\dots + n\\):</p> <ul> <li>Iteration: Ta m\u00f4 ph\u1ecfng qu\u00e1 tr\u00ecnh c\u1ed9ng d\u1ed3n trong v\u00f2ng l\u1eb7p. B\u1eaft \u0111\u1ea7u t\u1eeb \\(1\\) \u0111\u1ebfn \\(n\\), th\u1ef1c hi\u1ec7n ph\u00e9p c\u1ed9ng \u1edf m\u1ed7i v\u00f2ng \u0111\u1ec3 t\u00ednh \\(f(n)\\).</li> <li>\u0110\u1ec7 quy (Recursion): B\u00e0i to\u00e1n \u0111\u01b0\u1ee3c chia th\u00e0nh b\u00e0i to\u00e1n con: \\(f(n) = n + f(n-1)\\). Qu\u00e1 tr\u00ecnh n\u00e0y ti\u1ebfp t\u1ee5c \u0111\u1ec7 quy cho \u0111\u1ebfn khi g\u1eb7p tr\u01b0\u1eddng h\u1ee3p c\u01a1 b\u1ea3n \\(f(1) = 1\\), l\u00fac n\u00e0y \u0111\u1ec7 quy d\u1eebng l\u1ea1i.</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#call-stack","title":"Call stack","text":"<p>M\u1ed7i l\u1ea7n h\u00e0m \u0111\u1ec7 quy t\u1ef1 g\u1ecdi l\u1ea1i, h\u1ec7 th\u1ed1ng s\u1ebd c\u1ea5p ph\u00e1t b\u1ed9 nh\u1edb cho h\u00e0m m\u1edbi \u0111\u1ec3 l\u01b0u bi\u1ebfn c\u1ee5c b\u1ed9, \u0111\u1ecba ch\u1ec9 tr\u1ea3 v\u1ec1 v\u00e0 c\u00e1c th\u00f4ng tin li\u00ean quan. \u0110i\u1ec1u n\u00e0y d\u1eabn \u0111\u1ebfn hai k\u1ebft qu\u1ea3 ch\u00ednh:</p> <ul> <li>D\u1eef li\u1ec7u ng\u1eef c\u1ea3nh c\u1ee7a h\u00e0m \u0111\u01b0\u1ee3c l\u01b0u trong v\u00f9ng nh\u1edb g\u1ecdi l\u00e0 \"khung ng\u0103n x\u1ebfp\" v\u00e0 ch\u1ec9 \u0111\u01b0\u1ee3c gi\u1ea3i ph\u00f3ng sau khi h\u00e0m tr\u1ea3 v\u1ec1. V\u00ec v\u1eady, \u0111\u1ec7 quy th\u01b0\u1eddng ti\u00eau t\u1ed1n nhi\u1ec1u b\u1ed9 nh\u1edb h\u01a1n l\u1eb7p.</li> <li>Vi\u1ec7c g\u1ecdi h\u00e0m \u0111\u1ec7 quy t\u1ea1o ra th\u00eam chi ph\u00ed. Do \u0111\u00f3, \u0111\u1ec7 quy th\u01b0\u1eddng k\u00e9m hi\u1ec7u qu\u1ea3 v\u1ec1 th\u1eddi gian h\u01a1n so v\u1edbi v\u00f2ng l\u1eb7p.</li> </ul> <p>Nh\u01b0 h\u00ecnh d\u01b0\u1edbi, c\u00f3 \\(n\\) h\u00e0m \u0111\u1ec7 quy ch\u01b0a tr\u1ea3 v\u1ec1 tr\u01b0\u1edbc khi g\u1eb7p \u0111i\u1ec1u ki\u1ec7n d\u1eebng, t\u1ee9c l\u00e0 \u0111\u1ed9 s\u00e2u \u0111\u1ec7 quy l\u00e0 \\(n\\).</p> <p></p> <p>Trong th\u1ef1c t\u1ebf, \u0111\u1ed9 s\u00e2u \u0111\u1ec7 quy m\u00e0 ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh cho ph\u00e9p th\u01b0\u1eddng b\u1ecb gi\u1edbi h\u1ea1n, v\u00e0 \u0111\u1ec7 quy qu\u00e1 s\u00e2u c\u00f3 th\u1ec3 g\u00e2y l\u1ed7i tr\u00e0n ng\u0103n x\u1ebfp.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#tail-recursion","title":"Tail recursion","text":"<p>Th\u00fa v\u1ecb l\u00e0, n\u1ebfu h\u00e0m th\u1ef1c hi\u1ec7n g\u1ecdi \u0111\u1ec7 quy \u1edf b\u01b0\u1edbc cu\u1ed1i c\u00f9ng tr\u01b0\u1edbc khi tr\u1ea3 v\u1ec1, n\u00f3 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c tr\u00ecnh bi\u00ean d\u1ecbch ho\u1eb7c th\u00f4ng d\u1ecbch t\u1ed1i \u01b0u h\u00f3a \u0111\u1ec3 ti\u1ebft ki\u1ec7m b\u1ed9 nh\u1edb nh\u01b0 l\u1eb7p. Tr\u01b0\u1eddng h\u1ee3p n\u00e0y g\u1ecdi l\u00e0 tail recursion.</p> <ul> <li>Regular recursion: Khi tr\u1ea3 v\u1ec1 cho l\u1edbp tr\u01b0\u1edbc, v\u1eabn c\u00f2n ph\u1ea3i th\u1ef1c hi\u1ec7n th\u00eam m\u00e3, n\u00ean h\u1ec7 th\u1ed1ng ph\u1ea3i l\u01b0u ng\u1eef c\u1ea3nh c\u1ee7a l\u1ea7n g\u1ecdi tr\u01b0\u1edbc.</li> <li>Tail recursion: G\u1ecdi \u0111\u1ec7 quy l\u00e0 thao t\u00e1c cu\u1ed1i c\u00f9ng tr\u01b0\u1edbc khi tr\u1ea3 v\u1ec1. Khi tr\u1ea3 v\u1ec1 cho l\u1edbp tr\u01b0\u1edbc, kh\u00f4ng c\u1ea7n th\u1ef1c hi\u1ec7n th\u00eam g\u00ec, n\u00ean h\u1ec7 th\u1ed1ng kh\u00f4ng c\u1ea7n l\u01b0u ng\u1eef c\u1ea3nh c\u1ee7a l\u1edbp tr\u01b0\u1edbc.</li> </ul> <p>V\u00ed d\u1ee5, \u0111\u1ec3 t\u00ednh \\(1 + 2 + \\dots + n\\), ta c\u00f3 th\u1ec3 truy\u1ec1n bi\u1ebfn k\u1ebft qu\u1ea3 <code>res</code> l\u00e0m tham s\u1ed1 cho h\u00e0m, t\u1eeb \u0111\u00f3 \u0111\u1ea1t \u0111\u01b0\u1ee3c tail recursion:</p> <pre><code>[file]{recursion}-[class]{}-[func]{tail_recur}\n</code></pre> <p>Qu\u00e1 tr\u00ecnh th\u1ef1c hi\u1ec7n tail recursion \u0111\u01b0\u1ee3c minh h\u1ecda \u1edf h\u00ecnh d\u01b0\u1edbi. So s\u00e1nh gi\u1eefa regular recursion v\u00e0 tail recursion, \u0111i\u1ec3m th\u1ef1c hi\u1ec7n ph\u00e9p c\u1ed9ng l\u00e0 kh\u00e1c nhau.</p> <ul> <li>Regular recursion: Ph\u00e9p c\u1ed9ng th\u1ef1c hi\u1ec7n \u1edf giai \u0111o\u1ea1n \"tr\u1ea3 v\u1ec1\", m\u1ed7i l\u1edbp tr\u1ea3 v\u1ec1 l\u1ea1i ph\u1ea3i c\u1ed9ng th\u00eam m\u1ed9t l\u1ea7n n\u1eefa.</li> <li>Tail recursion: Ph\u00e9p c\u1ed9ng th\u1ef1c hi\u1ec7n \u1edf giai \u0111o\u1ea1n \"g\u1ecdi h\u00e0m\", c\u00f2n giai \u0111o\u1ea1n \"tr\u1ea3 v\u1ec1\" ch\u1ec9 \u0111\u01a1n gi\u1ea3n l\u00e0 tr\u1ea3 v\u1ec1 qua t\u1eebng l\u1edbp.</li> </ul> <p></p> <p>Tip</p> <p>L\u01b0u \u00fd r\u1eb1ng nhi\u1ec1u tr\u00ecnh bi\u00ean d\u1ecbch ho\u1eb7c th\u00f4ng d\u1ecbch kh\u00f4ng h\u1ed7 tr\u1ee3 t\u1ed1i \u01b0u h\u00f3a Tail recursion. V\u00ed d\u1ee5, Python kh\u00f4ng h\u1ed7 tr\u1ee3 t\u1ed1i \u01b0u h\u00f3a tail recursion m\u1eb7c \u0111\u1ecbnh, n\u00ean d\u00f9 h\u00e0m c\u00f3 d\u1ea1ng tail recursion v\u1eabn c\u00f3 th\u1ec3 g\u1eb7p l\u1ed7i tr\u00e0n ng\u0103n x\u1ebfp.</p>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#cay-e-quy","title":"C\u00e2y \u0111\u1ec7 quy","text":"<p>Khi gi\u1ea3i c\u00e1c thu\u1eadt to\u00e1n li\u00ean quan \u0111\u1ebfn \"chia \u0111\u1ec3 tr\u1ecb\", \u0111\u1ec7 quy th\u01b0\u1eddng mang l\u1ea1i c\u00e1ch ti\u1ebfp c\u1eadn tr\u1ef1c quan v\u00e0 m\u00e3 d\u1ec5 \u0111\u1ecdc h\u01a1n so v\u1edbi l\u1eb7p. L\u1ea5y v\u00ed d\u1ee5 \"d\u00e3y Fibonacci\":</p> <p>Question</p> <p>Cho d\u00e3y Fibonacci \\(0, 1, 1, 2, 3, 5, 8, 13, \\dots\\), h\u00e3y t\u00ecm s\u1ed1 th\u1ee9 \\(n\\) trong d\u00e3y.</p> <p>G\u1ecdi s\u1ed1 th\u1ee9 \\(n\\) c\u1ee7a d\u00e3y Fibonacci l\u00e0 \\(f(n)\\), ta d\u1ec5 d\u00e0ng r\u00fat ra hai k\u1ebft lu\u1eadn:</p> <ul> <li>Hai s\u1ed1 \u0111\u1ea7u ti\u00ean c\u1ee7a d\u00e3y l\u00e0 \\(f(1) = 0\\) v\u00e0 \\(f(2) = 1\\).</li> <li>M\u1ed7i s\u1ed1 trong d\u00e3y l\u00e0 t\u1ed5ng c\u1ee7a hai s\u1ed1 li\u1ec1n tr\u01b0\u1edbc, t\u1ee9c l\u00e0 \\(f(n) = f(n - 1) + f(n - 2)\\).</li> </ul> <p>D\u1ef1a v\u00e0o quan h\u1ec7 \u0111\u1ec7 quy v\u00e0 coi hai s\u1ed1 \u0111\u1ea7u l\u00e0 \u0111i\u1ec1u ki\u1ec7n d\u1eebng, ta c\u00f3 th\u1ec3 vi\u1ebft m\u00e3 \u0111\u1ec7 quy. G\u1ecdi <code>fib(n)</code> s\u1ebd tr\u1ea3 v\u1ec1 s\u1ed1 th\u1ee9 \\(n\\) c\u1ee7a d\u00e3y Fibonacci:</p> <pre><code>[file]{recursion}-[class]{}-[func]{fib}\n</code></pre> <p>Quan s\u00e1t \u0111o\u1ea1n m\u00e3 tr\u00ean, ta th\u1ea5y h\u00e0m t\u1ef1 g\u1ecdi l\u1ea1i hai l\u1ea7n trong ch\u00ednh n\u00f3, ngh\u0129a l\u00e0 m\u1ed9t l\u1ea7n g\u1ecdi t\u1ea1o ra hai nh\u00e1nh g\u1ecdi. Nh\u01b0 h\u00ecnh d\u01b0\u1edbi minh h\u1ecda, qu\u00e1 tr\u00ecnh g\u1ecdi \u0111\u1ec7 quy li\u00ean t\u1ee5c s\u1ebd t\u1ea1o ra m\u1ed9t c\u00e2y \u0111\u1ec7 quy c\u00f3 \u0111\u1ed9 s\u00e2u \\(n\\).</p> <p></p> <p>V\u1ec1 b\u1ea3n ch\u1ea5t, \u0111\u1ec7 quy th\u1ec3 hi\u1ec7n t\u01b0 duy \"chia nh\u1ecf b\u00e0i to\u00e1n th\u00e0nh c\u00e1c b\u00e0i to\u00e1n con\". Chi\u1ebfn l\u01b0\u1ee3c chia \u0111\u1ec3 tr\u1ecb n\u00e0y r\u1ea5t quan tr\u1ecdng.</p> <ul> <li>V\u1ec1 m\u1eb7t thu\u1eadt to\u00e1n, nhi\u1ec1u chi\u1ebfn l\u01b0\u1ee3c quan tr\u1ecdng nh\u01b0 t\u00ecm ki\u1ebfm, s\u1eafp x\u1ebfp, quay lui, chia \u0111\u1ec3 tr\u1ecb, l\u1eadp tr\u00ecnh \u0111\u1ed9ng \u0111\u1ec1u tr\u1ef1c ti\u1ebfp ho\u1eb7c gi\u00e1n ti\u1ebfp s\u1eed d\u1ee5ng t\u01b0 duy n\u00e0y.</li> <li>V\u1ec1 m\u1eb7t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u, \u0111\u1ec7 quy r\u1ea5t ph\u00f9 h\u1ee3p \u0111\u1ec3 x\u1eed l\u00fd danh s\u00e1ch li\u00ean k\u1ebft, c\u00e2y, \u0111\u1ed3 th\u1ecb, v\u00ec ch\u00fang d\u1ec5 ph\u00e2n t\u00edch b\u1eb1ng ph\u01b0\u01a1ng ph\u00e1p chia \u0111\u1ec3 tr\u1ecb.</li> </ul>"},{"location":"chapter_computational_complexity/iteration_and_recursion/#so-sanh","title":"So s\u00e1nh","text":"<p>T\u00f3m t\u1eaft l\u1ea1i, b\u1ea3ng sau \u0111\u00e2y cho th\u1ea5y s\u1ef1 kh\u00e1c bi\u1ec7t gi\u1eefa l\u1eb7p v\u00e0 \u0111\u1ec7 quy v\u1ec1 c\u00e1ch tri\u1ec3n khai, hi\u1ec7u n\u0103ng v\u00e0 t\u00ednh \u1ee9ng d\u1ee5ng.</p> <p> B\u1ea3ng: So s\u00e1nh \u0111\u1eb7c \u0111i\u1ec3m c\u1ee7a l\u1eb7p v\u00e0 \u0111\u1ec7 quy </p> L\u1eb7p \u0110\u1ec7 quy C\u00e1ch ti\u1ebfp c\u1eadn Loop structure Function calls n\u00f3 Hi\u1ec7u n\u0103ng th\u1eddi gian Th\u01b0\u1eddng hi\u1ec7u qu\u1ea3 h\u01a1n, kh\u00f4ng c\u00f3 chi ph\u00ed g\u1ecdi h\u00e0m M\u1ed7i l\u1ea7n g\u1ecdi h\u00e0m t\u1ea1o ra chi ph\u00ed S\u1eed d\u1ee5ng b\u1ed9 nh\u1edb Th\u01b0\u1eddng d\u00f9ng b\u1ed9 nh\u1edb c\u1ed1 \u0111\u1ecbnh C\u00e1c l\u1ea7n g\u1ecdi h\u00e0m t\u00edch l\u0169y c\u00f3 th\u1ec3 d\u00f9ng nhi\u1ec1u b\u1ed9 nh\u1edb ng\u0103n x\u1ebfp B\u00e0i to\u00e1n ph\u00f9 h\u1ee3p Ph\u00f9 h\u1ee3p v\u1edbi t\u00e1c v\u1ee5 l\u1eb7p \u0111\u01a1n gi\u1ea3n, m\u00e3 d\u1ec5 \u0111\u1ecdc Ph\u00f9 h\u1ee3p v\u1edbi b\u00e0i to\u00e1n chia nh\u1ecf, nh\u01b0 c\u00e2y, \u0111\u1ed3 th\u1ecb, chia \u0111\u1ec3 tr\u1ecb, quay lui, v.v., m\u00e3 ng\u1eafn g\u1ecdn v\u00e0 r\u00f5 r\u00e0ng <p>Tip</p> <p>N\u1ebfu b\u1ea1n th\u1ea5y ph\u1ea7n sau kh\u00f3 hi\u1ec3u, h\u00e3y quay l\u1ea1i \u0111\u1ecdc sau khi h\u1ecdc ch\u01b0\u01a1ng \"Ng\u0103n x\u1ebfp\".</p> <p>V\u1eady, m\u1ed1i li\u00ean h\u1ec7 n\u1ed9i t\u1ea1i gi\u1eefa l\u1eb7p v\u00e0 \u0111\u1ec7 quy l\u00e0 g\u00ec? L\u1ea5y v\u00ed d\u1ee5 h\u00e0m \u0111\u1ec7 quy \u1edf tr\u00ean, ph\u00e9p c\u1ed9ng th\u1ef1c hi\u1ec7n \u1edf giai \u0111o\u1ea1n \"tr\u1ea3 v\u1ec1\" c\u1ee7a \u0111\u1ec7 quy. \u0110i\u1ec1u n\u00e0y ngh\u0129a l\u00e0 h\u00e0m \u0111\u01b0\u1ee3c g\u1ecdi \u0111\u1ea7u ti\u00ean s\u1ebd l\u00e0 h\u00e0m cu\u1ed1i c\u00f9ng th\u1ef1c hi\u1ec7n ph\u00e9p c\u1ed9ng, gi\u1ed1ng v\u1edbi nguy\u00ean t\u1eafc \"v\u00e0o sau ra tr\u01b0\u1edbc\" c\u1ee7a ng\u0103n x\u1ebfp.</p> <p>C\u00e1c thu\u1eadt ng\u1eef nh\u01b0 \"ng\u0103n x\u1ebfp g\u1ecdi h\u00e0m\" v\u00e0 \"khung ng\u0103n x\u1ebfp\" cho th\u1ea5y m\u1ed1i li\u00ean h\u1ec7 ch\u1eb7t ch\u1ebd gi\u1eefa \u0111\u1ec7 quy v\u00e0 ng\u0103n x\u1ebfp.</p> <ol> <li>G\u1ecdi h\u00e0m: Khi m\u1ed9t h\u00e0m \u0111\u01b0\u1ee3c g\u1ecdi, h\u1ec7 th\u1ed1ng c\u1ea5p ph\u00e1t m\u1ed9t khung ng\u0103n x\u1ebfp m\u1edbi tr\u00ean \"ng\u0103n x\u1ebfp g\u1ecdi h\u00e0m\" cho h\u00e0m \u0111\u00f3, l\u01b0u bi\u1ebfn c\u1ee5c b\u1ed9, tham s\u1ed1, \u0111\u1ecba ch\u1ec9 tr\u1ea3 v\u1ec1 v\u00e0 d\u1eef li\u1ec7u kh\u00e1c.</li> <li>Tr\u1ea3 v\u1ec1: Khi h\u00e0m th\u1ef1c hi\u1ec7n xong v\u00e0 tr\u1ea3 v\u1ec1, khung ng\u0103n x\u1ebfp t\u01b0\u01a1ng \u1ee9ng s\u1ebd b\u1ecb lo\u1ea1i kh\u1ecfi \"ng\u0103n x\u1ebfp g\u1ecdi h\u00e0m\", kh\u00f4i ph\u1ee5c m\u00f4i tr\u01b0\u1eddng th\u1ef1c thi c\u1ee7a h\u00e0m tr\u01b0\u1edbc \u0111\u00f3.</li> </ol> <p>V\u00ec v\u1eady, ta c\u00f3 th\u1ec3 d\u00f9ng ng\u0103n x\u1ebfp t\u01b0\u1eddng minh \u0111\u1ec3 m\u00f4 ph\u1ecfng h\u00e0nh vi c\u1ee7a ng\u0103n x\u1ebfp g\u1ecdi h\u00e0m, t\u1eeb \u0111\u00f3 chuy\u1ec3n \u0111\u1ec7 quy th\u00e0nh d\u1ea1ng l\u1eb7p:</p> <pre><code>[file]{recursion}-[class]{}-[func]{for_loop_recur}\n</code></pre> <p>Quan s\u00e1t \u0111o\u1ea1n m\u00e3 tr\u00ean, khi chuy\u1ec3n \u0111\u1ec7 quy th\u00e0nh l\u1eb7p, m\u00e3 tr\u1edf n\u00ean ph\u1ee9c t\u1ea1p h\u01a1n. D\u00f9 l\u1eb7p v\u00e0 \u0111\u1ec7 quy th\u01b0\u1eddng c\u00f3 th\u1ec3 chuy\u1ec3n \u0111\u1ed5i qua l\u1ea1i, nh\u01b0ng kh\u00f4ng ph\u1ea3i l\u00fac n\u00e0o c\u0169ng n\u00ean l\u00e0m v\u1eady v\u00ec hai l\u00fd do:</p> <ul> <li>M\u00e3 chuy\u1ec3n \u0111\u1ed5i c\u00f3 th\u1ec3 kh\u00f3 hi\u1ec3u v\u00e0 k\u00e9m d\u1ec5 \u0111\u1ecdc h\u01a1n.</li> <li>V\u1edbi m\u1ed9t s\u1ed1 b\u00e0i to\u00e1n ph\u1ee9c t\u1ea1p, m\u00f4 ph\u1ecfng h\u00e0nh vi c\u1ee7a ng\u0103n x\u1ebfp h\u1ec7 th\u1ed1ng l\u00e0 r\u1ea5t kh\u00f3.</li> </ul> <p>T\u00f3m l\u1ea1i, vi\u1ec7c ch\u1ecdn l\u1eb7p hay \u0111\u1ec7 quy ph\u1ee5 thu\u1ed9c v\u00e0o b\u1ea3n ch\u1ea5t c\u1ee7a b\u00e0i to\u00e1n. Trong th\u1ef1c h\u00e0nh l\u1eadp tr\u00ecnh, c\u1ea7n c\u00e2n nh\u1eafc \u01b0u nh\u01b0\u1ee3c \u0111i\u1ec3m c\u1ee7a c\u1ea3 hai v\u00e0 ch\u1ecdn c\u00e1ch ti\u1ebfp c\u1eadn ph\u00f9 h\u1ee3p nh\u1ea5t v\u1edbi t\u00ecnh hu\u1ed1ng c\u1ee5 th\u1ec3.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/","title":"2.1 Algorithm efficiency assessment","text":""},{"location":"chapter_computational_complexity/performance_evaluation/#anh-gia-hieu-qua-thuat-toan","title":"\u0110\u00e1nh gi\u00e1 hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n","text":"<p>Khi thi\u1ebft k\u1ebf thu\u1eadt to\u00e1n, ch\u00fang ta theo \u0111u\u1ed5i hai m\u1ee5c ti\u00eau sau theo th\u1ee9 t\u1ef1.</p> <ol> <li>T\u00ecm ra gi\u1ea3i ph\u00e1p cho b\u00e0i to\u00e1n: Thu\u1eadt to\u00e1n c\u1ea7n \u0111\u1ea3m b\u1ea3o t\u00ecm \u0111\u01b0\u1ee3c l\u1eddi gi\u1ea3i \u0111\u00fang trong ph\u1ea1m vi \u0111\u1ea7u v\u00e0o \u0111\u00e3 cho.</li> <li>T\u00ecm ki\u1ebfm gi\u1ea3i ph\u00e1p t\u1ed1i \u01b0u: V\u1edbi c\u00f9ng m\u1ed9t b\u00e0i to\u00e1n, c\u00f3 th\u1ec3 c\u00f3 nhi\u1ec1u c\u00e1ch gi\u1ea3i kh\u00e1c nhau, v\u00e0 ch\u00fang ta h\u01b0\u1edbng t\u1edbi vi\u1ec7c t\u00ecm ra thu\u1eadt to\u00e1n hi\u1ec7u qu\u1ea3 nh\u1ea5t.</li> </ol> <p>N\u00f3i c\u00e1ch kh\u00e1c, khi \u0111\u00e3 c\u00f3 th\u1ec3 gi\u1ea3i quy\u1ebft \u0111\u01b0\u1ee3c b\u00e0i to\u00e1n, hi\u1ec7u qu\u1ea3 c\u1ee7a thu\u1eadt to\u00e1n tr\u1edf th\u00e0nh ti\u00eau ch\u00ed ch\u00ednh \u0111\u1ec3 \u0111\u00e1nh gi\u00e1, bao g\u1ed3m hai kh\u00eda c\u1ea1nh sau:</p> <ul> <li>Hi\u1ec7u qu\u1ea3 th\u1eddi gian: T\u1ed1c \u0111\u1ed9 th\u1ef1c thi c\u1ee7a thu\u1eadt to\u00e1n.</li> <li>Hi\u1ec7u qu\u1ea3 kh\u00f4ng gian: L\u01b0\u1ee3ng b\u1ed9 nh\u1edb m\u00e0 thu\u1eadt to\u00e1n s\u1eed d\u1ee5ng.</li> </ul> <p>T\u00f3m l\u1ea1i, m\u1ee5c ti\u00eau c\u1ee7a ch\u00fang ta l\u00e0 thi\u1ebft k\u1ebf c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n v\u1eeba nhanh v\u1eeba ti\u1ebft ki\u1ec7m b\u1ed9 nh\u1edb. \u0110\u00e1nh gi\u00e1 hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n l\u00e0 r\u1ea5t quan tr\u1ecdng, v\u00ec nh\u1edd \u0111\u00f3 ch\u00fang ta c\u00f3 th\u1ec3 so s\u00e1nh c\u00e1c thu\u1eadt to\u00e1n kh\u00e1c nhau v\u00e0 \u0111\u1ecbnh h\u01b0\u1edbng qu\u00e1 tr\u00ecnh thi\u1ebft k\u1ebf, t\u1ed1i \u01b0u thu\u1eadt to\u00e1n.</p> <p>C\u00f3 hai ph\u01b0\u01a1ng ph\u00e1p ch\u00ednh \u0111\u1ec3 \u0111\u00e1nh gi\u00e1 hi\u1ec7u qu\u1ea3: ki\u1ec3m th\u1eed th\u1ef1c t\u1ebf v\u00e0 \u01b0\u1edbc l\u01b0\u1ee3ng l\u00fd thuy\u1ebft.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/#kiem-thu-thuc-te","title":"Ki\u1ec3m th\u1eed th\u1ef1c t\u1ebf","text":"<p>Gi\u1ea3 s\u1eed ch\u00fang ta c\u00f3 hai thu\u1eadt to\u00e1n <code>A</code> v\u00e0 <code>B</code>, \u0111\u1ec1u gi\u1ea3i \u0111\u01b0\u1ee3c c\u00f9ng m\u1ed9t b\u00e0i to\u00e1n, v\u00e0 c\u1ea7n so s\u00e1nh hi\u1ec7u qu\u1ea3 c\u1ee7a ch\u00fang. C\u00e1ch tr\u1ef1c ti\u1ebfp nh\u1ea5t l\u00e0 ch\u1ea1y hai thu\u1eadt to\u00e1n n\u00e0y tr\u00ean m\u00e1y t\u00ednh, theo d\u00f5i v\u00e0 ghi l\u1ea1i th\u1eddi gian ch\u1ea1y c\u0169ng nh\u01b0 l\u01b0\u1ee3ng b\u1ed9 nh\u1edb s\u1eed d\u1ee5ng. Ph\u01b0\u01a1ng ph\u00e1p n\u00e0y ph\u1ea3n \u00e1nh th\u1ef1c t\u1ebf, nh\u01b0ng c\u00f3 nhi\u1ec1u h\u1ea1n ch\u1ebf.</p> <p>M\u1ed9t m\u1eb7t, r\u1ea5t kh\u00f3 lo\u1ea1i b\u1ecf \u1ea3nh h\u01b0\u1edfng t\u1eeb m\u00f4i tr\u01b0\u1eddng ki\u1ec3m th\u1eed. C\u1ea5u h\u00ecnh ph\u1ea7n c\u1ee9ng c\u00f3 th\u1ec3 \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn hi\u1ec7u n\u0103ng thu\u1eadt to\u00e1n. V\u00ed d\u1ee5, thu\u1eadt to\u00e1n c\u00f3 kh\u1ea3 n\u0103ng x\u1eed l\u00fd song song cao s\u1ebd ch\u1ea1y t\u1ed1t h\u01a1n tr\u00ean CPU \u0111a nh\u00e2n, c\u00f2n thu\u1eadt to\u00e1n thao t\u00e1c nhi\u1ec1u v\u1edbi b\u1ed9 nh\u1edb s\u1ebd ch\u1ea1y t\u1ed1t h\u01a1n v\u1edbi RAM hi\u1ec7u n\u0103ng cao. K\u1ebft qu\u1ea3 ki\u1ec3m th\u1eed c\u00f3 th\u1ec3 kh\u00e1c nhau tr\u00ean c\u00e1c m\u00e1y kh\u00e1c nhau. \u0110i\u1ec1u n\u00e0y khi\u1ebfn vi\u1ec7c ki\u1ec3m th\u1eed tr\u00ean nhi\u1ec1u m\u00e1y \u0111\u1ec3 t\u00ednh trung b\u00ecnh hi\u1ec7u qu\u1ea3 tr\u1edf n\u00ean kh\u00f4ng kh\u1ea3 thi.</p> <p>M\u1eb7t kh\u00e1c, ki\u1ec3m th\u1eed to\u00e0n di\u1ec7n r\u1ea5t t\u1ed1n t\u00e0i nguy\u00ean. Hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n thay \u0111\u1ed5i theo k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o. V\u00ed d\u1ee5, v\u1edbi d\u1eef li\u1ec7u nh\u1ecf, thu\u1eadt to\u00e1n <code>A</code> c\u00f3 th\u1ec3 ch\u1ea1y nhanh h\u01a1n <code>B</code>, nh\u01b0ng v\u1edbi d\u1eef li\u1ec7u l\u1edbn, k\u1ebft qu\u1ea3 c\u00f3 th\u1ec3 ng\u01b0\u1ee3c l\u1ea1i. V\u00ec v\u1eady, \u0111\u1ec3 c\u00f3 k\u1ebft lu\u1eadn thuy\u1ebft ph\u1ee5c, c\u1ea7n ki\u1ec3m th\u1eed v\u1edbi nhi\u1ec1u k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u, \u0111\u00f2i h\u1ecfi r\u1ea5t nhi\u1ec1u t\u00e0i nguy\u00ean t\u00ednh to\u00e1n.</p>"},{"location":"chapter_computational_complexity/performance_evaluation/#uoc-luong-ly-thuyet","title":"\u01af\u1edbc l\u01b0\u1ee3ng l\u00fd thuy\u1ebft","text":"<p>Do ki\u1ec3m th\u1eed th\u1ef1c t\u1ebf c\u00f3 nhi\u1ec1u h\u1ea1n ch\u1ebf, ch\u00fang ta c\u00f3 th\u1ec3 \u0111\u00e1nh gi\u00e1 hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n ch\u1ec9 b\u1eb1ng c\u00e1ch t\u00ednh to\u00e1n. Ph\u01b0\u01a1ng ph\u00e1p n\u00e0y g\u1ecdi l\u00e0 ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p ti\u1ec7m c\u1eadn, hay \u0111\u01a1n gi\u1ea3n l\u00e0 ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p.</p> <p>Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p ph\u1ea3n \u00e1nh m\u1ed1i quan h\u1ec7 gi\u1eefa t\u00e0i nguy\u00ean th\u1eddi gian v\u00e0 kh\u00f4ng gian c\u1ea7n thi\u1ebft \u0111\u1ec3 th\u1ef1c thi thu\u1eadt to\u00e1n v\u1edbi k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o. N\u00f3 m\u00f4 t\u1ea3 xu h\u01b0\u1edbng t\u0103ng l\u00ean c\u1ee7a th\u1eddi gian v\u00e0 b\u1ed9 nh\u1edb khi k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o t\u0103ng. \u0110\u1ecbnh ngh\u0129a n\u00e0y nghe c\u00f3 v\u1ebb ph\u1ee9c t\u1ea1p, nh\u01b0ng ch\u00fang ta c\u00f3 th\u1ec3 hi\u1ec3u qua ba \u0111i\u1ec3m ch\u00ednh sau:</p> <ul> <li>\"T\u00e0i nguy\u00ean th\u1eddi gian v\u00e0 kh\u00f4ng gian\" t\u01b0\u01a1ng \u1ee9ng v\u1edbi \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian v\u00e0 \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian.</li> <li>\"Khi k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o t\u0103ng\" ngh\u0129a l\u00e0 \u0111\u1ed9 ph\u1ee9c t\u1ea1p ph\u1ea3n \u00e1nh m\u1ed1i quan h\u1ec7 gi\u1eefa hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n v\u00e0 l\u01b0\u1ee3ng d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o.</li> <li>\"Xu h\u01b0\u1edbng t\u0103ng l\u00ean c\u1ee7a th\u1eddi gian v\u00e0 b\u1ed9 nh\u1edb\" ngh\u0129a l\u00e0 ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng t\u1eadp trung v\u00e0o gi\u00e1 tr\u1ecb c\u1ee5 th\u1ec3 c\u1ee7a th\u1eddi gian ch\u1ea1y hay b\u1ed9 nh\u1edb s\u1eed d\u1ee5ng, m\u00e0 ch\u00fa tr\u1ecdng v\u00e0o \"t\u1ed1c \u0111\u1ed9\" t\u0103ng l\u00ean c\u1ee7a ch\u00fang.</li> </ul> <p>Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u1eafc ph\u1ee5c \u0111\u01b0\u1ee3c nh\u01b0\u1ee3c \u0111i\u1ec3m c\u1ee7a ki\u1ec3m th\u1eed th\u1ef1c t\u1ebf, th\u1ec3 hi\u1ec7n \u1edf c\u00e1c \u0111i\u1ec3m sau:</p> <ul> <li>Kh\u00f4ng c\u1ea7n ch\u1ea1y m\u00e3 ngu\u1ed3n th\u1ef1c t\u1ebf, ti\u1ebft ki\u1ec7m n\u0103ng l\u01b0\u1ee3ng v\u00e0 th\u00e2n thi\u1ec7n v\u1edbi m\u00f4i tr\u01b0\u1eddng.</li> <li>Kh\u00f4ng ph\u1ee5 thu\u1ed9c v\u00e0o m\u00f4i tr\u01b0\u1eddng ki\u1ec3m th\u1eed, \u00e1p d\u1ee5ng \u0111\u01b0\u1ee3c tr\u00ean m\u1ecdi n\u1ec1n t\u1ea3ng.</li> <li>Ph\u1ea3n \u00e1nh hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n v\u1edbi c\u00e1c k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u kh\u00e1c nhau, \u0111\u1eb7c bi\u1ec7t l\u00e0 khi d\u1eef li\u1ec7u l\u1edbn.</li> </ul> <p>Tip</p> <p>N\u1ebfu b\u1ea1n v\u1eabn c\u00f2n b\u1ed1i r\u1ed1i v\u1ec1 kh\u00e1i ni\u1ec7m \u0111\u1ed9 ph\u1ee9c t\u1ea1p, \u0111\u1eebng lo l\u1eafng. Ch\u00fang ta s\u1ebd t\u00ecm hi\u1ec3u k\u1ef9 h\u01a1n \u1edf c\u00e1c ch\u01b0\u01a1ng sau.</p> <p>Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p cung c\u1ea5p cho ch\u00fang ta m\u1ed9t \"th\u01b0\u1edbc \u0111o\" \u0111\u1ec3 \u0111\u00e1nh gi\u00e1 hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n, gi\u00fap \u0111o l\u01b0\u1eddng t\u00e0i nguy\u00ean th\u1eddi gian v\u00e0 kh\u00f4ng gian c\u1ea7n thi\u1ebft \u0111\u1ec3 th\u1ef1c thi, v\u00e0 so s\u00e1nh hi\u1ec7u qu\u1ea3 gi\u1eefa c\u00e1c thu\u1eadt to\u00e1n kh\u00e1c nhau.</p> <p>\u0110\u1ed9 ph\u1ee9c t\u1ea1p l\u00e0 m\u1ed9t kh\u00e1i ni\u1ec7m to\u00e1n h\u1ecdc, c\u00f3 th\u1ec3 kh\u00e1 tr\u1eebu t\u01b0\u1ee3ng v\u00e0 kh\u00f3 hi\u1ec3u v\u1edbi ng\u01b0\u1eddi m\u1edbi b\u1eaft \u0111\u1ea7u. V\u00ec v\u1eady, ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p c\u00f3 th\u1ec3 ch\u01b0a ph\u1ea3i l\u00e0 ch\u1ee7 \u0111\u1ec1 ph\u00f9 h\u1ee3p \u0111\u1ec3 h\u1ecdc \u0111\u1ea7u ti\u00ean. Tuy nhi\u00ean, khi t\u00ecm hi\u1ec3u v\u1ec1 \u0111\u1eb7c \u0111i\u1ec3m c\u1ee7a m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u hay thu\u1eadt to\u00e1n c\u1ee5 th\u1ec3, ch\u00fang ta kh\u00f3 tr\u00e1nh kh\u1ecfi vi\u1ec7c ph\u00e2n t\u00edch t\u1ed1c \u0111\u1ed9 v\u00e0 b\u1ed9 nh\u1edb s\u1eed d\u1ee5ng c\u1ee7a n\u00f3.</p> <p>T\u00f3m l\u1ea1i, b\u1ea1n n\u00ean c\u00f3 hi\u1ec3u bi\u1ebft c\u01a1 b\u1ea3n v\u1ec1 ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p tr\u01b0\u1edbc khi \u0111i s\u00e2u v\u00e0o c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n, \u0111\u1ec3 c\u00f3 th\u1ec3 t\u1ef1 ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p c\u1ee7a c\u00e1c thu\u1eadt to\u00e1n \u0111\u01a1n gi\u1ea3n.</p>"},{"location":"chapter_computational_complexity/space_complexity/","title":"2.4 Space complexity","text":""},{"location":"chapter_computational_complexity/space_complexity/#space-complexity","title":"Space complexity","text":"<p>\u0110\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian \u0111\u01b0\u1ee3c d\u00f9ng \u0111\u1ec3 \u0111o xu h\u01b0\u1edbng t\u0103ng c\u1ee7a b\u1ed9 nh\u1edb chi\u1ebfm d\u1ee5ng b\u1edfi m\u1ed9t thu\u1eadt to\u00e1n khi l\u01b0\u1ee3ng d\u1eef li\u1ec7u t\u0103ng l\u00ean. Kh\u00e1i ni\u1ec7m n\u00e0y r\u1ea5t gi\u1ed1ng v\u1edbi \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian, ch\u1ec9 kh\u00e1c \u1edf ch\u1ed7 \"th\u1eddi gian ch\u1ea1y\" \u0111\u01b0\u1ee3c thay b\u1eb1ng \"kh\u00f4ng gian b\u1ed9 nh\u1edb chi\u1ebfm d\u1ee5ng\".</p>"},{"location":"chapter_computational_complexity/space_complexity/#space-related-to-algorithms","title":"Space related to algorithms","text":"<p>B\u1ed9 nh\u1edb m\u00e0 m\u1ed9t thu\u1eadt to\u00e1n s\u1eed d\u1ee5ng trong qu\u00e1 tr\u00ecnh th\u1ef1c hi\u1ec7n ch\u1ee7 y\u1ebfu bao g\u1ed3m c\u00e1c lo\u1ea1i sau.</p> <ul> <li>Kh\u00f4ng gian \u0111\u1ea7u v\u00e0o: D\u00f9ng \u0111\u1ec3 l\u01b0u d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o c\u1ee7a thu\u1eadt to\u00e1n.</li> <li>Kh\u00f4ng gian t\u1ea1m th\u1eddi: D\u00f9ng \u0111\u1ec3 l\u01b0u c\u00e1c bi\u1ebfn, \u0111\u1ed1i t\u01b0\u1ee3ng, ng\u1eef c\u1ea3nh h\u00e0m v\u00e0 c\u00e1c d\u1eef li\u1ec7u kh\u00e1c trong qu\u00e1 tr\u00ecnh ch\u1ea1y thu\u1eadt to\u00e1n.</li> <li>Kh\u00f4ng gian \u0111\u1ea7u ra: D\u00f9ng \u0111\u1ec3 l\u01b0u d\u1eef li\u1ec7u \u0111\u1ea7u ra c\u1ee7a thu\u1eadt to\u00e1n.</li> </ul> <p>Th\u00f4ng th\u01b0\u1eddng, ph\u1ea1m vi th\u1ed1ng k\u00ea \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian bao g\u1ed3m c\u1ea3 \"Kh\u00f4ng gian t\u1ea1m th\u1eddi\" v\u00e0 \"Kh\u00f4ng gian \u0111\u1ea7u ra\".</p> <p>Kh\u00f4ng gian t\u1ea1m th\u1eddi c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c chia nh\u1ecf h\u01a1n th\u00e0nh ba ph\u1ea7n.</p> <ul> <li>D\u1eef li\u1ec7u t\u1ea1m th\u1eddi: D\u00f9ng \u0111\u1ec3 l\u01b0u c\u00e1c h\u1eb1ng s\u1ed1, bi\u1ebfn, \u0111\u1ed1i t\u01b0\u1ee3ng, v.v. trong qu\u00e1 tr\u00ecnh th\u1ef1c thi thu\u1eadt to\u00e1n.</li> <li>Kh\u00f4ng gian khung ng\u0103n x\u1ebfp: D\u00f9ng \u0111\u1ec3 l\u01b0u d\u1eef li\u1ec7u ng\u1eef c\u1ea3nh c\u1ee7a h\u00e0m \u0111\u01b0\u1ee3c g\u1ecdi. H\u1ec7 th\u1ed1ng t\u1ea1o m\u1ed9t khung ng\u0103n x\u1ebfp \u1edf \u0111\u1ec9nh ng\u0103n x\u1ebfp m\u1ed7i khi m\u1ed9t h\u00e0m \u0111\u01b0\u1ee3c g\u1ecdi, v\u00e0 kh\u00f4ng gian khung ng\u0103n x\u1ebfp \u0111\u01b0\u1ee3c gi\u1ea3i ph\u00f3ng sau khi h\u00e0m tr\u1ea3 v\u1ec1.</li> <li>Kh\u00f4ng gian l\u1ec7nh: D\u00f9ng \u0111\u1ec3 l\u01b0u c\u00e1c l\u1ec7nh ch\u01b0\u01a1ng tr\u00ecnh \u0111\u00e3 bi\u00ean d\u1ecbch, th\u01b0\u1eddng c\u00f3 th\u1ec3 coi l\u00e0 kh\u00f4ng \u0111\u00e1ng k\u1ec3 khi th\u1ed1ng k\u00ea th\u1ef1c t\u1ebf.</li> </ul> <p>Khi ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian c\u1ee7a ch\u01b0\u01a1ng tr\u00ecnh, ch\u00fang ta th\u01b0\u1eddng t\u00ednh D\u1eef li\u1ec7u T\u1ea1m th\u1eddi, Kh\u00f4ng gian Khung Ng\u0103n x\u1ebfp v\u00e0 D\u1eef li\u1ec7u \u0110\u1ea7u ra, nh\u01b0 h\u00ecnh b\u00ean d\u01b0\u1edbi.</p> <p></p> <p>M\u00e3 li\u00ean quan nh\u01b0 sau:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>class Node:\n    \"\"\"L\u1edbp\"\"\"\n    def __init__(self, x: int):\n        self.val: int = x               # gi\u00e1 tr\u1ecb n\u00fat\n        self.next: Node | None = None   # tham chi\u1ebfu t\u1edbi n\u00fat ti\u1ebfp theo\n\ndef function() -&gt; int:\n    \"\"\"H\u00e0m\"\"\"\n    # Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c...\n    return 0\n\ndef algorithm(n) -&gt; int:    # d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    A = 0                   # d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng, th\u01b0\u1eddng vi\u1ebft hoa)\n    b = 0                   # d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    node = Node(0)          # d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n    c = function()          # kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return A + b + c        # d\u1eef li\u1ec7u \u0111\u1ea7u ra\n</code></pre> <pre><code>/* C\u1ea5u tr\u00fac */\nstruct Node {\n    int val;\n    Node *next;\n    Node(int x) : val(x), next(nullptr) {}\n};\n\n/* H\u00e0m */\nint func() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c...\n    return 0;\n}\n\nint algorithm(int n) {          // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    const int a = 0;            // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n    int b = 0;                  // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    Node* node = new Node(0);   // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n    int c = func();             // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return a + b + c;           // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>/* L\u1edbp */\nclass Node {\n    int val;\n    Node next;\n    Node(int x) { val = x; }\n}\n\n/* H\u00e0m */\nint function() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c...\n    return 0;\n}\n\nint algorithm(int n) {          // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    final int a = 0;            // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n    int b = 0;                  // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    Node node = new Node(0);    // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n    int c = function();         // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return a + b + c;           // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>/* L\u1edbp */\nclass Node {\n    int val;\n    Node next;\n    Node(int x) { val = x; }\n}\n\n/* H\u00e0m */\nint Function() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c...\n    return 0;\n}\n\nint Algorithm(int n) {  // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    const int a = 0;    // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n    int b = 0;          // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    Node node = new(0); // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n    int c = Function(); // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return a + b + c;   // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>/* C\u1ea5u tr\u00fac */\ntype node struct {\n    val  int\n    next *node\n}\n\n/* T\u1ea1o c\u1ea5u tr\u00fac node */\nfunc newNode(val int) *node {\n    return &amp;node{val: val}\n}\n\n/* H\u00e0m */\nfunc function() int {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c...\n    return 0\n}\n\nfunc algorithm(n int) int { // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    const a = 0             // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n    b := 0                  // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    newNode(0)              // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n    c := function()         // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return a + b + c        // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>/* L\u1edbp */\nclass Node {\n    var val: Int\n    var next: Node?\n\n    init(x: Int) {\n        val = x\n    }\n}\n\n/* H\u00e0m */\nfunc function() -&gt; Int {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c...\n    return 0\n}\n\nfunc algorithm(n: Int) -&gt; Int { // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    let a = 0                   // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n    var b = 0                   // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    let node = Node(x: 0)       // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n    let c = function()          // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return a + b + c            // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>/* L\u1edbp */\nclass Node {\n    val;\n    next;\n    constructor(val) {\n        this.val = val === undefined ? 0 : val; // gi\u00e1 tr\u1ecb n\u00fat\n        this.next = null;                       // tham chi\u1ebfu t\u1edbi n\u00fat ti\u1ebfp theo\n    }\n}\n\n/* H\u00e0m */\nfunction constFunc() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0;\n}\n\nfunction algorithm(n) {         // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    const a = 0;                // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n    let b = 0;                  // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    const node = new Node(0);   // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n    const c = constFunc();      // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return a + b + c;           // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>/* L\u1edbp */\nclass Node {\n    val: number;\n    next: Node | null;\n    constructor(val?: number) {\n        this.val = val === undefined ? 0 : val; // gi\u00e1 tr\u1ecb n\u00fat\n        this.next = null;                       // tham chi\u1ebfu t\u1edbi n\u00fat ti\u1ebfp theo\n    }\n}\n\n/* H\u00e0m */\nfunction constFunc(): number {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0;\n}\n\nfunction algorithm(n: number): number { // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    const a = 0;                        // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n    let b = 0;                          // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    const node = new Node(0);           // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n    const c = constFunc();              // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return a + b + c;                   // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>/* L\u1edbp */\nclass Node {\n  int val;\n  Node next;\n  Node(this.val, [this.next]);\n}\n\n/* H\u00e0m */\nint function() {\n  // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c...\n  return 0;\n}\n\nint algorithm(int n) {  // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n  const int a = 0;      // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n  int b = 0;            // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n  Node node = Node(0);  // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n  int c = function();   // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n  return a + b + c;     // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* C\u1ea5u tr\u00fac */\nstruct Node {\n    val: i32,\n    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,\n}\n\n/* Constructor */\nimpl Node {\n    fn new(val: i32) -&gt; Self {\n        Self { val: val, next: None }\n    }\n}\n\n/* H\u00e0m */\nfn function() -&gt; i32 {     \n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c...\n    return 0;\n}\n\nfn algorithm(n: i32) -&gt; i32 {   // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    const a: i32 = 0;           // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n    let mut b = 0;              // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    let node = Node::new(0);    // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (\u0111\u1ed1i t\u01b0\u1ee3ng)\n    let c = function();         // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return a + b + c;           // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>/* H\u00e0m */\nint func() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c...\n    return 0;\n}\n\nint algorithm(int n) {  // d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n    const int a = 0;    // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (h\u1eb1ng)\n    int b = 0;          // d\u1eef li\u1ec7u t\u1ea1m th\u1eddi (bi\u1ebfn)\n    int c = func();     // kh\u00f4ng gian khung ng\u0103n x\u1ebfp (g\u1ecdi h\u00e0m)\n    return a + b + c;   // d\u1eef li\u1ec7u \u0111\u1ea7u ra\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"chapter_computational_complexity/space_complexity/#calculation-method","title":"Calculation method","text":"<p>Ph\u01b0\u01a1ng ph\u00e1p t\u00ednh \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian t\u01b0\u01a1ng t\u1ef1 nh\u01b0 \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian, ch\u1ec9 kh\u00e1c \u1edf ch\u1ed7 \u0111\u1ed1i t\u01b0\u1ee3ng th\u1ed1ng k\u00ea chuy\u1ec3n t\u1eeb \"s\u1ed1 ph\u00e9p to\u00e1n\" sang \"k\u00edch th\u01b0\u1edbc kh\u00f4ng gian \u0111\u00e3 d\u00f9ng\".</p> <p>Tuy nhi\u00ean, kh\u00e1c v\u1edbi th\u1eddi gian, ch\u00fang ta th\u01b0\u1eddng ch\u1ec9 quan t\u00e2m \u0111\u1ebfn \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian trong tr\u01b0\u1eddng h\u1ee3p t\u1ec7 nh\u1ea5t. L\u00fd do l\u00e0 b\u1ed9 nh\u1edb l\u00e0 m\u1ed9t y\u00eau c\u1ea7u c\u1ee9ng, v\u00e0 ta ph\u1ea3i \u0111\u1ea3m b\u1ea3o r\u1eb1ng c\u00f3 \u0111\u1ee7 b\u1ed9 nh\u1edb \u0111\u01b0\u1ee3c c\u1ea5p cho m\u1ecdi d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o.</p> <p>Xem x\u00e9t \u0111o\u1ea1n m\u00e3 sau, thu\u1eadt ng\u1eef \"t\u1ec7 nh\u1ea5t\" trong \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian t\u1ec7 nh\u1ea5t c\u00f3 hai \u00fd ngh\u0129a.</p> <ol> <li>D\u1ef1a tr\u00ean d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o x\u1ea5u nh\u1ea5t: Khi \\(n &lt; 10\\), \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian l\u00e0 \\(O(1)\\); nh\u01b0ng khi \\(n &gt; 10\\), m\u1ea3ng <code>nums</code> \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o chi\u1ebfm kh\u00f4ng gian \\(O(n)\\), do \u0111\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian t\u1ec7 nh\u1ea5t l\u00e0 \\(O(n)\\).</li> <li>D\u1ef1a tr\u00ean \u0111\u1ec9nh s\u1eed d\u1ee5ng b\u1ed9 nh\u1edb trong qu\u00e1 tr\u00ecnh th\u1ef1c thi: V\u00ed d\u1ee5, tr\u01b0\u1edbc khi th\u1ef1c hi\u1ec7n d\u00f2ng cu\u1ed1i c\u00f9ng, ch\u01b0\u01a1ng tr\u00ecnh chi\u1ebfm \\(O(1)\\) kh\u00f4ng gian; khi kh\u1edfi t\u1ea1o m\u1ea3ng <code>nums</code>, ch\u01b0\u01a1ng tr\u00ecnh chi\u1ebfm \\(O(n)\\) kh\u00f4ng gian, n\u00ean \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian t\u1ec7 nh\u1ea5t l\u00e0 \\(O(n)\\).</li> </ol> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>def algorithm(n: int):\n    a = 0               # O(1)\n    b = [0] * 10000     # O(1)\n    if n &gt; 10:\n        nums = [0] * n  # O(n)\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;               // O(1)\n    vector&lt;int&gt; b(10000);    // O(1)\n    if (n &gt; 10)\n        vector&lt;int&gt; nums(n); // O(n)\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;                   // O(1)\n    int[] b = new int[10000];    // O(1)\n    if (n &gt; 10)\n        int[] nums = new int[n]; // O(n)\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 0;                   // O(1)\n    int[] b = new int[10000];    // O(1)\n    if (n &gt; 10) {\n        int[] nums = new int[n]; // O(n)\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 0                      // O(1)\n    b := make([]int, 10000)     // O(1)\n    var nums []int\n    if n &gt; 10 {\n        nums := make([]int, n)  // O(n)\n    }\n    fmt.Println(a, b, nums)\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    let a = 0 // O(1)\n    let b = Array(repeating: 0, count: 10000) // O(1)\n    if n &gt; 10 {\n        let nums = Array(repeating: 0, count: n) // O(n)\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n &gt; 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void {\n    const a = 0;                   // O(1)\n    const b = new Array(10000);    // O(1)\n    if (n &gt; 10) {\n        const nums = new Array(n); // O(n)\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 0;                            // O(1)\n  List&lt;int&gt; b = List.filled(10000, 0);  // O(1)\n  if (n &gt; 10) {\n    List&lt;int&gt; nums = List.filled(n, 0); // O(n)\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let a = 0;                           // O(1)\n    let b = [0; 10000];                  // O(1)\n    if n &gt; 10 {\n        let nums = vec![0; n as usize];  // O(n)\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 0;               // O(1)\n    int b[10000];            // O(1)\n    if (n &gt; 10)\n        int nums[n] = {0};   // O(n)\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>Trong c\u00e1c h\u00e0m \u0111\u1ec7 quy, c\u1ea7n ph\u1ea3i t\u00ednh c\u1ea3 kh\u00f4ng gian khung ng\u0103n x\u1ebfp. Xem \u0111o\u1ea1n m\u00e3 sau:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>def function() -&gt; int:\n    # Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0\n\ndef loop(n: int):\n    \"\"\"V\u00f2ng l\u1eb7p O(1)\"\"\"\n    for _ in range(n):\n        function()\n\ndef recur(n: int):\n    \"\"\"\u0110\u1ec7 quy O(n)\"\"\"\n    if n == 1:\n        return\n    return recur(n - 1)\n</code></pre> <pre><code>int func() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0;\n}\n/* V\u00f2ng l\u1eb7p O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n/* \u0110\u1ec7 quy O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    recur(n - 1);\n}\n</code></pre> <pre><code>int function() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0;\n}\n/* V\u00f2ng l\u1eb7p O(1) */\nvoid loop(n) {\n    for (int i = 0; i &lt; n; i++) {\n        function();\n    }\n}\n/* \u0110\u1ec7 quy O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    recur(n - 1);\n}\n</code></pre> <pre><code>int Function() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0;\n}\n/* V\u00f2ng l\u1eb7p O(1) */\nvoid Loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        Function();\n    }\n}\n/* \u0110\u1ec7 quy O(n) */\nint Recur(int n) {\n    if (n == 1) return 1;\n    return Recur(n - 1);\n}\n</code></pre> <pre><code>func function() int {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0\n}\n\n/* V\u00f2ng l\u1eb7p O(1) */\nfunc loop(n int) {\n    for i := 0; i &lt; n; i++ {\n        function()\n    }\n}\n\n/* \u0110\u1ec7 quy O(n) */\nfunc recur(n int) {\n    if n == 1 {\n        return\n    }\n    recur(n - 1)\n}\n</code></pre> <pre><code>@discardableResult\nfunc function() -&gt; Int {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0\n}\n\n/* V\u00f2ng l\u1eb7p O(1) */\nfunc loop(n: Int) {\n    for _ in 0 ..&lt; n {\n        function()\n    }\n}\n\n/* \u0110\u1ec7 quy O(n) */\nfunc recur(n: Int) {\n    if n == 1 {\n        return\n    }\n    recur(n: n - 1)\n}\n</code></pre> <pre><code>function constFunc() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0;\n}\n/* V\u00f2ng l\u1eb7p O(1) */\nfunction loop(n) {\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n/* \u0110\u1ec7 quy O(n) */\nfunction recur(n) {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>function constFunc(): number {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0;\n}\n/* V\u00f2ng l\u1eb7p O(1) */\nfunction loop(n: number): void {\n    for (let i = 0; i &lt; n; i++) {\n        constFunc();\n    }\n}\n/* \u0110\u1ec7 quy O(n) */\nfunction recur(n: number): void {\n    if (n === 1) return;\n    return recur(n - 1);\n}\n</code></pre> <pre><code>int function() {\n  // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n  return 0;\n}\n/* V\u00f2ng l\u1eb7p O(1) */\nvoid loop(int n) {\n  for (int i = 0; i &lt; n; i++) {\n    function();\n  }\n}\n/* \u0110\u1ec7 quy O(n) */\nvoid recur(int n) {\n  if (n == 1) return;\n  recur(n - 1);\n}\n</code></pre> <pre><code>fn function() -&gt; i32 {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0;\n}\n/* V\u00f2ng l\u1eb7p O(1) */\nfn loop(n: i32) {\n    for i in 0..n {\n        function();\n    }\n}\n/* \u0110\u1ec7 quy O(n) */\nvoid recur(n: i32) {\n    if n == 1 {\n        return;\n    }\n    recur(n - 1);\n}\n</code></pre> <pre><code>int func() {\n    // Th\u1ef1c hi\u1ec7n m\u1ed9t s\u1ed1 thao t\u00e1c\n    return 0;\n}\n/* V\u00f2ng l\u1eb7p O(1) */\nvoid loop(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        func();\n    }\n}\n/* \u0110\u1ec7 quy O(n) */\nvoid recur(int n) {\n    if (n == 1) return;\n    recur(n - 1);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a c\u1ea3 hai h\u00e0m <code>loop()</code> v\u00e0 <code>recur()</code> \u0111\u1ec1u l\u00e0 \\(O(n)\\), nh\u01b0ng \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian c\u1ee7a ch\u00fang kh\u00e1c nhau.</p> <ul> <li>H\u00e0m <code>loop()</code> g\u1ecdi <code>function()</code> \\(n\\) l\u1ea7n trong m\u1ed9t v\u00f2ng l\u1eb7p, m\u1ed7i l\u1ea7n g\u1ecdi <code>function()</code> tr\u1ea3 v\u1ec1 v\u00e0 gi\u1ea3i ph\u00f3ng kh\u00f4ng gian khung ng\u0103n x\u1ebfp, n\u00ean \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian v\u1eabn l\u00e0 \\(O(1)\\).</li> <li>H\u00e0m \u0111\u1ec7 quy <code>recur()</code> s\u1ebd c\u00f3 \\(n\\) th\u1ec3 hi\u1ec7n c\u1ee7a <code>recur()</code> ch\u01b0a tr\u1ea3 v\u1ec1 t\u1ed3n t\u1ea1i \u0111\u1ed3ng th\u1eddi trong qu\u00e1 tr\u00ecnh th\u1ef1c thi, do \u0111\u00f3 chi\u1ebfm kh\u00f4ng gian khung ng\u0103n x\u1ebfp \\(O(n)\\).</li> </ul>"},{"location":"chapter_computational_complexity/space_complexity/#common-types","title":"Common types","text":"<p>G\u1ecdi k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o l\u00e0 \\(n\\), h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y hi\u1ec3n th\u1ecb c\u00e1c lo\u1ea1i \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian ph\u1ed5 bi\u1ebfn (s\u1eafp x\u1ebfp t\u1eeb th\u1ea5p \u0111\u1ebfn cao).</p> \\[ \\begin{aligned} &amp; O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n^2) &lt; O(2^n) \\newline &amp; \\text{H\u1eb1ng} &lt; \\text{Logarit} &lt; \\text{Tuy\u1ebfn t\u00ednh} &lt; \\text{B\u1eadc hai} &lt; \\text{S\u1ed1 m\u0169} \\end{aligned} \\] <p></p>"},{"location":"chapter_computational_complexity/space_complexity/#constant-order-o1","title":"Constant order \\(O(1)\\)","text":"<p>B\u1eadc h\u1eb1ng th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n \u1edf c\u00e1c h\u1eb1ng, bi\u1ebfn, \u0111\u1ed1i t\u01b0\u1ee3ng m\u00e0 k\u00edch th\u01b0\u1edbc kh\u00f4ng ph\u1ee5 thu\u1ed9c v\u00e0o d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o \\(n\\).</p> <p>L\u01b0u \u00fd r\u1eb1ng b\u1ed9 nh\u1edb chi\u1ebfm d\u1ee5ng khi kh\u1edfi t\u1ea1o bi\u1ebfn ho\u1eb7c g\u1ecdi h\u00e0m trong m\u1ed9t v\u00f2ng l\u1eb7p, m\u00e0 \u0111\u01b0\u1ee3c gi\u1ea3i ph\u00f3ng khi sang v\u00f2ng l\u1eb7p ti\u1ebfp theo, s\u1ebd kh\u00f4ng t\u00edch l\u0169y theo kh\u00f4ng gian, do \u0111\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p v\u1eabn l\u00e0 \\(O(1)\\):</p> <pre><code>[file]{space_complexity}-[class]{}-[func]{constant}\n</code></pre>"},{"location":"chapter_computational_complexity/space_complexity/#linear-order-on","title":"Linear order \\(O(n)\\)","text":"<p>B\u1eadc tuy\u1ebfn t\u00ednh th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n trong m\u1ea3ng, danh s\u00e1ch li\u00ean k\u1ebft, ng\u0103n x\u1ebfp, h\u00e0ng \u0111\u1ee3i, v.v., n\u01a1i s\u1ed1 ph\u1ea7n t\u1eed t\u1ec9 l\u1ec7 v\u1edbi \\(n\\):</p> <pre><code>[file]{space_complexity}-[class]{}-[func]{linear}\n</code></pre> <p>Nh\u01b0 h\u00ecnh b\u00ean d\u01b0\u1edbi, \u0111\u1ed9 s\u00e2u \u0111\u1ec7 quy c\u1ee7a h\u00e0m n\u00e0y l\u00e0 \\(n\\), t\u1ee9c l\u00e0 c\u00f3 \\(n\\) th\u1ec3 hi\u1ec7n c\u1ee7a h\u00e0m <code>linear_recur()</code> ch\u01b0a tr\u1ea3 v\u1ec1, s\u1eed d\u1ee5ng kh\u00f4ng gian khung ng\u0103n x\u1ebfp \\(O(n)\\):</p> <pre><code>[file]{space_complexity}-[class]{}-[func]{linear_recur}\n</code></pre> <p></p>"},{"location":"chapter_computational_complexity/space_complexity/#quadratic-order-on2","title":"Quadratic order \\(O(n^2)\\)","text":"<p>B\u1eadc b\u1eadc hai th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n trong ma tr\u1eadn v\u00e0 \u0111\u1ed3 th\u1ecb, n\u01a1i s\u1ed1 ph\u1ea7n t\u1eed t\u1ec9 l\u1ec7 v\u1edbi b\u00ecnh ph\u01b0\u01a1ng c\u1ee7a \\(n\\):</p> <pre><code>[file]{space_complexity}-[class]{}-[func]{quadratic}\n</code></pre> <p>Nh\u01b0 h\u00ecnh b\u00ean d\u01b0\u1edbi, \u0111\u1ed9 s\u00e2u \u0111\u1ec7 quy c\u1ee7a h\u00e0m n\u00e0y l\u00e0 \\(n\\), v\u00e0 trong m\u1ed7i l\u1ea7n g\u1ecdi \u0111\u1ec7 quy, m\u1ed9t m\u1ea3ng \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o v\u1edbi \u0111\u1ed9 d\u00e0i l\u1ea7n l\u01b0\u1ee3t l\u00e0 \\(n\\), \\(n-1\\), \\(\\dots\\), \\(2\\), \\(1\\), trung b\u00ecnh l\u00e0 \\(n/2\\), do \u0111\u00f3 t\u1ed5ng th\u1ec3 chi\u1ebfm kh\u00f4ng gian \\(O(n^2)\\):</p> <pre><code>[file]{space_complexity}-[class]{}-[func]{quadratic_recur}\n</code></pre> <p></p>"},{"location":"chapter_computational_complexity/space_complexity/#exponential-order-o2n","title":"Exponential order \\(O(2^n)\\)","text":"<p>B\u1eadc s\u1ed1 m\u0169 th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n trong c\u00e2y nh\u1ecb ph\u00e2n. Quan s\u00e1t h\u00ecnh d\u01b0\u1edbi, m\u1ed9t \"c\u00e2y nh\u1ecb ph\u00e2n \u0111\u1ea7y\" c\u00f3 \\(n\\) m\u1ee9c c\u00f3 \\(2^n - 1\\) n\u00fat, chi\u1ebfm kh\u00f4ng gian \\(O(2^n)\\):</p> <pre><code>[file]{space_complexity}-[class]{}-[func]{build_tree}\n</code></pre> <p></p>"},{"location":"chapter_computational_complexity/space_complexity/#logarithmic-order-olog-n","title":"Logarithmic order \\(O(\\log n)\\)","text":"<p>B\u1eadc logarit th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n trong c\u00e1c thu\u1eadt to\u00e1n chia \u0111\u1ec3 tr\u1ecb. V\u00ed d\u1ee5, trong s\u1eafp x\u1ebfp tr\u1ed9n (merge sort), m\u1ed9t m\u1ea3ng \u0111\u1ed9 d\u00e0i \\(n\\) \u0111\u01b0\u1ee3c chia \u0111\u00f4i \u0111\u1ec7 quy m\u1ed7i l\u1ea7n, t\u1ea1o th\u00e0nh m\u1ed9t c\u00e2y \u0111\u1ec7 quy c\u00f3 chi\u1ec1u cao \\(\\log n\\), s\u1eed d\u1ee5ng kh\u00f4ng gian khung ng\u0103n x\u1ebfp \\(O(\\log n)\\).</p> <p>M\u1ed9t v\u00ed d\u1ee5 kh\u00e1c l\u00e0 chuy\u1ec3n m\u1ed9t s\u1ed1 sang chu\u1ed7i. Cho m\u1ed9t s\u1ed1 nguy\u00ean d\u01b0\u01a1ng \\(n\\), s\u1ed1 ch\u1eef s\u1ed1 c\u1ee7a n\u00f3 l\u00e0 \\(\\log_{10} n + 1\\), t\u01b0\u01a1ng \u1ee9ng v\u1edbi \u0111\u1ed9 d\u00e0i c\u1ee7a chu\u1ed7i, do \u0111\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian l\u00e0 \\(O(\\log_{10} n + 1) = O(\\log n)\\).</p>"},{"location":"chapter_computational_complexity/space_complexity/#balancing-time-and-space","title":"Balancing time and space","text":"<p>L\u00fd t\u01b0\u1edfng l\u00e0 ch\u00fang ta mu\u1ed1n c\u1ea3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian v\u00e0 kh\u00f4ng gian \u0111\u1ec1u t\u1ed1i \u01b0u. Tuy nhi\u00ean, trong th\u1ef1c t\u1ebf, t\u1ed1i \u01b0u c\u1ea3 hai c\u00f9ng l\u00fac th\u01b0\u1eddng kh\u00f3.</p> <p>Gi\u1ea3m \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian th\u01b0\u1eddng \u0111i k\u00e8m v\u1edbi vi\u1ec7c t\u0103ng \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian, v\u00e0 ng\u01b0\u1ee3c l\u1ea1i. C\u00e1ch s\u1eed d\u1ee5ng b\u1ed9 nh\u1edb nhi\u1ec1u h\u01a1n \u0111\u1ec3 c\u1ea3i thi\u1ec7n t\u1ed1c \u0111\u1ed9 thu\u1eadt to\u00e1n \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 \"\u0111\u1ed5i kh\u00f4ng gian l\u1ea5y th\u1eddi gian\" (space-time tradeoff); chi\u1ec1u ng\u01b0\u1ee3c l\u1ea1i g\u1ecdi l\u00e0 \"\u0111\u1ed5i th\u1eddi gian l\u1ea5y kh\u00f4ng gian\" (time-space tradeoff).</p> <p>L\u1ef1a ch\u1ecdn ph\u1ee5 thu\u1ed9c v\u00e0o kh\u00eda c\u1ea1nh n\u00e0o ch\u00fang ta quan t\u00e2m h\u01a1n. Trong h\u1ea7u h\u1ebft tr\u01b0\u1eddng h\u1ee3p, th\u1eddi gian quan tr\u1ecdng h\u01a1n kh\u00f4ng gian, n\u00ean \"\u0111\u1ed5i kh\u00f4ng gian l\u1ea5y th\u1eddi gian\" th\u01b0\u1eddng l\u00e0 chi\u1ebfn l\u01b0\u1ee3c ph\u1ed5 bi\u1ebfn h\u01a1n. T\u1ea5t nhi\u00ean, khi x\u1eed l\u00fd kh\u1ed1i l\u01b0\u1ee3ng d\u1eef li\u1ec7u l\u1edbn, ki\u1ec3m so\u00e1t \u0111\u1ed9 ph\u1ee9c t\u1ea1p kh\u00f4ng gian c\u0169ng r\u1ea5t quan tr\u1ecdng.</p>"},{"location":"chapter_computational_complexity/summary/","title":"2.5 Summary","text":""},{"location":"chapter_computational_complexity/summary/#tom-tat","title":"T\u00f3m t\u1eaft","text":""},{"location":"chapter_computational_complexity/summary/#on-tap-chinh","title":"\u00d4n t\u1eadp ch\u00ednh","text":"<p>\u0110\u00e1nh gi\u00e1 hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n</p> <ul> <li>Hi\u1ec7u qu\u1ea3 v\u1ec1 th\u1eddi gian v\u00e0 hi\u1ec7u qu\u1ea3 v\u1ec1 b\u1ed9 nh\u1edb l\u00e0 hai ti\u00eau ch\u00ed ch\u00ednh \u0111\u1ec3 \u0111\u00e1nh gi\u00e1 ch\u1ea5t l\u01b0\u1ee3ng c\u1ee7a m\u1ed9t thu\u1eadt to\u00e1n.</li> <li>Ta c\u00f3 th\u1ec3 \u0111\u00e1nh gi\u00e1 hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n b\u1eb1ng c\u00e1ch ki\u1ec3m th\u1eed th\u1ef1c t\u1ebf, nh\u01b0ng kh\u00f3 lo\u1ea1i b\u1ecf \u1ea3nh h\u01b0\u1edfng c\u1ee7a m\u00f4i tr\u01b0\u1eddng ki\u1ec3m th\u1eed v\u00e0 t\u1ed1n nhi\u1ec1u t\u00e0i nguy\u00ean t\u00ednh to\u00e1n.</li> <li>Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p gi\u00fap kh\u1eafc ph\u1ee5c nh\u01b0\u1ee3c \u0111i\u1ec3m c\u1ee7a ki\u1ec3m th\u1eed th\u1ef1c t\u1ebf. K\u1ebft qu\u1ea3 ph\u00e2n t\u00edch \u00e1p d\u1ee5ng cho m\u1ecdi n\u1ec1n t\u1ea3ng v\u00e0 cho th\u1ea5y hi\u1ec7u qu\u1ea3 c\u1ee7a thu\u1eadt to\u00e1n \u1edf c\u00e1c quy m\u00f4 d\u1eef li\u1ec7u kh\u00e1c nhau.</li> </ul> <p>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian</p> <ul> <li>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian \u0111o xu h\u01b0\u1edbng th\u1eddi gian ch\u1ea1y c\u1ee7a thu\u1eadt to\u00e1n khi kh\u1ed1i l\u01b0\u1ee3ng d\u1eef li\u1ec7u t\u0103ng l\u00ean, gi\u00fap \u0111\u00e1nh gi\u00e1 hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n. Tuy nhi\u00ean, n\u00f3 c\u00f3 th\u1ec3 kh\u00f4ng ch\u00ednh x\u00e1c trong m\u1ed9t s\u1ed1 tr\u01b0\u1eddng h\u1ee3p, v\u00ed d\u1ee5 khi d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o nh\u1ecf ho\u1eb7c khi c\u00e1c thu\u1eadt to\u00e1n c\u00f3 c\u00f9ng \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian, khi\u1ebfn vi\u1ec7c so s\u00e1nh hi\u1ec7u qu\u1ea3 tr\u1edf n\u00ean kh\u00f3 kh\u0103n.</li> <li>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian tr\u01b0\u1eddng h\u1ee3p x\u1ea5u nh\u1ea5t \u0111\u01b0\u1ee3c k\u00fd hi\u1ec7u b\u1eb1ng big-\\(O\\), bi\u1ec3u th\u1ecb gi\u1edbi h\u1ea1n tr\u00ean ti\u1ec7m c\u1eadn, ph\u1ea3n \u00e1nh m\u1ee9c t\u0103ng s\u1ed1 ph\u00e9p to\u00e1n \\(T(n)\\) khi \\(n\\) ti\u1ebfn t\u1edbi v\u00f4 c\u00f9ng.</li> <li>\u0110\u1ec3 t\u00ednh \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian, ta th\u1ef1c hi\u1ec7n hai b\u01b0\u1edbc: \u0111\u1ebfm s\u1ed1 ph\u00e9p to\u00e1n, sau \u0111\u00f3 x\u00e1c \u0111\u1ecbnh gi\u1edbi h\u1ea1n tr\u00ean ti\u1ec7m c\u1eadn.</li> <li>C\u00e1c \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian ph\u1ed5 bi\u1ebfn, s\u1eafp x\u1ebfp t\u1eeb th\u1ea5p \u0111\u1ebfn cao, g\u1ed3m \\(O(1)\\), \\(O(\\log n)\\), \\(O(n)\\), \\(O(n \\log n)\\), \\(O(n^2)\\), \\(O(2^n)\\) v\u00e0 \\(O(n!)\\), v.v.</li> <li>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a m\u1ed9t s\u1ed1 thu\u1eadt to\u00e1n kh\u00f4ng c\u1ed1 \u0111\u1ecbnh, ph\u1ee5 thu\u1ed9c v\u00e0o ph\u00e2n b\u1ed1 d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o. \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian \u0111\u01b0\u1ee3c chia th\u00e0nh tr\u01b0\u1eddng h\u1ee3p x\u1ea5u nh\u1ea5t, t\u1ed1t nh\u1ea5t v\u00e0 trung b\u00ecnh. Tr\u01b0\u1eddng h\u1ee3p t\u1ed1t nh\u1ea5t \u00edt \u0111\u01b0\u1ee3c d\u00f9ng v\u00ec d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o th\u01b0\u1eddng ph\u1ea3i \u0111\u00e1p \u1ee9ng \u0111i\u1ec1u ki\u1ec7n r\u1ea5t \u0111\u1eb7c bi\u1ec7t.</li> <li>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian trung b\u00ecnh ph\u1ea3n \u00e1nh hi\u1ec7u qu\u1ea3 c\u1ee7a thu\u1eadt to\u00e1n khi d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o ng\u1eabu nhi\u00ean, g\u1ea7n gi\u1ed1ng v\u1edbi hi\u1ec7u su\u1ea5t th\u1ef1c t\u1ebf. \u0110\u1ec3 t\u00ednh \u0111\u1ed9 ph\u1ee9c t\u1ea1p trung b\u00ecnh, c\u1ea7n x\u00e9t \u0111\u1ebfn ph\u00e2n b\u1ed1 d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o v\u00e0 k\u1ef3 v\u1ecdng to\u00e1n h\u1ecdc.</li> </ul> <p>\u0110\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb</p> <ul> <li>\u0110\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb, gi\u1ed1ng nh\u01b0 \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian, \u0111o xu h\u01b0\u1edbng b\u1ed9 nh\u1edb m\u00e0 thu\u1eadt to\u00e1n s\u1eed d\u1ee5ng khi kh\u1ed1i l\u01b0\u1ee3ng d\u1eef li\u1ec7u t\u0103ng l\u00ean.</li> <li>B\u1ed9 nh\u1edb s\u1eed d\u1ee5ng khi thu\u1eadt to\u00e1n ch\u1ea1y g\u1ed3m b\u1ed9 nh\u1edb \u0111\u1ea7u v\u00e0o, b\u1ed9 nh\u1edb t\u1ea1m th\u1eddi v\u00e0 b\u1ed9 nh\u1edb \u0111\u1ea7u ra. Th\u00f4ng th\u01b0\u1eddng, b\u1ed9 nh\u1edb \u0111\u1ea7u v\u00e0o kh\u00f4ng t\u00ednh v\u00e0o \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb. B\u1ed9 nh\u1edb t\u1ea1m th\u1eddi g\u1ed3m d\u1eef li\u1ec7u t\u1ea1m, b\u1ed9 nh\u1edb khung ng\u0103n x\u1ebfp v\u00e0 b\u1ed9 nh\u1edb l\u1ec7nh; trong \u0111\u00f3 b\u1ed9 nh\u1edb khung ng\u0103n x\u1ebfp th\u01b0\u1eddng ch\u1ec9 \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb trong h\u00e0m \u0111\u1ec7 quy.</li> <li>Ta th\u01b0\u1eddng ch\u1ec9 quan t\u00e2m \u0111\u1ebfn \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb tr\u01b0\u1eddng h\u1ee3p x\u1ea5u nh\u1ea5t, t\u1ee9c l\u00e0 t\u00ednh \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb c\u1ee7a thu\u1eadt to\u00e1n v\u1edbi d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o x\u1ea5u nh\u1ea5t v\u00e0 t\u1ea1i th\u1eddi \u0111i\u1ec3m s\u1eed d\u1ee5ng b\u1ed9 nh\u1edb nhi\u1ec1u nh\u1ea5t.</li> <li>C\u00e1c \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb ph\u1ed5 bi\u1ebfn, s\u1eafp x\u1ebfp t\u1eeb th\u1ea5p \u0111\u1ebfn cao, g\u1ed3m \\(O(1)\\), \\(O(\\log n)\\), \\(O(n)\\), \\(O(n^2)\\) v\u00e0 \\(O(2^n)\\), v.v.</li> </ul>"},{"location":"chapter_computational_complexity/summary/#hoi-ap","title":"H\u1ecfi &amp; \u0110\u00e1p","text":"<p>H\u1ecfi: \u0110\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb c\u1ee7a \u0111\u1ec7 quy \u0111u\u00f4i c\u00f3 ph\u1ea3i l\u00e0 \\(O(1)\\) kh\u00f4ng?</p> <p>V\u1ec1 l\u00fd thuy\u1ebft, \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb c\u1ee7a h\u00e0m \u0111\u1ec7 quy \u0111u\u00f4i c\u00f3 th\u1ec3 t\u1ed1i \u01b0u v\u1ec1 \\(O(1)\\). Tuy nhi\u00ean, h\u1ea7u h\u1ebft c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh (nh\u01b0 Java, Python, C++, Go, C#) kh\u00f4ng t\u1ef1 \u0111\u1ed9ng t\u1ed1i \u01b0u \u0111\u1ec7 quy \u0111u\u00f4i, n\u00ean th\u01b0\u1eddng \u0111\u01b0\u1ee3c coi l\u00e0 c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb \\(O(n)\\).</p> <p>H\u1ecfi: S\u1ef1 kh\u00e1c bi\u1ec7t gi\u1eefa \"h\u00e0m\" v\u00e0 \"ph\u01b0\u01a1ng th\u1ee9c\" l\u00e0 g\u00ec?</p> <p>H\u00e0m c\u00f3 th\u1ec3 th\u1ef1c thi \u0111\u1ed9c l\u1eadp, v\u1edbi t\u1ea5t c\u1ea3 tham s\u1ed1 \u0111\u01b0\u1ee3c truy\u1ec1n r\u00f5 r\u00e0ng. Ph\u01b0\u01a1ng th\u1ee9c g\u1eafn v\u1edbi m\u1ed9t \u0111\u1ed1i t\u01b0\u1ee3ng v\u00e0 \u0111\u01b0\u1ee3c truy\u1ec1n ng\u1ea7m \u0111\u1ed1i t\u01b0\u1ee3ng g\u1ecdi n\u00f3, c\u00f3 th\u1ec3 thao t\u00e1c tr\u00ean d\u1eef li\u1ec7u c\u1ee7a m\u1ed9t \u0111\u1ed1i t\u01b0\u1ee3ng thu\u1ed9c l\u1edbp.</p> <p>M\u1ed9t s\u1ed1 v\u00ed d\u1ee5 t\u1eeb c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh ph\u1ed5 bi\u1ebfn:</p> <ul> <li>C l\u00e0 ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh th\u1ee7 t\u1ee5c, kh\u00f4ng c\u00f3 kh\u00e1i ni\u1ec7m h\u01b0\u1edbng \u0111\u1ed1i t\u01b0\u1ee3ng, n\u00ean ch\u1ec9 c\u00f3 h\u00e0m. Tuy nhi\u00ean, ta c\u00f3 th\u1ec3 m\u00f4 ph\u1ecfng l\u1eadp tr\u00ecnh h\u01b0\u1edbng \u0111\u1ed1i t\u01b0\u1ee3ng b\u1eb1ng c\u00e1ch t\u1ea1o c\u1ea5u tr\u00fac (struct), v\u00e0 c\u00e1c h\u00e0m li\u00ean k\u1ebft v\u1edbi c\u1ea5u tr\u00fac n\u00e0y t\u01b0\u01a1ng \u0111\u01b0\u01a1ng v\u1edbi ph\u01b0\u01a1ng th\u1ee9c \u1edf c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c.</li> <li>Java v\u00e0 C# l\u00e0 ng\u00f4n ng\u1eef h\u01b0\u1edbng \u0111\u1ed1i t\u01b0\u1ee3ng, n\u01a1i c\u00e1c kh\u1ed1i m\u00e3 (ph\u01b0\u01a1ng th\u1ee9c) th\u01b0\u1eddng n\u1eb1m trong l\u1edbp. Ph\u01b0\u01a1ng th\u1ee9c t\u0129nh ho\u1ea1t \u0111\u1ed9ng gi\u1ed1ng nh\u01b0 h\u00e0m v\u00ec n\u00f3 g\u1eafn v\u1edbi l\u1edbp v\u00e0 kh\u00f4ng truy c\u1eadp \u0111\u01b0\u1ee3c bi\u1ebfn c\u1ee7a \u0111\u1ed1i t\u01b0\u1ee3ng c\u1ee5 th\u1ec3.</li> <li>C++ v\u00e0 Python h\u1ed7 tr\u1ee3 c\u1ea3 l\u1eadp tr\u00ecnh th\u1ee7 t\u1ee5c (h\u00e0m) v\u00e0 l\u1eadp tr\u00ecnh h\u01b0\u1edbng \u0111\u1ed1i t\u01b0\u1ee3ng (ph\u01b0\u01a1ng th\u1ee9c).</li> </ul> <p>H\u1ecfi: H\u00ecnh \"C\u00e1c lo\u1ea1i \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb ph\u1ed5 bi\u1ebfn\" c\u00f3 ph\u1ea3n \u00e1nh k\u00edch th\u01b0\u1edbc b\u1ed9 nh\u1edb tuy\u1ec7t \u0111\u1ed1i kh\u00f4ng?</p> <p>Kh\u00f4ng, h\u00ecnh ch\u1ec9 th\u1ec3 hi\u1ec7n \u0111\u1ed9 ph\u1ee9c t\u1ea1p b\u1ed9 nh\u1edb, t\u1ee9c l\u00e0 xu h\u01b0\u1edbng t\u0103ng tr\u01b0\u1edfng, ch\u1ee9 kh\u00f4ng ph\u1ea3i k\u00edch th\u01b0\u1edbc b\u1ed9 nh\u1edb tuy\u1ec7t \u0111\u1ed1i.</p> <p>N\u1ebfu b\u1ea1n l\u1ea5y \\(n = 8\\), c\u00f3 th\u1ec3 th\u1ea5y gi\u00e1 tr\u1ecb c\u1ee7a m\u1ed7i \u0111\u01b0\u1eddng cong kh\u00f4ng kh\u1edbp v\u1edbi h\u00e0m c\u1ee7a n\u00f3. \u0110\u00f3 l\u00e0 v\u00ec m\u1ed7i \u0111\u01b0\u1eddng cong \u0111\u1ec1u c\u00f3 m\u1ed9t h\u1eb1ng s\u1ed1, nh\u1eb1m n\u00e9n ph\u1ea1m vi gi\u00e1 tr\u1ecb l\u1ea1i cho d\u1ec5 nh\u00ecn.</p> <p>Trong th\u1ef1c t\u1ebf, v\u00ec ta th\u01b0\u1eddng kh\u00f4ng bi\u1ebft \"h\u1eb1ng s\u1ed1\" \u0111\u1ed9 ph\u1ee9c t\u1ea1p c\u1ee7a t\u1eebng ph\u01b0\u01a1ng ph\u00e1p, n\u00ean kh\u00f4ng th\u1ec3 ch\u1ecdn gi\u1ea3i ph\u00e1p t\u1ed1t nh\u1ea5t cho \\(n = 8\\) ch\u1ec9 d\u1ef1a v\u00e0o \u0111\u1ed9 ph\u1ee9c t\u1ea1p. Tuy nhi\u00ean, v\u1edbi \\(n = 8^5\\), vi\u1ec7c l\u1ef1a ch\u1ecdn s\u1ebd d\u1ec5 h\u01a1n nhi\u1ec1u v\u00ec xu h\u01b0\u1edbng t\u0103ng tr\u01b0\u1edfng s\u1ebd chi\u1ebfm \u01b0u th\u1ebf.</p>"},{"location":"chapter_computational_complexity/time_complexity/","title":"2.3 Time complexity","text":""},{"location":"chapter_computational_complexity/time_complexity/#o-phuc-tap-thoi-gian","title":"\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian","text":"<p>Th\u1eddi gian ch\u1ea1y (runtime) c\u00f3 th\u1ec3 tr\u1ef1c quan \u0111\u00e1nh gi\u00e1 hi\u1ec7u su\u1ea5t c\u1ee7a m\u1ed9t thu\u1eadt to\u00e1n. L\u00e0m th\u1ebf n\u00e0o \u0111\u1ec3 ch\u00fang ta \u01b0\u1edbc l\u01b0\u1ee3ng ch\u00ednh x\u00e1c th\u1eddi gian ch\u1ea1y c\u1ee7a m\u1ed9t \u0111o\u1ea1n thu\u1eadt to\u00e1n?</p> <ol> <li>X\u00e1c \u0111\u1ecbnh n\u1ec1n t\u1ea3ng ch\u1ea1y: Bao g\u1ed3m c\u1ea5u h\u00ecnh ph\u1ea7n c\u1ee9ng, ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh, m\u00f4i tr\u01b0\u1eddng h\u1ec7 th\u1ed1ng, v.v., t\u1ea5t c\u1ea3 \u0111\u1ec1u c\u00f3 th\u1ec3 \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn hi\u1ec7u su\u1ea5t th\u1ef1c thi m\u00e3.</li> <li>\u0110\u00e1nh gi\u00e1 th\u1eddi gian ch\u1ea1y cho t\u1eebng ph\u00e9p to\u00e1n t\u00ednh to\u00e1n: V\u00ed d\u1ee5, ph\u00e9p c\u1ed9ng <code>+</code> c\u00f3 th\u1ec3 m\u1ea5t 1 ns, ph\u00e9p nh\u00e2n <code>*</code> c\u00f3 th\u1ec3 m\u1ea5t 10 ns, thao t\u00e1c in <code>print()</code> c\u00f3 th\u1ec3 m\u1ea5t 5 ns, v.v.</li> <li>\u0110\u1ebfm t\u1ea5t c\u1ea3 c\u00e1c ph\u00e9p to\u00e1n t\u00ednh to\u00e1n trong m\u00e3: C\u1ed9ng th\u1eddi gian th\u1ef1c thi c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c ph\u00e9p to\u00e1n n\u00e0y s\u1ebd cho t\u1ed5ng th\u1eddi gian ch\u1ea1y.</li> </ol> <p>V\u00ed d\u1ee5, x\u00e9t \u0111o\u1ea1n m\u00e3 sau v\u1edbi k\u00edch th\u01b0\u1edbc \u0111\u1ea7u v\u00e0o l\u00e0 \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code># D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y\ndef algorithm(n: int):\n    a = 2      # 1 ns\n    a = a + 1  # 1 ns\n    a = a * 2  # 10 ns\n    # L\u1eb7p n l\u1ea7n\n    for _ in range(n):  # 1 ns\n        print(0)        # 5 ns\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // V\u00f2ng l\u1eb7p l\u1eb7p n l\u1ea7n\n    for (int i = 0; i &lt; n; i++) {  // 1 ns , m\u1ed7i l\u1ea7n v\u00f2ng i++ \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n\n        cout &lt;&lt; 0 &lt;&lt; endl;         // 5 ns\n    }\n}\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // V\u00f2ng l\u1eb7p l\u1eb7p n l\u1ea7n\n    for (int i = 0; i &lt; n; i++) {  // 1 ns , m\u1ed7i l\u1ea7n v\u00f2ng i++ \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n\n        System.out.println(0);     // 5 ns\n    }\n}\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nvoid Algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // V\u00f2ng l\u1eb7p l\u1eb7p n l\u1ea7n\n    for (int i = 0; i &lt; n; i++) {  // 1 ns , m\u1ed7i l\u1ea7n v\u00f2ng i++ \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n\n        Console.WriteLine(0);      // 5 ns\n    }\n}\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nfunc algorithm(n int) {\n    a := 2     // 1 ns\n    a = a + 1  // 1 ns\n    a = a * 2  // 10 ns\n    // L\u1eb7p n l\u1ea7n\n    for i := 0; i &lt; n; i++ {  // 1 ns\n        fmt.Println(a)        // 5 ns\n    }\n}\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nfunc algorithm(n: Int) {\n    var a = 2 // 1 ns\n    a = a + 1 // 1 ns\n    a = a * 2 // 10 ns\n    // L\u1eb7p n l\u1ea7n\n    for _ in 0 ..&lt; n { // 1 ns\n        print(0) // 5 ns\n    }\n}\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nfunction algorithm(n) {\n    var a = 2; // 1 ns\n    a = a + 1; // 1 ns\n    a = a * 2; // 10 ns\n    // L\u1eb7p n l\u1ea7n\n    for(let i = 0; i &lt; n; i++) { // 1 ns , m\u1ed7i l\u1ea7n v\u00f2ng i++ \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n\n        console.log(0); // 5 ns\n    }\n}\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nfunction algorithm(n: number): void {\n    var a: number = 2; // 1 ns\n    a = a + 1; // 1 ns\n    a = a * 2; // 10 ns\n    // L\u1eb7p n l\u1ea7n\n    for(let i = 0; i &lt; n; i++) { // 1 ns , m\u1ed7i l\u1ea7n v\u00f2ng i++ \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n\n        console.log(0); // 5 ns\n    }\n}\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nvoid algorithm(int n) {\n  int a = 2; // 1 ns\n  a = a + 1; // 1 ns\n  a = a * 2; // 10 ns\n  // L\u1eb7p n l\u1ea7n\n  for (int i = 0; i &lt; n; i++) { // 1 ns , m\u1ed7i l\u1ea7n v\u00f2ng i++ \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n\n    print(0); // 5 ns\n  }\n}\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nfn algorithm(n: i32) {\n    let mut a = 2;      // 1 ns\n    a = a + 1;          // 1 ns\n    a = a * 2;          // 10 ns\n    // L\u1eb7p n l\u1ea7n\n    for _ in 0..n {     // 1 ns cho m\u1ed7i l\u1ea7n i++\n        println!(\"{}\", 0);  // 5 ns\n    }\n}\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nvoid algorithm(int n) {\n    int a = 2;  // 1 ns\n    a = a + 1;  // 1 ns\n    a = a * 2;  // 10 ns\n    // L\u1eb7p n l\u1ea7n\n    for (int i = 0; i &lt; n; i++) {   // 1 ns , m\u1ed7i l\u1ea7n v\u00f2ng i++ \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n\n        printf(\"%d\", 0);            // 5 ns\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// D\u01b0\u1edbi m\u1ed9t n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3\nfn algorithm(n: usize) void {\n    var a: i32 = 2; // 1 ns\n    a += 1; // 1 ns\n    a *= 2; // 10 ns\n    // L\u1eb7p n l\u1ea7n\n    for (0..n) |_| { // 1 ns\n        std.debug.print(\"{}\\n\", .{0}); // 5 ns\n    }\n}\n</code></pre> <p>S\u1eed d\u1ee5ng ph\u01b0\u01a1ng ph\u00e1p tr\u00ean, th\u1eddi gian ch\u1ea1y c\u1ee7a thu\u1eadt to\u00e1n c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c t\u00ednh l\u00e0 \\((6n + 12)\\) ns:</p> \\[ 1 + 1 + 10 + (1 + 5) \\times n = 6n + 12 \\] <p>Tuy nhi\u00ean, trong th\u1ef1c t\u1ebf, vi\u1ec7c \u0111\u1ebfm th\u1eddi gian ch\u1ea1y c\u1ee7a m\u1ed9t thu\u1eadt to\u00e1n l\u00e0 kh\u00f4ng th\u1ef1c t\u1ebf v\u00e0 kh\u00f4ng h\u1ee3p l\u00fd. Th\u1ee9 nh\u1ea5t, ch\u00fang ta kh\u00f4ng mu\u1ed1n g\u00e1n th\u1eddi gian \u01b0\u1edbc l\u01b0\u1ee3ng cho n\u1ec1n t\u1ea3ng ch\u1ea1y c\u1ee5 th\u1ec3, v\u00ec thu\u1eadt to\u00e1n c\u1ea7n ch\u1ea1y tr\u00ean nhi\u1ec1u n\u1ec1n t\u1ea3ng kh\u00e1c nhau. Th\u1ee9 hai, r\u1ea5t kh\u00f3 \u0111\u1ec3 bi\u1ebft th\u1eddi gian ch\u1ea1y ch\u00ednh x\u00e1c cho t\u1eebng lo\u1ea1i ph\u00e9p to\u00e1n, l\u00e0m cho qu\u00e1 tr\u00ecnh \u01b0\u1edbc l\u01b0\u1ee3ng tr\u1edf n\u00ean kh\u00f3 kh\u0103n.</p>"},{"location":"chapter_computational_complexity/time_complexity/#anh-gia-xu-huong-tang-truong-thoi-gian","title":"\u0110\u00e1nh gi\u00e1 xu h\u01b0\u1edbng t\u0103ng tr\u01b0\u1edfng th\u1eddi gian","text":"<p>Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian kh\u00f4ng ph\u1ea3i l\u00e0 \u0111\u1ebfm th\u1eddi gian ch\u1ea1y, m\u00e0 l\u00e0 xu h\u01b0\u1edbng t\u0103ng tr\u01b0\u1edfng c\u1ee7a th\u1eddi gian ch\u1ea1y khi kh\u1ed1i l\u01b0\u1ee3ng d\u1eef li\u1ec7u t\u0103ng l\u00ean.</p> <p>H\u00e3y hi\u1ec3u kh\u00e1i ni\u1ec7m \"xu h\u01b0\u1edbng t\u0103ng tr\u01b0\u1edfng th\u1eddi gian\" b\u1eb1ng v\u00ed d\u1ee5. Gi\u1ea3 s\u1eed k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o l\u00e0 \\(n\\), v\u00e0 x\u00e9t ba thu\u1eadt to\u00e1n <code>A</code>, <code>B</code>, v\u00e0 <code>C</code>:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code># \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\ndef algorithm_A(n: int):\n    print(0)\n# \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\ndef algorithm_B(n: int):\n    for _ in range(n):\n        print(0)\n# \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\ndef algorithm_C(n: int):\n    for _ in range(1000000):\n        print(0)\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nvoid algorithm_A(int n) {\n    cout &lt;&lt; 0 &lt;&lt; endl;\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n}\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nvoid algorithm_A(int n) {\n    System.out.println(0);\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        System.out.println(0);\n    }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        System.out.println(0);\n    }\n}\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nvoid AlgorithmA(int n) {\n    Console.WriteLine(0);\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nvoid AlgorithmB(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        Console.WriteLine(0);\n    }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nvoid AlgorithmC(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        Console.WriteLine(0);\n    }\n}\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nfunc algorithm_A(n int) {\n    fmt.Println(0)\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nfunc algorithm_B(n int) {\n    for i := 0; i &lt; n; i++ {\n        fmt.Println(0)\n    }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nfunc algorithm_C(n int) {\n    for i := 0; i &lt; 1000000; i++ {\n        fmt.Println(0)\n    }\n}\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nfunc algorithmA(n: Int) {\n    print(0)\n}\n\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nfunc algorithmB(n: Int) {\n    for _ in 0 ..&lt; n {\n        print(0)\n    }\n}\n\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nfunc algorithmC(n: Int) {\n    for _ in 0 ..&lt; 1_000_000 {\n        print(0)\n    }\n}\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nfunction algorithm_A(n) {\n    console.log(0);\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nfunction algorithm_B(n) {\n    for (let i = 0; i &lt; n; i++) {\n        console.log(0);\n    }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nfunction algorithm_C(n) {\n    for (let i = 0; i &lt; 1000000; i++) {\n        console.log(0);\n    }\n}\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nfunction algorithm_A(n: number): void {\n    console.log(0);\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nfunction algorithm_B(n: number): void {\n    for (let i = 0; i &lt; n; i++) {\n        console.log(0);\n    }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nfunction algorithm_C(n: number): void {\n    for (let i = 0; i &lt; 1000000; i++) {\n        console.log(0);\n    }\n}\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nvoid algorithmA(int n) {\n  print(0);\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nvoid algorithmB(int n) {\n  for (int i = 0; i &lt; n; i++) {\n    print(0);\n  }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nvoid algorithmC(int n) {\n  for (int i = 0; i &lt; 1000000; i++) {\n    print(0);\n  }\n}\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nfn algorithm_A(n: i32) {\n    println!(\"{}\", 0);\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nfn algorithm_B(n: i32) {\n    for _ in 0..n {\n        println!(\"{}\", 0);\n    }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nfn algorithm_C(n: i32) {\n    for _ in 0..1000000 {\n        println!(\"{}\", 0);\n    }\n}\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nvoid algorithm_A(int n) {\n    printf(\"%d\", 0);\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nvoid algorithm_B(int n) {\n    for (int i = 0; i &lt; n; i++) {\n        printf(\"%d\", 0);\n    }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nvoid algorithm_C(int n) {\n    for (int i = 0; i &lt; 1000000; i++) {\n        printf(\"%d\", 0);\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n A: h\u1eb1ng s\u1ed1\nfn algorithm_A(n: usize) void {\n    _ = n;\n    std.debug.print(\"{}\\n\", .{0});\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n B: b\u1eadc tuy\u1ebfn t\u00ednh\nfn algorithm_B(n: i32) void {\n    for (0..n) |_| {\n        std.debug.print(\"{}\\n\", .{0});\n    }\n}\n// \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a thu\u1eadt to\u00e1n C: h\u1eb1ng s\u1ed1\nfn algorithm_C(n: i32) void {\n    _ = n;\n    for (0..1000000) |_| {\n        std.debug.print(\"{}\\n\", .{0});\n    }\n}\n</code></pre> <p>H\u00ecnh b\u00ean d\u01b0\u1edbi th\u1ec3 hi\u1ec7n \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a ba thu\u1eadt to\u00e1n n\u00e0y.</p> <ul> <li>Thu\u1eadt to\u00e1n <code>A</code> ch\u1ec9 c\u00f3 m\u1ed9t thao t\u00e1c in, v\u00e0 th\u1eddi gian ch\u1ea1y c\u1ee7a n\u00f3 kh\u00f4ng t\u0103ng theo \\(n\\). \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian \u0111\u01b0\u1ee3c coi l\u00e0 \"h\u1eb1ng s\u1ed1\".</li> <li>Thu\u1eadt to\u00e1n <code>B</code> th\u1ef1c hi\u1ec7n thao t\u00e1c in l\u1eb7p \\(n\\) l\u1ea7n, th\u1eddi gian ch\u1ea1y t\u0103ng tuy\u1ebfn t\u00ednh theo \\(n\\). \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian l\u00e0 \"b\u1eadc tuy\u1ebfn t\u00ednh\".</li> <li>Thu\u1eadt to\u00e1n <code>C</code> l\u1eb7p in 1.000.000 l\u1ea7n. M\u1eb7c d\u00f9 t\u1ed1n nhi\u1ec1u th\u1eddi gian th\u1ef1c thi, nh\u01b0ng n\u00f3 \u0111\u1ed9c l\u1eadp v\u1edbi k\u00edch th\u01b0\u1edbc \u0111\u1ea7u v\u00e0o \\(n\\). V\u00ec v\u1eady, \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a <code>C</code> gi\u1ed1ng <code>A</code>, \u0111\u1ec1u l\u00e0 \"h\u1eb1ng s\u1ed1\".</li> </ul> <p></p> <p>So v\u1edbi vi\u1ec7c \u0111\u1ebfm tr\u1ef1c ti\u1ebfp th\u1eddi gian ch\u1ea1y c\u1ee7a thu\u1eadt to\u00e1n, ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u00f3 nh\u1eefng \u0111\u1eb7c \u0111i\u1ec3m g\u00ec?</p> <ul> <li>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian \u0111\u00e1nh gi\u00e1 hi\u1ec7u qu\u1ea3 thu\u1eadt to\u00e1n m\u1ed9t c\u00e1ch hi\u1ec7u qu\u1ea3. V\u00ed d\u1ee5, thu\u1eadt to\u00e1n <code>B</code> c\u00f3 th\u1eddi gian ch\u1ea1y t\u0103ng tuy\u1ebfn t\u00ednh, ch\u1eadm h\u01a1n thu\u1eadt to\u00e1n <code>A</code> khi \\(n &gt; 1\\) v\u00e0 ch\u1eadm h\u01a1n <code>C</code> khi \\(n &gt; 1{,}000{,}000\\). Th\u1ef1c t\u1ebf, khi k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o \\(n\\) \u0111\u1ee7 l\u1edbn, thu\u1eadt to\u00e1n c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p \"h\u1eb1ng s\u1ed1\" lu\u00f4n t\u1ed1t h\u01a1n thu\u1eadt to\u00e1n \"tuy\u1ebfn t\u00ednh\", \u0111\u00e2y l\u00e0 b\u1ea3n ch\u1ea5t c\u1ee7a xu h\u01b0\u1edbng t\u0103ng tr\u01b0\u1edfng th\u1eddi gian.</li> <li>Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian \u0111\u01a1n gi\u1ea3n h\u01a1n. R\u00f5 r\u00e0ng, n\u1ec1n t\u1ea3ng ch\u1ea1y v\u00e0 lo\u1ea1i ph\u00e9p to\u00e1n t\u00ednh to\u00e1n kh\u00f4ng \u1ea3nh h\u01b0\u1edfng t\u1edbi xu h\u01b0\u1edbng t\u0103ng tr\u01b0\u1edfng th\u1eddi gian. V\u00ec v\u1eady, khi ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian, ta c\u00f3 th\u1ec3 coi th\u1eddi gian th\u1ef1c thi c\u1ee7a m\u1ecdi ph\u00e9p to\u00e1n \u0111\u1ec1u l\u00e0 c\u00f9ng m\u1ed9t \"\u0111\u01a1n v\u1ecb th\u1eddi gian\", \u0111\u01a1n gi\u1ea3n h\u00f3a vi\u1ec7c \"\u0111\u1ebfm th\u1eddi gian th\u1ef1c thi c\u1ee7a ph\u00e9p to\u00e1n\" th\u00e0nh \"\u0111\u1ebfm s\u1ed1 ph\u00e9p to\u00e1n\". \u0110i\u1ec1u n\u00e0y gi\u1ea3m \u0111\u00e1ng k\u1ec3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p khi \u01b0\u1edbc l\u01b0\u1ee3ng.</li> <li>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u00f3 gi\u1edbi h\u1ea1n c\u1ee7a n\u00f3. V\u00ed d\u1ee5, m\u1eb7c d\u00f9 <code>A</code> v\u00e0 <code>C</code> c\u00f3 c\u00f9ng \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian, th\u1eddi gian ch\u1ea1y th\u1ef1c t\u1ebf c\u1ee7a ch\u00fang c\u00f3 th\u1ec3 r\u1ea5t kh\u00e1c nhau. T\u01b0\u01a1ng t\u1ef1, m\u1eb7c d\u00f9 <code>B</code> c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p cao h\u01a1n <code>C</code>, nh\u01b0ng khi \\(n\\) nh\u1ecf th\u00ec <code>B</code> c\u00f3 th\u1ec3 t\u1ed1t h\u01a1n. Trong nh\u1eefng tr\u01b0\u1eddng h\u1ee3p n\u00e0y, kh\u00f3 \u0111\u00e1nh gi\u00e1 hi\u1ec7u su\u1ea5t ch\u1ec9 d\u1ef1a tr\u00ean \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian. Tuy nhi\u00ean, m\u1eb7c d\u00f9 c\u00f3 nh\u1eefng v\u1ea5n \u0111\u1ec1 \u0111\u00f3, ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p v\u1eabn l\u00e0 ph\u01b0\u01a1ng ph\u00e1p hi\u1ec7u qu\u1ea3 v\u00e0 ph\u1ed5 bi\u1ebfn nh\u1ea5t \u0111\u1ec3 \u0111\u00e1nh gi\u00e1 hi\u1ec7u su\u1ea5t thu\u1eadt to\u00e1n.</li> </ul>"},{"location":"chapter_computational_complexity/time_complexity/#can-tren-tiem-can","title":"C\u1eadn tr\u00ean ti\u1ec7m c\u1eadn","text":"<p>X\u00e9t m\u1ed9t h\u00e0m v\u1edbi k\u00edch th\u01b0\u1edbc \u0111\u1ea7u v\u00e0o \\(n\\):</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>def algorithm(n: int):\n    a = 1      # +1\n    a = a + 1  # +1\n    a = a * 2  # +1\n    # L\u1eb7p n l\u1ea7n\n    for i in range(n):  # +1\n        print(0)        # +1\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // V\u00f2ng l\u1eb7p l\u1eb7p n l\u1ea7n\n    for (int i = 0; i &lt; n; i++) { // +1 (m\u1ed7i l\u1ea7n th\u1ef1c hi\u1ec7n i ++)\n        cout &lt;&lt; 0 &lt;&lt; endl;    // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // V\u00f2ng l\u1eb7p l\u1eb7p n l\u1ea7n\n    for (int i = 0; i &lt; n; i++) { // +1 (m\u1ed7i l\u1ea7n th\u1ef1c hi\u1ec7n i ++)\n        System.out.println(0);    // +1\n    }\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // V\u00f2ng l\u1eb7p l\u1eb7p n l\u1ea7n\n    for (int i = 0; i &lt; n; i++) {   // +1 (m\u1ed7i l\u1ea7n th\u1ef1c hi\u1ec7n i ++)\n        Console.WriteLine(0);   // +1\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 1      // +1\n    a = a + 1   // +1\n    a = a * 2   // +1\n    // L\u1eb7p n l\u1ea7n\n    for i := 0; i &lt; n; i++ {   // +1\n        fmt.Println(a)         // +1\n    }\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    var a = 1 // +1\n    a = a + 1 // +1\n    a = a * 2 // +1\n    // L\u1eb7p n l\u1ea7n\n    for _ in 0 ..&lt; n { // +1\n        print(0) // +1\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    var a = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // L\u1eb7p n l\u1ea7n\n    for(let i = 0; i &lt; n; i++){ // +1 (m\u1ed7i l\u1ea7n th\u1ef1c hi\u1ec7n i ++)\n        console.log(0); // +1\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void{\n    var a: number = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // L\u1eb7p n l\u1ea7n\n    for(let i = 0; i &lt; n; i++){ // +1 (m\u1ed7i l\u1ea7n th\u1ef1c hi\u1ec7n i ++)\n        console.log(0); // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 1; // +1\n  a = a + 1; // +1\n  a = a * 2; // +1\n  // L\u1eb7p n l\u1ea7n\n  for (int i = 0; i &lt; n; i++) { // +1 (m\u1ed7i l\u1ea7n th\u1ef1c hi\u1ec7n i ++)\n    print(0); // +1\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let mut a = 1;   // +1\n    a = a + 1;      // +1\n    a = a * 2;      // +1\n\n    // L\u1eb7p n l\u1ea7n\n    for _ in 0..n { // +1 (m\u1ed7i l\u1ea7n th\u1ef1c hi\u1ec7n i ++)\n        println!(\"{}\", 0); // +1\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +1\n    a = a + 1;  // +1\n    a = a * 2;  // +1\n    // L\u1eb7p n l\u1ea7n\n    for (int i = 0; i &lt; n; i++) {   // +1 (m\u1ed7i l\u1ea7n th\u1ef1c hi\u1ec7n i ++)\n        printf(\"%d\", 0);            // +1\n    }\n} \n</code></pre> <pre><code>\n</code></pre> <pre><code>fn algorithm(n: usize) void {\n    var a: i32 = 1; // +1\n    a += 1; // +1\n    a *= 2; // +1\n    // L\u1eb7p n l\u1ea7n\n    for(0..n) |_| { // +1 (m\u1ed7i l\u1ea7n th\u1ef1c hi\u1ec7n i ++)\n        std.debug.print(\"{}\\n\", .{0}); // +1\n    }\n}\n</code></pre> <p>Cho m\u1ed9t h\u00e0m bi\u1ec3u di\u1ec5n s\u1ed1 ph\u00e9p to\u00e1n c\u1ee7a m\u1ed9t thu\u1eadt to\u00e1n theo k\u00edch th\u01b0\u1edbc \u0111\u1ea7u v\u00e0o \\(n\\), k\u00fd hi\u1ec7u l\u00e0 \\(T(n)\\), xem v\u00ed d\u1ee5 sau:</p> \\[ T(n) = 3 + 2n \\] <p>V\u00ec \\(T(n)\\) l\u00e0 m\u1ed9t h\u00e0m tuy\u1ebfn t\u00ednh, xu h\u01b0\u1edbng t\u0103ng tr\u01b0\u1edfng c\u1ee7a n\u00f3 l\u00e0 tuy\u1ebfn t\u00ednh, n\u00ean \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian l\u00e0 b\u1eadc tuy\u1ebfn t\u00ednh, k\u00fd hi\u1ec7u l\u00e0 \\(O(n)\\). K\u00fd hi\u1ec7u to\u00e1n h\u1ecdc n\u00e0y, g\u1ecdi l\u00e0 ch\u00fa th\u00edch big-O (big-O notation), bi\u1ec3u di\u1ec5n c\u1eadn tr\u00ean ti\u1ec7m c\u1eadn c\u1ee7a h\u00e0m \\(T(n)\\).</p> <p>V\u1ec1 b\u1ea3n ch\u1ea5t, ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian l\u00e0 t\u00ecm c\u1eadn tr\u00ean ti\u1ec7m c\u1eadn c\u1ee7a \"s\u1ed1 ph\u00e9p to\u00e1n \\(T(n)\\)\". N\u00f3 c\u00f3 \u0111\u1ecbnh ngh\u0129a to\u00e1n h\u1ecdc ch\u00ednh x\u00e1c.</p> <p>C\u1eadn tr\u00ean ti\u1ec7m c\u1eadn</p> <p>N\u1ebfu t\u1ed3n t\u1ea1i c\u00e1c s\u1ed1 th\u1ef1c d\u01b0\u01a1ng \\(c\\) v\u00e0 \\(n_0\\) sao cho v\u1edbi m\u1ecdi \\(n &gt; n_0\\), \\(T(n) \\leq c \\cdot f(n)\\), th\u00ec \\(f(n)\\) \u0111\u01b0\u1ee3c coi l\u00e0 c\u1eadn tr\u00ean ti\u1ec7m c\u1eadn c\u1ee7a \\(T(n)\\), k\u00fd hi\u1ec7u \\(T(n) = O(f(n))\\).</p> <p>Nh\u01b0 minh h\u1ecda trong h\u00ecnh d\u01b0\u1edbi, vi\u1ec7c t\u00ednh c\u1eadn tr\u00ean ti\u1ec7m c\u1eadn l\u00e0 t\u00ecm m\u1ed9t h\u00e0m \\(f(n)\\) sao cho khi \\(n\\) ti\u1ebfn t\u1edbi v\u00f4 c\u00f9ng, \\(T(n)\\) v\u00e0 \\(f(n)\\) c\u00f3 c\u00f9ng b\u1eadc t\u0103ng tr\u01b0\u1edfng, ch\u1ec9 kh\u00e1c nhau b\u1edfi m\u1ed9t h\u1ec7 s\u1ed1 h\u1eb1ng \\(c\\).</p> <p></p>"},{"location":"chapter_computational_complexity/time_complexity/#phuong-phap-tinh-toan","title":"Ph\u01b0\u01a1ng ph\u00e1p t\u00ednh to\u00e1n","text":"<p>M\u1eb7c d\u00f9 kh\u00e1i ni\u1ec7m c\u1eadn tr\u00ean ti\u1ec7m c\u1eadn c\u00f3 v\u1ebb to\u00e1n h\u1ecdc, b\u1ea1n kh\u00f4ng c\u1ea7n n\u1eafm v\u1eefng ngay l\u1eadp t\u1ee9c. H\u00e3y b\u1eaft \u0111\u1ea7u hi\u1ec3u ph\u01b0\u01a1ng ph\u00e1p t\u00ednh, b\u1ea1n c\u00f3 th\u1ec3 luy\u1ec7n t\u1eadp v\u00e0 hi\u1ec3u d\u1ea7n theo th\u1eddi gian.</p> <p>Khi \u0111\u00e3 x\u00e1c \u0111\u1ecbnh \u0111\u01b0\u1ee3c \\(f(n)\\), ta c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian \\(O(f(n))\\). Nh\u01b0ng l\u00e0m th\u1ebf n\u00e0o \u0111\u1ec3 x\u00e1c \u0111\u1ecbnh c\u1eadn tr\u00ean ti\u1ec7m c\u1eadn \\(f(n)\\)? Qu\u00e1 tr\u00ecnh n\u00e0y th\u01b0\u1eddng g\u1ed3m hai b\u01b0\u1edbc: \u0111\u1ebfm s\u1ed1 ph\u00e9p to\u00e1n v\u00e0 x\u00e1c \u0111\u1ecbnh c\u1eadn tr\u00ean ti\u1ec7m c\u1eadn.</p>"},{"location":"chapter_computational_complexity/time_complexity/#buoc-1-em-so-phep-toan","title":"B\u01b0\u1edbc 1: \u0111\u1ebfm s\u1ed1 ph\u00e9p to\u00e1n","text":"<p>B\u01b0\u1edbc n\u00e0y g\u1ed3m duy\u1ec7t m\u00e3 t\u1eebng d\u00f2ng. Tuy nhi\u00ean, do t\u1ed3n t\u1ea1i h\u1ec7 s\u1ed1 h\u1eb1ng \\(c\\) trong \\(c \\cdot f(n)\\), t\u1ea5t c\u1ea3 c\u00e1c h\u1ec7 s\u1ed1 v\u00e0 h\u1eb1ng s\u1ed1 trong \\(T(n)\\) c\u00f3 th\u1ec3 b\u1ecb b\u1ecf qua. Nguy\u00ean t\u1eafc n\u00e0y cho ph\u00e9p c\u00e1c k\u1ef9 thu\u1eadt \u0111\u01a1n gi\u1ea3n h\u00f3a khi \u0111\u1ebfm ph\u00e9p to\u00e1n.</p> <ol> <li>B\u1ecf qua c\u00e1c h\u1eb1ng s\u1ed1 trong \\(T(n)\\), v\u00ec ch\u00fang kh\u00f4ng ph\u1ee5 thu\u1ed9c v\u00e0o \\(n\\) n\u00ean kh\u00f4ng \u1ea3nh h\u01b0\u1edfng \u0111\u1ebfn \u0111\u1ed9 ph\u1ee9c t\u1ea1p.</li> <li>Lo\u1ea1i b\u1ecf t\u1ea5t c\u1ea3 h\u1ec7 s\u1ed1. V\u00ed d\u1ee5, l\u1eb7p 2n, 5n + 1 l\u1ea7n, v.v., c\u00f3 th\u1ec3 \u0111\u01a1n gi\u1ea3n th\u00e0nh n l\u1ea7n v\u00ec h\u1ec7 s\u1ed1 tr\u01b0\u1edbc n kh\u00f4ng l\u00e0m thay \u0111\u1ed5i \u0111\u1ed9 ph\u1ee9c t\u1ea1p.</li> <li>D\u00f9ng ph\u00e9p nh\u00e2n cho v\u00f2ng l\u1eb7p l\u1ed3ng nhau. T\u1ed5ng s\u1ed1 ph\u00e9p to\u00e1n b\u1eb1ng t\u00edch s\u1ed1 l\u01b0\u1ee3ng ph\u00e9p to\u00e1n \u1edf m\u1ed7i v\u00f2ng l\u1eb7p, \u00e1p d\u1ee5ng k\u1ef9 thu\u1eadt 1 v\u00e0 2 cho m\u1ed7i c\u1ea5p v\u00f2ng l\u1eb7p.</li> </ol> <p>V\u1edbi m\u1ed9t \u0111o\u1ea1n m\u00e3, ta c\u00f3 th\u1ec3 d\u00f9ng c\u00e1c k\u1ef9 thu\u1eadt tr\u00ean \u0111\u1ec3 \u0111\u1ebfm ph\u00e9p to\u00e1n:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>def algorithm(n: int):\n    a = 1      # +0 (m\u1eb9o 1)\n    a = a + n  # +0 (m\u1eb9o 1)\n    # +n (k\u1ef9 thu\u1eadt 2)\n    for i in range(5 * n + 1):\n        print(0)\n    # +n*n (k\u1ef9 thu\u1eadt 3)\n    for i in range(2 * n):\n        for j in range(n + 1):\n            print(0)\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (m\u1eb9o 1)\n    a = a + n;  // +0 (m\u1eb9o 1)\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        cout &lt;&lt; 0 &lt;&lt; endl;\n    }\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            cout &lt;&lt; 0 &lt;&lt; endl;\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (m\u1eb9o 1)\n    a = a + n;  // +0 (m\u1eb9o 1)\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        System.out.println(0);\n    }\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            System.out.println(0);\n        }\n    }\n}\n</code></pre> <pre><code>void Algorithm(int n) {\n    int a = 1;  // +0 (m\u1eb9o 1)\n    a = a + n;  // +0 (m\u1eb9o 1)\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        Console.WriteLine(0);\n    }\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            Console.WriteLine(0);\n        }\n    }\n}\n</code></pre> <pre><code>func algorithm(n int) {\n    a := 1     // +0 (m\u1eb9o 1)\n    a = a + n  // +0 (m\u1eb9o 1)\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for i := 0; i &lt; 5 * n + 1; i++ {\n        fmt.Println(0)\n    }\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for i := 0; i &lt; 2 * n; i++ {\n        for j := 0; j &lt; n + 1; j++ {\n            fmt.Println(0)\n        }\n    }\n}\n</code></pre> <pre><code>func algorithm(n: Int) {\n    var a = 1 // +0 (m\u1eb9o 1)\n    a = a + n // +0 (m\u1eb9o 1)\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for _ in 0 ..&lt; (5 * n + 1) {\n        print(0)\n    }\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for _ in 0 ..&lt; (2 * n) {\n        for _ in 0 ..&lt; (n + 1) {\n            print(0)\n        }\n    }\n}\n</code></pre> <pre><code>function algorithm(n) {\n    let a = 1;  // +0 (m\u1eb9o 1)\n    a = a + n;  // +0 (m\u1eb9o 1)\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for (let i = 0; i &lt; 5 * n + 1; i++) {\n        console.log(0);\n    }\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for (let i = 0; i &lt; 2 * n; i++) {\n        for (let j = 0; j &lt; n + 1; j++) {\n            console.log(0);\n        }\n    }\n}\n</code></pre> <pre><code>function algorithm(n: number): void {\n    let a = 1;  // +0 (m\u1eb9o 1)\n    a = a + n;  // +0 (m\u1eb9o 1)\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for (let i = 0; i &lt; 5 * n + 1; i++) {\n        console.log(0);\n    }\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for (let i = 0; i &lt; 2 * n; i++) {\n        for (let j = 0; j &lt; n + 1; j++) {\n            console.log(0);\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n  int a = 1; // +0 (m\u1eb9o 1)\n  a = a + n; // +0 (m\u1eb9o 1)\n  // +n (k\u1ef9 thu\u1eadt 2)\n  for (int i = 0; i &lt; 5 * n + 1; i++) {\n    print(0);\n  }\n  // +n*n (k\u1ef9 thu\u1eadt 3)\n  for (int i = 0; i &lt; 2 * n; i++) {\n    for (int j = 0; j &lt; n + 1; j++) {\n      print(0);\n    }\n  }\n}\n</code></pre> <pre><code>fn algorithm(n: i32) {\n    let mut a = 1;     // +0 (m\u1eb9o 1)\n    a = a + n;        // +0 (m\u1eb9o 1)\n\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for i in 0..(5 * n + 1) {\n        println!(\"{}\", 0);\n    }\n\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for i in 0..(2 * n) {\n        for j in 0..(n + 1) {\n            println!(\"{}\", 0);\n        }\n    }\n}\n</code></pre> <pre><code>void algorithm(int n) {\n    int a = 1;  // +0 (m\u1eb9o 1)\n    a = a + n;  // +0 (m\u1eb9o 1)\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for (int i = 0; i &lt; 5 * n + 1; i++) {\n        printf(\"%d\", 0);\n    }\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for (int i = 0; i &lt; 2 * n; i++) {\n        for (int j = 0; j &lt; n + 1; j++) {\n            printf(\"%d\", 0);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>fn algorithm(n: usize) void {\n    var a: i32 = 1;     // +0 (m\u1eb9o 1)\n    a = a + @as(i32, @intCast(n));        // +0 (m\u1eb9o 1)\n\n    // +n (k\u1ef9 thu\u1eadt 2)\n    for(0..(5 * n + 1)) |_| {\n        std.debug.print(\"{}\\n\", .{0});\n    }\n\n    // +n*n (k\u1ef9 thu\u1eadt 3)\n    for(0..(2 * n)) |_| {\n        for(0..(n + 1)) |_| {\n            std.debug.print(\"{}\\n\", .{0});\n        }\n    }\n}\n</code></pre> <p>C\u00f4ng th\u1ee9c d\u01b0\u1edbi \u0111\u00e2y cho th\u1ea5y k\u1ebft qu\u1ea3 \u0111\u1ebfm tr\u01b0\u1edbc v\u00e0 sau khi \u0111\u01a1n gi\u1ea3n h\u00f3a, \u0111\u1ec1u d\u1eabn t\u1edbi \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian \\(O(n^2)\\):</p> \\[ \\begin{aligned} T(n) &amp; = 2n(n + 1) + (5n + 1) + 2 &amp; \\text{\u0110\u1ebfm \u0111\u1ea7y \u0111\u1ee7 (-.-|||)} \\newline &amp; = 2n^2 + 7n + 3 \\newline T(n) &amp; = n^2 + n &amp; \\text{\u0110\u1ebfm \u0111\u00e3 \u0111\u01a1n gi\u1ea3n (o.O)} \\end{aligned} \\]"},{"location":"chapter_computational_complexity/time_complexity/#buoc-2-xac-inh-can-tren-tiem-can","title":"B\u01b0\u1edbc 2: x\u00e1c \u0111\u1ecbnh c\u1eadn tr\u00ean ti\u1ec7m c\u1eadn","text":"<p>\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian \u0111\u01b0\u1ee3c x\u00e1c \u0111\u1ecbnh b\u1edfi h\u1ea1ng l\u1edbn nh\u1ea5t trong \\(T(n)\\). B\u1edfi v\u00ec khi \\(n\\) ti\u1ebfn t\u1edbi v\u00f4 c\u00f9ng, h\u1ea1ng l\u1edbn nh\u1ea5t s\u1ebd chi ph\u1ed1i, l\u00e0m cho \u1ea3nh h\u01b0\u1edfng c\u1ee7a c\u00e1c h\u1ea1ng kh\u00e1c tr\u1edf n\u00ean kh\u00f4ng \u0111\u00e1ng k\u1ec3.</p> <p>B\u1ea3ng d\u01b0\u1edbi \u0111\u00e2y minh h\u1ecda v\u00ed d\u1ee5 v\u1ec1 c\u00e1c s\u1ed1 ph\u00e9p to\u00e1n kh\u00e1c nhau v\u00e0 \u0111\u1ed9 ph\u1ee9c t\u1ea1p t\u01b0\u01a1ng \u1ee9ng. M\u1ed9t s\u1ed1 gi\u00e1 tr\u1ecb \u0111\u01b0\u1ee3c ph\u00f3ng \u0111\u1ea1i \u0111\u1ec3 nh\u1ea5n m\u1ea1nh r\u1eb1ng h\u1ec7 s\u1ed1 kh\u00f4ng th\u1ec3 thay \u0111\u1ed5i c\u1ea5p \u0111\u1ed9 t\u0103ng tr\u01b0\u1edfng. Khi \\(n\\) r\u1ea5t l\u1edbn, c\u00e1c h\u1eb1ng s\u1ed1 tr\u1edf n\u00ean kh\u00f4ng \u0111\u00e1ng k\u1ec3.</p> <p> B\u1ea3ng: \u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian cho c\u00e1c s\u1ed1 ph\u00e9p to\u00e1n kh\u00e1c nhau </p> S\u1ed1 ph\u00e9p to\u00e1n \\(T(n)\\) \u0110\u1ed9 ph\u1ee9c t\u1ea1p \\(O(f(n))\\) \\(100000\\) \\(O(1)\\) \\(3n + 2\\) \\(O(n)\\) \\(2n^2 + 3n + 2\\) \\(O(n^2)\\) \\(n^3 + 10000n^2\\) \\(O(n^3)\\) \\(2^n + 10000n^{10000}\\) \\(O(2^n)\\)"},{"location":"chapter_computational_complexity/time_complexity/#cac-loai-o-phuc-tap-thoi-gian-pho-bien","title":"C\u00e1c lo\u1ea1i \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian ph\u1ed5 bi\u1ebfn","text":"<p>Gi\u1ea3 s\u1eed k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o l\u00e0 \\(n\\). C\u00e1c lo\u1ea1i \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian ph\u1ed5 bi\u1ebfn \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp t\u1eeb th\u1ea5p \u0111\u1ebfn cao nh\u01b0 sau:</p> \\[ \\begin{aligned} &amp; O(1) &lt; O(\\log n) &lt; O(n) &lt; O(n \\log n) &lt; O(n^2) &lt; O(2^n) &lt; O(n!) \\newline &amp; \\text{H\u1eb1ng s\u1ed1} &lt; \\text{Log} &lt; \\text{Tuy\u1ebfn t\u00ednh} &lt; \\text{Tuy\u1ebfn t\u00ednh-Log} &lt; \\text{B\u1eadc hai} &lt; \\text{M\u0169} &lt; \\text{Giai th\u1eeba} \\end{aligned} \\] <p></p>"},{"location":"chapter_computational_complexity/time_complexity/#bac-hang-so-o1","title":"B\u1eadc h\u1eb1ng s\u1ed1 \\(O(1)\\)","text":"<p>B\u1eadc h\u1eb1ng s\u1ed1 ngh\u0129a l\u00e0 s\u1ed1 ph\u00e9p to\u00e1n kh\u00f4ng ph\u1ee5 thu\u1ed9c v\u00e0o k\u00edch th\u01b0\u1edbc \u0111\u1ea7u v\u00e0o \\(n\\). Trong h\u00e0m d\u01b0\u1edbi \u0111\u00e2y, m\u1eb7c d\u00f9 s\u1ed1 l\u1ea7n in <code>size</code> c\u00f3 th\u1ec3 l\u1edbn, \u0111\u1ed9 ph\u1ee9c t\u1ea1p v\u1eabn l\u00e0 \\(O(1)\\) v\u00ec kh\u00f4ng li\u00ean quan \u0111\u1ebfn \\(n\\):</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{constant}\n</code></pre>"},{"location":"chapter_computational_complexity/time_complexity/#bac-tuyen-tinh-on","title":"B\u1eadc tuy\u1ebfn t\u00ednh \\(O(n)\\)","text":"<p>B\u1eadc tuy\u1ebfn t\u00ednh ngh\u0129a l\u00e0 s\u1ed1 ph\u00e9p to\u00e1n t\u0103ng theo tuy\u1ebfn t\u00ednh v\u1edbi k\u00edch th\u01b0\u1edbc \u0111\u1ea7u v\u00e0o \\(n\\). B\u1eadc tuy\u1ebfn t\u00ednh th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n \u1edf c\u1ea5u tr\u00fac v\u00f2ng l\u1eb7p \u0111\u01a1n:</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{linear}\n</code></pre> <p>C\u00e1c thao t\u00e1c nh\u01b0 duy\u1ec7t m\u1ea3ng v\u00e0 duy\u1ec7t danh s\u00e1ch li\u00ean k\u1ebft c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p l\u00e0 \\(O(n)\\), v\u1edbi \\(n\\) l\u00e0 \u0111\u1ed9 d\u00e0i m\u1ea3ng ho\u1eb7c danh s\u00e1ch:</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{array_traversal}\n</code></pre> <p>C\u1ea7n l\u01b0u \u00fd r\u1eb1ng k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \\(n\\) n\u00ean \u0111\u01b0\u1ee3c x\u00e1c \u0111\u1ecbnh d\u1ef1a tr\u00ean lo\u1ea1i d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o. V\u00ed d\u1ee5, trong v\u00ed d\u1ee5 \u0111\u1ea7u ti\u00ean, \\(n\\) l\u00e0 k\u00edch th\u01b0\u1edbc d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o, trong v\u00ed d\u1ee5 th\u1ee9 hai, \\(n\\) l\u00e0 \u0111\u1ed9 d\u00e0i m\u1ea3ng.</p>"},{"location":"chapter_computational_complexity/time_complexity/#bac-hai-on2","title":"B\u1eadc hai \\(O(n^2)\\)","text":"<p>B\u1eadc hai ngh\u0129a l\u00e0 s\u1ed1 ph\u00e9p to\u00e1n t\u0103ng b\u00ecnh ph\u01b0\u01a1ng theo k\u00edch th\u01b0\u1edbc \u0111\u1ea7u v\u00e0o \\(n\\). B\u1eadc hai th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n \u1edf v\u00f2ng l\u1eb7p l\u1ed3ng nhau, khi v\u00f2ng ngo\u00e0i v\u00e0 v\u00f2ng trong \u0111\u1ec1u c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p \\(O(n)\\), d\u1eabn t\u1edbi t\u1ed5ng th\u1ec3 \\(O(n^2)\\):</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{quadratic}\n</code></pre> <p>H\u00ecnh d\u01b0\u1edbi so s\u00e1nh b\u1eadc h\u1eb1ng s\u1ed1, tuy\u1ebfn t\u00ednh v\u00e0 b\u1eadc hai.</p> <p></p> <p>V\u00ed d\u1ee5, trong s\u1eafp x\u1ebfp n\u1ed5i b\u1ecdt (bubble sort), v\u00f2ng ngo\u00e0i ch\u1ea1y \\(n - 1\\) l\u1ea7n, v\u00f2ng trong ch\u1ea1y \\(n-1\\), \\(n-2\\), ..., \\(2\\), \\(1\\) l\u1ea7n, trung b\u00ecnh \\(n / 2\\) l\u1ea7n, d\u1eabn t\u1edbi \u0111\u1ed9 ph\u1ee9c t\u1ea1p \\(O((n - 1) n / 2) = O(n^2)\\):</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{bubble_sort}\n</code></pre>"},{"location":"chapter_computational_complexity/time_complexity/#bac-mu-o2n","title":"B\u1eadc m\u0169 \\(O(2^n)\\)","text":"<p>\"Ph\u00e2n chia t\u1ebf b\u00e0o\" trong sinh h\u1ecdc l\u00e0 v\u00ed d\u1ee5 kinh \u0111i\u1ec3n c\u1ee7a t\u0103ng tr\u01b0\u1edfng b\u1eadc m\u0169: b\u1eaft \u0111\u1ea7u t\u1eeb m\u1ed9t t\u1ebf b\u00e0o, sau m\u1ed9t l\u1ea7n ph\u00e2n chia th\u00e0nh hai, sau hai l\u1ea7n th\u00e0nh b\u1ed1n, v\u00e0 c\u1ee9 th\u1ebf, sau \\(n\\) l\u1ea7n s\u1ebd c\u00f3 \\(2^n\\) t\u1ebf b\u00e0o.</p> <p>H\u00ecnh d\u01b0\u1edbi v\u00e0 m\u00e3 m\u00f4 ph\u1ecfng qu\u00e1 tr\u00ecnh ph\u00e2n chia t\u1ebf b\u00e0o, c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p \\(O(2^n)\\):</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{exponential}\n</code></pre> <p></p> <p>Trong th\u1ef1c t\u1ebf, b\u1eadc m\u0169 th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n \u1edf c\u00e1c h\u00e0m \u0111\u1ec7 quy. V\u00ed d\u1ee5, trong m\u00e3 d\u01b0\u1edbi, n\u00f3 \u0111\u1ec7 quy t\u00e1ch th\u00e0nh hai nh\u00e1nh, d\u1eebng sau \\(n\\) l\u1ea7n ph\u00e2n chia:</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{exp_recur}\n</code></pre> <p>T\u0103ng tr\u01b0\u1edfng b\u1eadc m\u0169 r\u1ea5t nhanh v\u00e0 th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n \u1edf c\u00e1c ph\u01b0\u01a1ng ph\u00e1p t\u00ecm ki\u1ebfm to\u00e0n di\u1ec7n (brute force, backtracking, v.v.). V\u1edbi b\u00e0i to\u00e1n quy m\u00f4 l\u1edbn, b\u1eadc m\u0169 l\u00e0 kh\u00f4ng ch\u1ea5p nh\u1eadn \u0111\u01b0\u1ee3c, th\u01b0\u1eddng c\u1ea7n d\u00f9ng quy ho\u1ea1ch \u0111\u1ed9ng ho\u1eb7c thu\u1eadt to\u00e1n tham lam l\u00e0m gi\u1ea3i ph\u00e1p.</p>"},{"location":"chapter_computational_complexity/time_complexity/#bac-logarit-olog-n","title":"B\u1eadc logarit \\(O(\\log n)\\)","text":"<p>Ng\u01b0\u1ee3c v\u1edbi b\u1eadc m\u0169, b\u1eadc logarit m\u00f4 t\u1ea3 t\u00ecnh hu\u1ed1ng \"k\u00edch th\u01b0\u1edbc gi\u1ea3m m\u1ed9t n\u1eeda m\u1ed7i v\u00f2ng\". V\u1edbi k\u00edch th\u01b0\u1edbc \u0111\u1ea7u v\u00e0o \\(n\\), v\u00ec m\u1ed7i v\u00f2ng gi\u1ea3m m\u1ed9t n\u1eeda, s\u1ed1 v\u00f2ng c\u1ea7n thi\u1ebft l\u00e0 \\(\\log_2 n\\), l\u00e0 h\u00e0m \u0111\u1ea3o c\u1ee7a \\(2^n\\).</p> <p>H\u00ecnh d\u01b0\u1edbi v\u00e0 m\u00e3 m\u00f4 ph\u1ecfng qu\u00e1 tr\u00ecnh \"gi\u1ea3m m\u1ed9t n\u1eeda m\u1ed7i v\u00f2ng\", c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p \\(O(\\log_2 n)\\), th\u01b0\u1eddng vi\u1ebft t\u1eaft l\u00e0 \\(O(\\log n)\\):</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{logarithmic}\n</code></pre> <p></p> <p>Gi\u1ed1ng nh\u01b0 b\u1eadc m\u0169, b\u1eadc logarit c\u0169ng th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n \u1edf c\u00e1c h\u00e0m \u0111\u1ec7 quy. M\u00e3 d\u01b0\u1edbi t\u1ea1o m\u1ed9t c\u00e2y \u0111\u1ec7 quy c\u00f3 chi\u1ec1u cao \\(\\log_2 n\\):</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{log_recur}\n</code></pre> <p>B\u1eadc logarit ph\u1ed5 bi\u1ebfn trong c\u00e1c thu\u1eadt to\u00e1n chia \u0111\u1ec3 tr\u1ecb (divide-and-conquer), th\u1ec3 hi\u1ec7n \u00fd t\u01b0\u1edfng \"chia nh\u1ecf\" v\u00e0 \"gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 l\u1edbn b\u1eb1ng c\u00e1ch chia nh\u1ecf\". \u0110\u00e2y l\u00e0 t\u1ed1c \u0111\u1ed9 t\u0103ng tr\u01b0\u1edfng r\u1ea5t ch\u1eadm v\u00e0 l\u00e0 \u0111\u1ed9 ph\u1ee9c t\u1ea1p l\u00fd t\u01b0\u1edfng sau b\u1eadc h\u1eb1ng s\u1ed1.</p> <p>C\u01a1 s\u1ed1 c\u1ee7a \\(O(\\log n)\\) l\u00e0 g\u00ec?</p> <p>K\u1ef9 thu\u1eadt th\u1ef1c t\u1ebf \"chia th\u00e0nh m ph\u1ea7n\" t\u01b0\u01a1ng \u1ee9ng v\u1edbi \u0111\u1ed9 ph\u1ee9c t\u1ea1p \\(O(\\log_m n)\\). D\u00f9ng c\u00f4ng th\u1ee9c \u0111\u1ed5i c\u01a1 s\u1ed1 logarit, ta c\u00f3 th\u1ec3 quy m\u1ecdi c\u01a1 s\u1ed1 v\u1ec1 nhau:</p> \\[ O(\\log_m n) = O(\\log_k n / \\log_k m) = O(\\log_k n) \\] <p>\u0110i\u1ec1u n\u00e0y ngh\u0129a l\u00e0 c\u01a1 s\u1ed1 \\(m\\) c\u00f3 th\u1ec3 thay \u0111\u1ed5i m\u00e0 kh\u00f4ng \u1ea3nh h\u01b0\u1edfng t\u1edbi \u0111\u1ed9 ph\u1ee9c t\u1ea1p. V\u00ec v\u1eady, th\u01b0\u1eddng ta b\u1ecf qua c\u01a1 s\u1ed1 v\u00e0 vi\u1ebft \u0111\u01a1n gi\u1ea3n l\u00e0 \\(O(\\log n)\\).</p>"},{"location":"chapter_computational_complexity/time_complexity/#bac-tuyen-tinh-logarit-on-log-n","title":"B\u1eadc tuy\u1ebfn t\u00ednh-logarit \\(O(n \\log n)\\)","text":"<p>B\u1eadc tuy\u1ebfn t\u00ednh-logarit th\u01b0\u1eddng xu\u1ea5t hi\u1ec7n \u1edf v\u00f2ng l\u1eb7p l\u1ed3ng nhau m\u00e0 m\u1ed9t v\u00f2ng c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p \\(O(\\log n)\\) v\u00e0 v\u00f2ng kia l\u00e0 \\(O(n)\\). M\u00e3 li\u00ean quan nh\u01b0 sau:</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{linear_log_recur}\n</code></pre> <p>H\u00ecnh d\u01b0\u1edbi cho th\u1ea5y c\u00e1ch t\u1ea1o ra b\u1eadc \\(O(n \\log n)\\). M\u1ed7i c\u1ea5p trong c\u00e2y nh\u1ecb ph\u00e2n c\u00f3 \\(n\\) ph\u00e9p to\u00e1n, v\u00e0 c\u00e2y c\u00f3 \\(\\log_2 n + 1\\) c\u1ea5p, d\u1eabn t\u1edbi t\u1ed5ng l\u00e0 \\(O(n \\log n)\\).</p> <p></p> <p>C\u00e1c thu\u1eadt to\u00e1n s\u1eafp x\u1ebfp ph\u1ed5 bi\u1ebfn th\u01b0\u1eddng c\u00f3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p \\(O(n \\log n)\\), nh\u01b0 quicksort, mergesort, v\u00e0 heapsort.</p>"},{"location":"chapter_computational_complexity/time_complexity/#bac-giai-thua-on","title":"B\u1eadc giai th\u1eeba \\(O(n!)\\)","text":"<p>B\u1eadc giai th\u1eeba t\u01b0\u01a1ng \u1ee9ng v\u1edbi b\u00e0i to\u00e1n \"ho\u00e1n v\u1ecb \u0111\u1ea7y \u0111\u1ee7\". V\u1edbi \\(n\\) ph\u1ea7n t\u1eed ph\u00e2n bi\u1ec7t, s\u1ed1 ho\u00e1n v\u1ecb l\u00e0:</p> \\[ n! = n \\times (n - 1) \\times (n - 2) \\times \\dots \\times 2 \\times 1 \\] <p>Giai th\u1eeba th\u01b0\u1eddng \u0111\u01b0\u1ee3c c\u00e0i b\u1eb1ng \u0111\u1ec7 quy. Nh\u01b0 trong m\u00e3 v\u00e0 h\u00ecnh d\u01b0\u1edbi, c\u1ea5p \u0111\u1ea7u t\u00e1ch th\u00e0nh \\(n\\) nh\u00e1nh, c\u1ea5p hai th\u00e0nh \\(n - 1\\) nh\u00e1nh, v\u00e0 c\u1ee9 th\u1ebf, d\u1eebng sau c\u1ea5p th\u1ee9 \\(n\\):</p> <pre><code>[file]{time_complexity}-[class]{}-[func]{factorial_recur}\n</code></pre> <p></p> <p>L\u01b0u \u00fd r\u1eb1ng b\u1eadc giai th\u1eeba t\u0103ng nhanh h\u01a1n c\u1ea3 b\u1eadc m\u0169; n\u00f3 kh\u00f4ng ch\u1ea5p nh\u1eadn \u0111\u01b0\u1ee3c cho \\(n\\) l\u1edbn.</p>"},{"location":"chapter_computational_complexity/time_complexity/#o-phuc-tap-trong-truong-hop-xau-nhat-tot-nhat-va-trung-binh","title":"\u0110\u1ed9 ph\u1ee9c t\u1ea1p trong tr\u01b0\u1eddng h\u1ee3p x\u1ea5u nh\u1ea5t, t\u1ed1t nh\u1ea5t v\u00e0 trung b\u00ecnh","text":"<p>Hi\u1ec7u su\u1ea5t th\u1eddi gian c\u1ee7a m\u1ed9t thu\u1eadt to\u00e1n th\u01b0\u1eddng kh\u00f4ng c\u1ed1 \u0111\u1ecbnh m\u00e0 ph\u1ee5 thu\u1ed9c v\u00e0o ph\u00e2n b\u1ed1 d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o. Gi\u1ea3 s\u1eed ta c\u00f3 m\u1ed9t m\u1ea3ng <code>nums</code> \u0111\u1ed9 d\u00e0i \\(n\\), g\u1ed3m c\u00e1c s\u1ed1 t\u1eeb \\(1\\) \u0111\u1ebfn \\(n\\), m\u1ed7i s\u1ed1 xu\u1ea5t hi\u1ec7n \u0111\u00fang m\u1ed9t l\u1ea7n, nh\u01b0ng b\u1ecb tr\u00e1o ng\u1eabu nhi\u00ean. Nhi\u1ec7m v\u1ee5 l\u00e0 tr\u1ea3 v\u1ec1 ch\u1ec9 s\u1ed1 c\u1ee7a ph\u1ea7n t\u1eed \\(1\\). Ta c\u00f3 th\u1ec3 r\u00fat ra:</p> <ul> <li>Khi <code>nums = [?, ?, ..., 1]</code>, t\u1ee9c l\u00e0 ph\u1ea7n t\u1eed cu\u1ed1i c\u00f9ng l\u00e0 \\(1\\), c\u1ea7n duy\u1ec7t to\u00e0n b\u1ed9 m\u1ea3ng, \u0111\u1ea1t \u0111\u1ed9 ph\u1ee9c t\u1ea1p tr\u01b0\u1eddng h\u1ee3p x\u1ea5u nh\u1ea5t \\(O(n)\\).</li> <li>Khi <code>nums = [1, ?, ?, ...]</code>, t\u1ee9c l\u00e0 ph\u1ea7n t\u1eed \u0111\u1ea7u ti\u00ean l\u00e0 \\(1\\), kh\u00f4ng c\u1ea7n duy\u1ec7t th\u00eam, \u0111\u1ea1t \u0111\u1ed9 ph\u1ee9c t\u1ea1p t\u1ed1t nh\u1ea5t \\(\\Omega(1)\\).</li> </ul> <p>\"\u0110\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian tr\u01b0\u1eddng h\u1ee3p x\u1ea5u nh\u1ea5t\" t\u01b0\u01a1ng \u1ee9ng v\u1edbi c\u1eadn tr\u00ean ti\u1ec7m c\u1eadn, k\u00fd hi\u1ec7u b\u1eb1ng k\u00fd t\u1ef1 l\u1edbn \\(O\\). T\u01b0\u01a1ng \u1ee9ng, \"\u0111\u1ed9 ph\u1ee9c t\u1ea1p t\u1ed1t nh\u1ea5t\" t\u01b0\u01a1ng \u1ee9ng v\u1edbi c\u1eadn d\u01b0\u1edbi ti\u1ec7m c\u1eadn, k\u00fd hi\u1ec7u b\u1eb1ng \\(\\Omega\\):</p> <pre><code>[file]{worst_best_time_complexity}-[class]{}-[func]{find_one}\n</code></pre> <p>C\u1ea7n l\u01b0u \u00fd r\u1eb1ng \u0111\u1ed9 ph\u1ee9c t\u1ea1p t\u1ed1t nh\u1ea5t hi\u1ebfm khi \u0111\u01b0\u1ee3c d\u00f9ng trong th\u1ef1c t\u1ebf, v\u00ec n\u00f3 th\u01b0\u1eddng ch\u1ec9 \u0111\u1ea1t \u0111\u01b0\u1ee3c trong c\u00e1c ph\u00e2n b\u1ed1 d\u1eef li\u1ec7u r\u1ea5t hi\u1ebfm v\u00e0 c\u00f3 th\u1ec3 g\u00e2y hi\u1ec3u l\u1ea7m. \u0110\u1ed9 ph\u1ee9c t\u1ea1p tr\u01b0\u1eddng h\u1ee3p x\u1ea5u nh\u1ea5t th\u1ef1c t\u1ebf h\u01a1n v\u00ec n\u00f3 cung c\u1ea5p gi\u00e1 tr\u1ecb an to\u00e0n cho hi\u1ec7u su\u1ea5t, gi\u00fap ta t\u1ef1 tin s\u1eed d\u1ee5ng thu\u1eadt to\u00e1n.</p> <p>T\u1eeb v\u00ed d\u1ee5 tr\u00ean, r\u00f5 r\u00e0ng r\u1eb1ng c\u1ea3 tr\u01b0\u1eddng h\u1ee3p x\u1ea5u nh\u1ea5t v\u00e0 t\u1ed1t nh\u1ea5t \u0111\u1ec1u x\u1ea3y ra khi c\u00f3 \"ph\u00e2n b\u1ed1 d\u1eef li\u1ec7u \u0111\u1eb7c bi\u1ec7t\", c\u00f3 th\u1ec3 x\u00e1c su\u1ea5t nh\u1ecf v\u00e0 kh\u00f4ng ph\u1ea3n \u00e1nh \u0111\u00fang hi\u1ec7u su\u1ea5t th\u1ef1c t\u1ebf. Ng\u01b0\u1ee3c l\u1ea1i, \u0111\u1ed9 ph\u1ee9c t\u1ea1p trung b\u00ecnh c\u00f3 th\u1ec3 ph\u1ea3n \u00e1nh hi\u1ec7u su\u1ea5t thu\u1eadt to\u00e1n d\u01b0\u1edbi d\u1eef li\u1ec7u ng\u1eabu nhi\u00ean, k\u00fd hi\u1ec7u b\u1eb1ng \\(\\Theta\\).</p> <p>V\u1edbi m\u1ed9t s\u1ed1 thu\u1eadt to\u00e1n, ta c\u00f3 th\u1ec3 \u01b0\u1edbc l\u01b0\u1ee3ng trung b\u00ecnh \u0111\u01a1n gi\u1ea3n khi gi\u1ea3 s\u1eed ph\u00e2n b\u1ed1 d\u1eef li\u1ec7u ng\u1eabu nhi\u00ean. V\u00ed d\u1ee5, trong v\u00ed d\u1ee5 t\u00ecm 1 \u1edf tr\u00ean, v\u00ec m\u1ea3ng b\u1ecb tr\u00e1o \u0111\u1ec1u, x\u00e1c su\u1ea5t ph\u1ea7n t\u1eed 1 xu\u1ea5t hi\u1ec7n \u1edf m\u1ed7i v\u1ecb tr\u00ed l\u00e0 nh\u01b0 nhau. Do \u0111\u00f3, s\u1ed1 v\u00f2ng trung b\u00ecnh l\u00e0 n\u1eeda \u0111\u1ed9 d\u00e0i m\u1ea3ng \\(n / 2\\), cho \u0111\u1ed9 ph\u1ee9c t\u1ea1p trung b\u00ecnh \\(\\Theta(n / 2) = \\Theta(n)\\).</p> <p>Tuy nhi\u00ean, t\u00ednh \u0111\u1ed9 ph\u1ee9c t\u1ea1p trung b\u00ecnh cho c\u00e1c thu\u1eadt to\u00e1n ph\u1ee9c t\u1ea1p h\u01a1n c\u00f3 th\u1ec3 kh\u00f3, v\u00ec kh\u00f3 ph\u00e2n t\u00edch gi\u00e1 tr\u1ecb k\u1ef3 v\u1ecdng d\u01b0\u1edbi ph\u00e2n b\u1ed1 d\u1eef li\u1ec7u. Trong nh\u1eefng tr\u01b0\u1eddng h\u1ee3p n\u00e0y, ta th\u01b0\u1eddng d\u00f9ng \u0111\u1ed9 ph\u1ee9c t\u1ea1p tr\u01b0\u1eddng h\u1ee3p x\u1ea5u nh\u1ea5t l\u00e0m ti\u00eau chu\u1ea9n \u0111\u00e1nh gi\u00e1 hi\u1ec7u su\u1ea5t.</p> <p>T\u1ea1i sao \u00edt th\u1ea5y k\u00fd hi\u1ec7u \\(\\Theta\\)?</p> <p>C\u00f3 th\u1ec3 v\u00ec ch\u00fa th\u00edch \\(O\\) \u0111\u01b0\u1ee3c d\u00f9ng ph\u1ed5 bi\u1ebfn h\u01a1n trong l\u1eddi n\u00f3i, n\u00ean ng\u01b0\u1eddi ta hay d\u00f9ng \\(O\\) \u0111\u1ec3 ch\u1ec9 c\u1ea3 \u0111\u1ed9 ph\u1ee9c t\u1ea1p trung b\u00ecnh. Tuy nhi\u00ean, nghi\u00eam t\u00fac m\u00e0 n\u00f3i, c\u00e1ch l\u00e0m \u0111\u00f3 kh\u00f4ng ch\u00ednh x\u00e1c. Trong s\u00e1ch n\u00e0y v\u00e0 c\u00e1c t\u00e0i li\u1ec7u kh\u00e1c, n\u1ebfu b\u1ea1n th\u1ea5y c\u00e2u \"\u0111\u1ed9 ph\u1ee9c t\u1ea1p trung b\u00ecnh \\(O(n)\\)\", h\u00e3y hi\u1ec3u tr\u1ef1c ti\u1ebfp l\u00e0 \\(\\Theta(n)\\).</p>"},{"location":"chapter_data_structure/","title":"C\u1ea5u tr\u00fac d\u1eef li\u1ec7u","text":""},{"location":"chapter_data_structure/#cau-truc-du-lieu","title":"C\u1ea5u tr\u00fac d\u1eef li\u1ec7u","text":"<p>Abstract</p> <p>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u00f3ng vai tr\u00f2 nh\u01b0 m\u1ed9t khu\u00f4n kh\u1ed5 v\u1eefng ch\u1eafc v\u00e0 \u0111a d\u1ea1ng.</p> <p>Ch\u00fang cung c\u1ea5p m\u1ed9t b\u1ea3n thi\u1ebft k\u1ebf cho vi\u1ec7c t\u1ed5 ch\u1ee9c d\u1eef li\u1ec7u m\u1ed9t c\u00e1ch c\u00f3 tr\u1eadt t\u1ef1, tr\u00ean \u0111\u00f3 c\u00e1c thu\u1eadt to\u00e1n \u0111\u01b0\u1ee3c tri\u1ec3n khai.</p>"},{"location":"chapter_data_structure/basic_data_types/","title":"3.2 Basic data types","text":""},{"location":"chapter_data_structure/basic_data_types/#cac-kieu-du-lieu-co-ban","title":"C\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n","text":"<p>Khi n\u00f3i v\u1ec1 d\u1eef li\u1ec7u trong m\u00e1y t\u00ednh, ch\u00fang ta th\u01b0\u1eddng ngh\u0129 \u0111\u1ebfn c\u00e1c d\u1ea1ng nh\u01b0 v\u0103n b\u1ea3n, h\u00ecnh \u1ea3nh, video, \u00e2m thanh v\u00e0 m\u00f4 h\u00ecnh 3D. D\u00f9 c\u00f3 c\u00e1ch t\u1ed5 ch\u1ee9c kh\u00e1c nhau, t\u1ea5t c\u1ea3 \u0111\u1ec1u \u0111\u01b0\u1ee3c t\u1ea1o th\u00e0nh t\u1eeb c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n.</p> <p>Ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n l\u00e0 nh\u1eefng ki\u1ec3u m\u00e0 CPU c\u00f3 th\u1ec3 thao t\u00e1c tr\u1ef1c ti\u1ebfp v\u00e0 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng tr\u1ef1c ti\u1ebfp trong thu\u1eadt to\u00e1n, ch\u1ee7 y\u1ebfu g\u1ed3m c\u00e1c lo\u1ea1i sau:</p> <ul> <li>Ki\u1ec3u s\u1ed1 nguy\u00ean: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>.</li> <li>Ki\u1ec3u s\u1ed1 th\u1ef1c: <code>float</code>, <code>double</code>, d\u00f9ng \u0111\u1ec3 bi\u1ec3u di\u1ec5n s\u1ed1 th\u1eadp ph\u00e2n.</li> <li>Ki\u1ec3u k\u00fd t\u1ef1: <code>char</code>, d\u00f9ng \u0111\u1ec3 bi\u1ec3u di\u1ec5n ch\u1eef c\u00e1i, d\u1ea5u c\u00e2u, th\u1eadm ch\u00ed l\u00e0 emoji \u1edf nhi\u1ec1u ng\u00f4n ng\u1eef.</li> <li>Ki\u1ec3u boolean: <code>bool</code>, d\u00f9ng \u0111\u1ec3 bi\u1ec3u di\u1ec5n quy\u1ebft \u0111\u1ecbnh \"\u0111\u00fang\" ho\u1eb7c \"sai\".</li> </ul> <p>C\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong m\u00e1y t\u00ednh d\u01b0\u1edbi d\u1ea1ng nh\u1ecb ph\u00e2n. M\u1ed9t ch\u1eef s\u1ed1 nh\u1ecb ph\u00e2n l\u00e0 1 bit. Trong h\u1ea7u h\u1ebft h\u1ec7 \u0111i\u1ec1u h\u00e0nh hi\u1ec7n \u0111\u1ea1i, 1 byte g\u1ed3m 8 bit.</p> <p>Gi\u00e1 tr\u1ecb m\u00e0 ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n c\u00f3 th\u1ec3 bi\u1ec3u di\u1ec5n ph\u1ee5 thu\u1ed9c v\u00e0o k\u00edch th\u01b0\u1edbc b\u1ed9 nh\u1edb m\u00e0 n\u00f3 chi\u1ebfm. D\u01b0\u1edbi \u0111\u00e2y, ch\u00fang ta l\u1ea5y Java l\u00e0m v\u00ed d\u1ee5.</p> <ul> <li>Ki\u1ec3u s\u1ed1 nguy\u00ean <code>byte</code> chi\u1ebfm 1 byte = 8 bit v\u00e0 c\u00f3 th\u1ec3 bi\u1ec3u di\u1ec5n \\(2^8\\) s\u1ed1.</li> <li>Ki\u1ec3u s\u1ed1 nguy\u00ean <code>int</code> chi\u1ebfm 4 byte = 32 bit v\u00e0 c\u00f3 th\u1ec3 bi\u1ec3u di\u1ec5n \\(2^{32}\\) s\u1ed1.</li> </ul> <p>B\u1ea3ng sau li\u1ec7t k\u00ea k\u00edch th\u01b0\u1edbc b\u1ed9 nh\u1edb, ph\u1ea1m vi gi\u00e1 tr\u1ecb v\u00e0 gi\u00e1 tr\u1ecb m\u1eb7c \u0111\u1ecbnh c\u1ee7a c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n trong Java. B\u1ea1n kh\u00f4ng c\u1ea7n ph\u1ea3i ghi nh\u1edb b\u1ea3ng n\u00e0y, ch\u1ec9 c\u1ea7n hi\u1ec3u t\u1ed5ng qu\u00e1t v\u00e0 tra c\u1ee9u khi c\u1ea7n.</p> <p> B\u1ea3ng  \u00a0 K\u00edch th\u01b0\u1edbc b\u1ed9 nh\u1edb v\u00e0 ph\u1ea1m vi gi\u00e1 tr\u1ecb c\u1ee7a c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n </p> Ki\u1ec3u K\u00fd hi\u1ec7u K\u00edch th\u01b0\u1edbc Gi\u00e1 tr\u1ecb nh\u1ecf nh\u1ea5t Gi\u00e1 tr\u1ecb l\u1edbn nh\u1ea5t Gi\u00e1 tr\u1ecb m\u1eb7c \u0111\u1ecbnh S\u1ed1 nguy\u00ean <code>byte</code> 1 byte \\(-2^7\\) (\\(-128\\)) \\(2^7 - 1\\) (\\(127\\)) 0 <code>short</code> 2 byte \\(-2^{15}\\) \\(2^{15} - 1\\) 0 <code>int</code> 4 byte \\(-2^{31}\\) \\(2^{31} - 1\\) 0 <code>long</code> 8 byte \\(-2^{63}\\) \\(2^{63} - 1\\) 0 S\u1ed1 th\u1ef1c <code>float</code> 4 byte \\(1.175 \\times 10^{-38}\\) \\(3.403 \\times 10^{38}\\) \\(0.0\\text{f}\\) <code>double</code> 8 byte \\(2.225 \\times 10^{-308}\\) \\(1.798 \\times 10^{308}\\) 0.0 K\u00fd t\u1ef1 <code>char</code> 2 byte 0 \\(2^{16} - 1\\) 0 Boolean <code>bool</code> 1 byte \\(\\text{false}\\) \\(\\text{true}\\) \\(\\text{false}\\) <p>L\u01b0u \u00fd r\u1eb1ng b\u1ea3ng tr\u00ean ch\u1ec9 \u00e1p d\u1ee5ng cho c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n c\u1ee7a Java. M\u1ed7i ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh \u0111\u1ec1u c\u00f3 \u0111\u1ecbnh ngh\u0129a ki\u1ec3u d\u1eef li\u1ec7u ri\u00eang, c\u00f3 th\u1ec3 kh\u00e1c v\u1ec1 k\u00edch th\u01b0\u1edbc, ph\u1ea1m vi gi\u00e1 tr\u1ecb v\u00e0 gi\u00e1 tr\u1ecb m\u1eb7c \u0111\u1ecbnh.</p> <ul> <li>Trong Python, ki\u1ec3u s\u1ed1 nguy\u00ean <code>int</code> c\u00f3 th\u1ec3 l\u1edbn t\u00f9y \u00fd, ch\u1ec9 gi\u1edbi h\u1ea1n b\u1edfi b\u1ed9 nh\u1edb; ki\u1ec3u s\u1ed1 th\u1ef1c <code>float</code> l\u00e0 s\u1ed1 th\u1ef1c 64 bit; kh\u00f4ng c\u00f3 ki\u1ec3u <code>char</code>, m\u1ed9t k\u00fd t\u1ef1 th\u1ef1c ch\u1ea5t l\u00e0 chu\u1ed7i <code>str</code> c\u00f3 \u0111\u1ed9 d\u00e0i 1.</li> <li>C v\u00e0 C++ kh\u00f4ng quy \u0111\u1ecbnh k\u00edch th\u01b0\u1edbc ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n, n\u00f3 ph\u1ee5 thu\u1ed9c v\u00e0o n\u1ec1n t\u1ea3ng v\u00e0 tr\u00ecnh bi\u00ean d\u1ecbch. B\u1ea3ng tr\u00ean theo m\u00f4 h\u00ecnh d\u1eef li\u1ec7u LP64 data model, d\u00f9ng cho h\u1ec7 \u0111i\u1ec1u h\u00e0nh Unix 64-bit nh\u01b0 Linux v\u00e0 macOS.</li> <li>K\u00edch th\u01b0\u1edbc c\u1ee7a <code>char</code> trong C v\u00e0 C++ l\u00e0 1 byte, c\u00f2n \u1edf nhi\u1ec1u ng\u00f4n ng\u1eef kh\u00e1c th\u00ec ph\u1ee5 thu\u1ed9c v\u00e0o ph\u01b0\u01a1ng ph\u00e1p m\u00e3 h\u00f3a k\u00fd t\u1ef1, s\u1ebd \u0111\u01b0\u1ee3c n\u00f3i r\u00f5 \u1edf ch\u01b0\u01a1ng \"M\u00e3 h\u00f3a k\u00fd t\u1ef1\".</li> <li>D\u00f9 ki\u1ec3u boolean ch\u1ec9 c\u1ea7n 1 bit (0 ho\u1eb7c 1), nh\u01b0ng th\u01b0\u1eddng \u0111\u01b0\u1ee3c l\u01b0u trong b\u1ed9 nh\u1edb l\u00e0 1 byte. L\u00fd do l\u00e0 CPU hi\u1ec7n \u0111\u1ea1i th\u01b0\u1eddng d\u00f9ng 1 byte l\u00e0 \u0111\u01a1n v\u1ecb nh\u1ecf nh\u1ea5t \u0111\u1ec3 truy c\u1eadp b\u1ed9 nh\u1edb.</li> </ul> <p>V\u1eady, ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n li\u00ean quan g\u00ec \u0111\u1ebfn c\u1ea5u tr\u00fac d\u1eef li\u1ec7u? Ch\u00fang ta bi\u1ebft r\u1eb1ng c\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u00e0 c\u00e1ch t\u1ed5 ch\u1ee9c v\u00e0 l\u01b0u tr\u1eef d\u1eef li\u1ec7u trong m\u00e1y t\u00ednh. \u1ede \u0111\u00e2y, tr\u1ecdng t\u00e2m l\u00e0 \"c\u1ea5u tr\u00fac\" ch\u1ee9 kh\u00f4ng ph\u1ea3i \"d\u1eef li\u1ec7u\".</p> <p>N\u1ebfu mu\u1ed1n bi\u1ec3u di\u1ec5n \"m\u1ed9t d\u00e3y s\u1ed1\", ch\u00fang ta th\u01b0\u1eddng ngh\u0129 \u0111\u1ebfn m\u1ea3ng. V\u00ec c\u1ea5u tr\u00fac tuy\u1ebfn t\u00ednh c\u1ee7a m\u1ea3ng gi\u00fap bi\u1ec3u di\u1ec5n s\u1ef1 li\u1ec1n k\u1ec1 v\u00e0 th\u1ee9 t\u1ef1 c\u1ee7a c\u00e1c s\u1ed1, c\u00f2n vi\u1ec7c l\u01b0u tr\u1eef l\u00e0 s\u1ed1 nguy\u00ean <code>int</code>, s\u1ed1 th\u1ef1c <code>float</code> hay k\u00fd t\u1ef1 <code>char</code> th\u00ec kh\u00f4ng li\u00ean quan \u0111\u1ebfn \"c\u1ea5u tr\u00fac d\u1eef li\u1ec7u\".</p> <p>N\u00f3i c\u00e1ch kh\u00e1c, ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n cung c\u1ea5p \"ki\u1ec3u n\u1ed9i dung\" c\u1ee7a d\u1eef li\u1ec7u, c\u00f2n c\u1ea5u tr\u00fac d\u1eef li\u1ec7u cung c\u1ea5p \"c\u00e1ch t\u1ed5 ch\u1ee9c\" d\u1eef li\u1ec7u. V\u00ed d\u1ee5, trong \u0111o\u1ea1n m\u00e3 d\u01b0\u1edbi \u0111\u00e2y, ch\u00fang ta d\u00f9ng c\u00f9ng m\u1ed9t c\u1ea5u tr\u00fac d\u1eef li\u1ec7u (m\u1ea3ng) \u0111\u1ec3 l\u01b0u tr\u1eef v\u00e0 bi\u1ec3u di\u1ec5n c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau nh\u01b0 <code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code>, v.v.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code># Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nnumbers: list[int] = [0] * 5\ndecimals: list[float] = [0.0] * 5\n# K\u00fd t\u1ef1 trong Python th\u1ef1c ch\u1ea5t l\u00e0 chu\u1ed7i c\u00f3 \u0111\u1ed9 d\u00e0i 1\ncharacters: list[str] = ['0'] * 5\nbools: list[bool] = [False] * 5\n# List trong Python c\u00f3 th\u1ec3 l\u01b0u tr\u1eef t\u1ef1 do c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n v\u00e0 tham chi\u1ebfu \u0111\u1ed1i t\u01b0\u1ee3ng\ndata = [0, 0.0, 'a', False, ListNode(0)]\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nint numbers[5];\nfloat decimals[5];\nchar characters[5];\nbool bools[5];\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nint[] numbers = new int[5];\nfloat[] decimals = new float[5];\nchar[] characters = new char[5];\nboolean[] bools = new boolean[5];\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nint[] numbers = new int[5];\nfloat[] decimals = new int[5];\nchar[] characters = new char[5];\nbool[] bools = new bool[5];\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nvar numbers = [5]int{}\nvar decimals = [5]float64{}\nvar characters = [5]byte{}\nvar bools = [5]bool{}\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nlet numbers = Array(repeating: 0, count: 5)\nlet decimals = Array(repeating: 0.0, count: 5)\nlet characters: [Character] = Array(repeating: \"a\", count: 5)\nlet bools = Array(repeating: false, count: 5)\n</code></pre> <pre><code>// M\u1ea3ng trong JavaScript c\u00f3 th\u1ec3 l\u01b0u tr\u1eef t\u1ef1 do c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n v\u00e0 \u0111\u1ed1i t\u01b0\u1ee3ng\nconst array = [0, 0.0, 'a', false];\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nconst numbers: number[] = [];\nconst characters: string[] = [];\nconst bools: boolean[] = [];\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nList&lt;int&gt; numbers = List.filled(5, 0);\nList&lt;double&gt; decimals = List.filled(5, 0.0);\nList&lt;String&gt; characters = List.filled(5, 'a');\nList&lt;bool&gt; bools = List.filled(5, false);\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nlet numbers: Vec&lt;i32&gt; = vec![0; 5];\nlet decimals: Vec&lt;f32&gt; = vec![0.0, 5];\nlet characters: Vec&lt;char&gt; = vec!['0'; 5];\nlet bools: Vec&lt;bool&gt; = vec![false; 5];\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nint numbers[10];\nfloat decimals[10];\nchar characters[10];\nbool bools[10];\n</code></pre> <pre><code>\n</code></pre> <pre><code>// Kh\u1edfi t\u1ea1o m\u1ea3ng v\u1edbi c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n kh\u00e1c nhau\nvar numbers: [5]i32 = undefined;\nvar decimals: [5]f32 = undefined;\nvar characters: [5]u8 = undefined;\nvar bools: [5]bool = undefined;\n</code></pre>"},{"location":"chapter_data_structure/character_encoding/","title":"3.4 Character encoding *","text":""},{"location":"chapter_data_structure/character_encoding/#ma-hoa-ky-tu","title":"M\u00e3 h\u00f3a k\u00fd t\u1ef1 *","text":"<p>Trong h\u1ec7 th\u1ed1ng m\u00e1y t\u00ednh, t\u1ea5t c\u1ea3 d\u1eef li\u1ec7u \u0111\u1ec1u \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef d\u01b0\u1edbi d\u1ea1ng nh\u1ecb ph\u00e2n, v\u00e0 <code>char</code> c\u0169ng kh\u00f4ng ngo\u1ea1i l\u1ec7. \u0110\u1ec3 bi\u1ec3u di\u1ec5n k\u00fd t\u1ef1, ch\u00fang ta c\u1ea7n ph\u00e1t tri\u1ec3n m\u1ed9t \"b\u1ed9 k\u00fd t\u1ef1\" \u0111\u1ecbnh ngh\u0129a \u00e1nh x\u1ea1 m\u1ed9t-m\u1ed9t gi\u1eefa m\u1ed7i k\u00fd t\u1ef1 v\u00e0 s\u1ed1 nh\u1ecb ph\u00e2n. V\u1edbi b\u1ed9 k\u00fd t\u1ef1, m\u00e1y t\u00ednh c\u00f3 th\u1ec3 chuy\u1ec3n \u0111\u1ed5i s\u1ed1 nh\u1ecb ph\u00e2n th\u00e0nh k\u00fd t\u1ef1 b\u1eb1ng c\u00e1ch tra c\u1ee9u b\u1ea3ng.</p>"},{"location":"chapter_data_structure/character_encoding/#bo-ky-tu-ascii","title":"B\u1ed9 k\u00fd t\u1ef1 ASCII","text":"<p>M\u00e3 ASCII l\u00e0 m\u1ed9t trong nh\u1eefng b\u1ed9 k\u00fd t\u1ef1 s\u1edbm nh\u1ea5t, ch\u00ednh th\u1ee9c \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 American Standard Code for Information Interchange. N\u00f3 s\u1eed d\u1ee5ng 7 bit nh\u1ecb ph\u00e2n (7 bit th\u1ea5p h\u01a1n c\u1ee7a m\u1ed9t byte) \u0111\u1ec3 bi\u1ec3u di\u1ec5n m\u1ed9t k\u00fd t\u1ef1, cho ph\u00e9p t\u1ed1i \u0111a 128 k\u00fd t\u1ef1 kh\u00e1c nhau. Nh\u01b0 h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y, ASCII bao g\u1ed3m ch\u1eef c\u00e1i in hoa v\u00e0 in th\u01b0\u1eddng ti\u1ebfng Anh, s\u1ed1 t\u1eeb 0 \u0111\u1ebfn 9, c\u00e1c d\u1ea5u ch\u1ea5m c\u00e2u kh\u00e1c nhau, v\u00e0 m\u1ed9t s\u1ed1 k\u00fd t\u1ef1 \u0111i\u1ec1u khi\u1ec3n (nh\u01b0 d\u00f2ng m\u1edbi v\u00e0 tab).</p> <p></p> <p>Tuy nhi\u00ean, ASCII ch\u1ec9 c\u00f3 th\u1ec3 bi\u1ec3u di\u1ec5n k\u00fd t\u1ef1 ti\u1ebfng Anh. V\u1edbi s\u1ef1 to\u00e0n c\u1ea7u h\u00f3a c\u1ee7a m\u00e1y t\u00ednh, m\u1ed9t b\u1ed9 k\u00fd t\u1ef1 g\u1ecdi l\u00e0 EASCII \u0111\u00e3 \u0111\u01b0\u1ee3c ph\u00e1t tri\u1ec3n \u0111\u1ec3 bi\u1ec3u di\u1ec5n nhi\u1ec1u ng\u00f4n ng\u1eef h\u01a1n. N\u00f3 m\u1edf r\u1ed9ng t\u1eeb c\u1ea5u tr\u00fac 7 bit c\u1ee7a ASCII th\u00e0nh 8 bit, cho ph\u00e9p bi\u1ec3u di\u1ec5n 256 k\u00fd t\u1ef1.</p> <p>Tr\u00ean to\u00e0n c\u1ea7u, nhi\u1ec1u b\u1ed9 k\u00fd t\u1ef1 EASCII d\u00e0nh ri\u00eang cho t\u1eebng khu v\u1ef1c \u0111\u00e3 \u0111\u01b0\u1ee3c gi\u1edbi thi\u1ec7u. 128 k\u00fd t\u1ef1 \u0111\u1ea7u ti\u00ean c\u1ee7a c\u00e1c b\u1ed9 n\u00e0y nh\u1ea5t qu\u00e1n v\u1edbi ASCII, trong khi 128 k\u00fd t\u1ef1 c\u00f2n l\u1ea1i \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a kh\u00e1c nhau \u0111\u1ec3 \u0111\u00e1p \u1ee9ng y\u00eau c\u1ea7u c\u1ee7a c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c nhau.</p>"},{"location":"chapter_data_structure/character_encoding/#bo-ky-tu-gbk","title":"B\u1ed9 k\u00fd t\u1ef1 GBK","text":"<p>Sau \u0111\u00f3, ng\u01b0\u1eddi ta ph\u00e1t hi\u1ec7n r\u1eb1ng EASCII v\u1eabn kh\u00f4ng th\u1ec3 \u0111\u00e1p \u1ee9ng y\u00eau c\u1ea7u k\u00fd t\u1ef1 c\u1ee7a nhi\u1ec1u ng\u00f4n ng\u1eef. V\u00ed d\u1ee5, c\u00f3 g\u1ea7n tr\u0103m ngh\u00ecn k\u00fd t\u1ef1 Trung Qu\u1ed1c, v\u1edbi v\u00e0i ngh\u00ecn k\u00fd t\u1ef1 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng th\u01b0\u1eddng xuy\u00ean. N\u0103m 1980, C\u01a1 quan Ti\u00eau chu\u1ea9n h\u00f3a Trung Qu\u1ed1c \u0111\u00e3 ph\u00e1t h\u00e0nh b\u1ed9 k\u00fd t\u1ef1 GB2312, bao g\u1ed3m 6763 k\u00fd t\u1ef1 Trung Qu\u1ed1c, v\u1ec1 c\u01a1 b\u1ea3n \u0111\u00e1p \u1ee9ng nhu c\u1ea7u x\u1eed l\u00fd m\u00e1y t\u00ednh cho ng\u00f4n ng\u1eef Trung Qu\u1ed1c.</p> <p>Tuy nhi\u00ean, GB2312 kh\u00f4ng th\u1ec3 x\u1eed l\u00fd m\u1ed9t s\u1ed1 k\u00fd t\u1ef1 hi\u1ebfm v\u00e0 truy\u1ec1n th\u1ed1ng. B\u1ed9 k\u00fd t\u1ef1 GBK m\u1edf r\u1ed9ng GB2312 v\u00e0 bao g\u1ed3m 21886 k\u00fd t\u1ef1 Trung Qu\u1ed1c. Trong l\u01b0\u1ee3c \u0111\u1ed3 m\u00e3 h\u00f3a GBK, k\u00fd t\u1ef1 ASCII \u0111\u01b0\u1ee3c bi\u1ec3u di\u1ec5n b\u1eb1ng m\u1ed9t byte, trong khi k\u00fd t\u1ef1 Trung Qu\u1ed1c s\u1eed d\u1ee5ng hai byte.</p>"},{"location":"chapter_data_structure/character_encoding/#bo-ky-tu-unicode","title":"B\u1ed9 k\u00fd t\u1ef1 Unicode","text":"<p>V\u1edbi s\u1ef1 ph\u00e1t tri\u1ec3n nhanh ch\u00f3ng c\u1ee7a c\u00f4ng ngh\u1ec7 m\u00e1y t\u00ednh v\u00e0 v\u00f4 s\u1ed1 b\u1ed9 k\u00fd t\u1ef1 v\u00e0 ti\u00eau chu\u1ea9n m\u00e3 h\u00f3a, nhi\u1ec1u v\u1ea5n \u0111\u1ec1 \u0111\u00e3 n\u1ea3y sinh. M\u1ed9t m\u1eb7t, c\u00e1c b\u1ed9 k\u00fd t\u1ef1 n\u00e0y th\u01b0\u1eddng ch\u1ec9 \u0111\u1ecbnh ngh\u0129a k\u00fd t\u1ef1 cho c\u00e1c ng\u00f4n ng\u1eef c\u1ee5 th\u1ec3 v\u00e0 kh\u00f4ng th\u1ec3 ho\u1ea1t \u0111\u1ed9ng \u0111\u00fang trong m\u00f4i tr\u01b0\u1eddng \u0111a ng\u00f4n ng\u1eef. M\u1eb7t kh\u00e1c, s\u1ef1 t\u1ed3n t\u1ea1i c\u1ee7a nhi\u1ec1u ti\u00eau chu\u1ea9n b\u1ed9 k\u00fd t\u1ef1 cho c\u00f9ng m\u1ed9t ng\u00f4n ng\u1eef g\u00e2y ra hi\u1ec7n t\u01b0\u1ee3ng v\u0103n b\u1ea3n b\u1ecb l\u1ed7i khi trao \u0111\u1ed5i th\u00f4ng tin gi\u1eefa c\u00e1c m\u00e1y t\u00ednh s\u1eed d\u1ee5ng ti\u00eau chu\u1ea9n m\u00e3 h\u00f3a kh\u00e1c nhau.</p> <p>C\u00e1c nh\u00e0 nghi\u00ean c\u1ee9u th\u1eddi \u0111\u00f3 ngh\u0129: N\u1ebfu ch\u00fang ta ph\u00e1t tri\u1ec3n m\u1ed9t b\u1ed9 k\u00fd t\u1ef1 to\u00e0n di\u1ec7n bao g\u1ed3m t\u1ea5t c\u1ea3 ng\u00f4n ng\u1eef v\u00e0 k\u00fd hi\u1ec7u to\u00e0n c\u1ea7u th\u00ec sao? \u0110i\u1ec1u n\u00e0y c\u00f3 gi\u1ea3i quy\u1ebft c\u00e1c v\u1ea5n \u0111\u1ec1 li\u00ean quan \u0111\u1ebfn m\u00f4i tr\u01b0\u1eddng \u0111a ng\u00f4n ng\u1eef v\u00e0 v\u0103n b\u1ea3n b\u1ecb l\u1ed7i kh\u00f4ng? L\u1ea5y c\u1ea3m h\u1ee9ng t\u1eeb \u00fd t\u01b0\u1edfng n\u00e0y, b\u1ed9 k\u00fd t\u1ef1 r\u1ed9ng l\u1edbn, Unicode, \u0111\u00e3 ra \u0111\u1eddi.</p> <p>Unicode \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 \"\u7edf\u4e00\u7801\" (Unified Code) b\u1eb1ng ti\u1ebfng Trung, v\u1ec1 l\u00fd thuy\u1ebft c\u00f3 th\u1ec3 ch\u1ee9a h\u01a1n m\u1ed9t tri\u1ec7u k\u00fd t\u1ef1. N\u00f3 nh\u1eb1m m\u1ee5c \u0111\u00edch k\u1ebft h\u1ee3p c\u00e1c k\u00fd t\u1ef1 t\u1eeb kh\u1eafp n\u01a1i tr\u00ean th\u1ebf gi\u1edbi v\u00e0o m\u1ed9t b\u1ed9 duy nh\u1ea5t, cung c\u1ea5p b\u1ed9 k\u00fd t\u1ef1 ph\u1ed5 qu\u00e1t \u0111\u1ec3 x\u1eed l\u00fd v\u00e0 hi\u1ec3n th\u1ecb c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c nhau, gi\u1ea3m thi\u1ec3u c\u00e1c v\u1ea5n \u0111\u1ec1 v\u1ec1 v\u0103n b\u1ea3n b\u1ecb l\u1ed7i do c\u00e1c ti\u00eau chu\u1ea9n m\u00e3 h\u00f3a kh\u00e1c nhau.</p> <p>K\u1ec3 t\u1eeb khi ph\u00e1t h\u00e0nh n\u0103m 1991, Unicode \u0111\u00e3 li\u00ean t\u1ee5c m\u1edf r\u1ed9ng \u0111\u1ec3 bao g\u1ed3m c\u00e1c ng\u00f4n ng\u1eef v\u00e0 k\u00fd t\u1ef1 m\u1edbi. T\u00ednh \u0111\u1ebfn th\u00e1ng 9 n\u0103m 2022, Unicode ch\u1ee9a 149.186 k\u00fd t\u1ef1, bao g\u1ed3m k\u00fd t\u1ef1, k\u00fd hi\u1ec7u, v\u00e0 th\u1eadm ch\u00ed c\u1ea3 emoji t\u1eeb c\u00e1c ng\u00f4n ng\u1eef kh\u00e1c nhau. Trong b\u1ed9 k\u00fd t\u1ef1 Unicode r\u1ed9ng l\u1edbn, c\u00e1c k\u00fd t\u1ef1 th\u01b0\u1eddng d\u00f9ng chi\u1ebfm 2 byte, trong khi m\u1ed9t s\u1ed1 k\u00fd t\u1ef1 hi\u1ebfm c\u00f3 th\u1ec3 chi\u1ebfm 3 ho\u1eb7c th\u1eadm ch\u00ed 4 byte.</p> <p>Unicode l\u00e0 b\u1ed9 k\u00fd t\u1ef1 ph\u1ed5 qu\u00e1t g\u00e1n m\u1ed9t s\u1ed1 (g\u1ecdi l\u00e0 \"\u0111i\u1ec3m m\u00e3\") cho m\u1ed7i k\u00fd t\u1ef1, nh\u01b0ng n\u00f3 kh\u00f4ng ch\u1ec9 \u0111\u1ecbnh c\u00e1ch c\u00e1c \u0111i\u1ec3m m\u00e3 k\u00fd t\u1ef1 Unicode n\u00e0y n\u00ean \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong h\u1ec7 th\u1ed1ng m\u00e1y t\u00ednh. Ng\u01b0\u1eddi ta c\u00f3 th\u1ec3 h\u1ecfi: L\u00e0m th\u1ebf n\u00e0o h\u1ec7 th\u1ed1ng di\u1ec5n gi\u1ea3i c\u00e1c \u0111i\u1ec3m m\u00e3 Unicode c\u00f3 \u0111\u1ed9 d\u00e0i kh\u00e1c nhau trong m\u1ed9t v\u0103n b\u1ea3n? V\u00ed d\u1ee5, v\u1edbi m\u1ed9t m\u00e3 2 byte, l\u00e0m th\u1ebf n\u00e0o h\u1ec7 th\u1ed1ng x\u00e1c \u0111\u1ecbnh n\u00f3 bi\u1ec3u di\u1ec5n m\u1ed9t k\u00fd t\u1ef1 2 byte \u0111\u01a1n l\u1ebb hay hai k\u00fd t\u1ef1 1 byte?</p> <p>M\u1ed9t gi\u1ea3i ph\u00e1p \u0111\u01a1n gi\u1ea3n cho v\u1ea5n \u0111\u1ec1 n\u00e0y l\u00e0 l\u01b0u tr\u1eef t\u1ea5t c\u1ea3 k\u00fd t\u1ef1 d\u01b0\u1edbi d\u1ea1ng m\u00e3 h\u00f3a \u0111\u1ed9 d\u00e0i b\u1eb1ng nhau. Nh\u01b0 h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y, m\u1ed7i k\u00fd t\u1ef1 trong \"Hello\" chi\u1ebfm 1 byte, trong khi m\u1ed7i k\u00fd t\u1ef1 trong \"\u7b97\u6cd5\" (algorithm) chi\u1ebfm 2 byte. Ch\u00fang ta c\u00f3 th\u1ec3 m\u00e3 h\u00f3a t\u1ea5t c\u1ea3 k\u00fd t\u1ef1 trong \"Hello \u7b97\u6cd5\" th\u00e0nh 2 byte b\u1eb1ng c\u00e1ch \u0111\u1ec7m c\u00e1c bit cao h\u01a1n b\u1eb1ng s\u1ed1 kh\u00f4ng. Ph\u01b0\u01a1ng ph\u00e1p n\u00e0y s\u1ebd cho ph\u00e9p h\u1ec7 th\u1ed1ng di\u1ec5n gi\u1ea3i m\u1ed9t k\u00fd t\u1ef1 m\u1ed7i 2 byte, kh\u00f4i ph\u1ee5c n\u1ed9i dung c\u1ee7a c\u1ee5m t\u1eeb.</p> <p></p> <p>Tuy nhi\u00ean, nh\u01b0 ASCII \u0111\u00e3 cho ch\u00fang ta th\u1ea5y, m\u00e3 h\u00f3a ti\u1ebfng Anh ch\u1ec9 c\u1ea7n 1 byte. S\u1eed d\u1ee5ng ph\u01b0\u01a1ng ph\u00e1p tr\u00ean s\u1ebd l\u00e0m t\u0103ng g\u1ea5p \u0111\u00f4i kh\u00f4ng gian chi\u1ebfm b\u1edfi v\u0103n b\u1ea3n ti\u1ebfng Anh so v\u1edbi m\u00e3 h\u00f3a ASCII, \u0111i\u1ec1u n\u00e0y l\u00e3ng ph\u00ed kh\u00f4ng gian b\u1ed9 nh\u1edb. Do \u0111\u00f3, c\u1ea7n m\u1ed9t ph\u01b0\u01a1ng ph\u00e1p m\u00e3 h\u00f3a Unicode hi\u1ec7u qu\u1ea3 h\u01a1n.</p>"},{"location":"chapter_data_structure/character_encoding/#ma-hoa-utf-8","title":"M\u00e3 h\u00f3a UTF-8","text":"<p>Hi\u1ec7n t\u1ea1i, UTF-8 \u0111\u00e3 tr\u1edf th\u00e0nh ph\u01b0\u01a1ng ph\u00e1p m\u00e3 h\u00f3a Unicode \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng r\u1ed9ng r\u00e3i nh\u1ea5t tr\u00ean to\u00e0n c\u1ea7u. N\u00f3 l\u00e0 m\u00e3 h\u00f3a \u0111\u1ed9 d\u00e0i bi\u1ebfn \u0111\u1ed5i, s\u1eed d\u1ee5ng 1 \u0111\u1ebfn 4 byte \u0111\u1ec3 bi\u1ec3u di\u1ec5n m\u1ed9t k\u00fd t\u1ef1, t\u00f9y thu\u1ed9c v\u00e0o \u0111\u1ed9 ph\u1ee9c t\u1ea1p c\u1ee7a k\u00fd t\u1ef1. K\u00fd t\u1ef1 ASCII ch\u1ec9 c\u1ea7n 1 byte, ch\u1eef c\u00e1i Latin v\u00e0 Hy L\u1ea1p y\u00eau c\u1ea7u 2 byte, k\u00fd t\u1ef1 Trung Qu\u1ed1c th\u01b0\u1eddng d\u00f9ng c\u1ea7n 3 byte, v\u00e0 m\u1ed9t s\u1ed1 k\u00fd t\u1ef1 hi\u1ebfm kh\u00e1c c\u1ea7n 4 byte.</p> <p>C\u00e1c quy t\u1eafc m\u00e3 h\u00f3a cho UTF-8 kh\u00f4ng ph\u1ee9c t\u1ea1p v\u00e0 c\u00f3 th\u1ec3 chia th\u00e0nh hai tr\u01b0\u1eddng h\u1ee3p:</p> <ul> <li>\u0110\u1ed1i v\u1edbi k\u00fd t\u1ef1 1 byte, \u0111\u1eb7t bit cao nh\u1ea5t th\u00e0nh \\(0\\), v\u00e0 7 bit c\u00f2n l\u1ea1i th\u00e0nh \u0111i\u1ec3m m\u00e3 Unicode. \u0110\u1eb7c bi\u1ec7t, k\u00fd t\u1ef1 ASCII chi\u1ebfm 128 \u0111i\u1ec3m m\u00e3 \u0111\u1ea7u ti\u00ean trong b\u1ed9 Unicode. \u0110i\u1ec1u n\u00e0y c\u00f3 ngh\u0129a l\u00e0 m\u00e3 h\u00f3a UTF-8 t\u01b0\u01a1ng th\u00edch ng\u01b0\u1ee3c v\u1edbi ASCII. \u0110i\u1ec1u n\u00e0y ng\u1ee5 \u00fd r\u1eb1ng UTF-8 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 ph\u00e2n t\u00edch v\u0103n b\u1ea3n ASCII c\u1ed5 x\u01b0a.</li> <li>\u0110\u1ed1i v\u1edbi k\u00fd t\u1ef1 c\u00f3 \u0111\u1ed9 d\u00e0i \\(n\\) byte (trong \u0111\u00f3 \\(n &gt; 1\\)), \u0111\u1eb7t \\(n\\) bit cao nh\u1ea5t c\u1ee7a byte \u0111\u1ea7u ti\u00ean th\u00e0nh \\(1\\), v\u00e0 bit \\((n + 1)^{\\text{th}}\\) th\u00e0nh \\(0\\); b\u1eaft \u0111\u1ea7u t\u1eeb byte th\u1ee9 hai, \u0111\u1eb7t 2 bit cao nh\u1ea5t c\u1ee7a m\u1ed7i byte th\u00e0nh \\(10\\); c\u00e1c bit c\u00f2n l\u1ea1i \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 \u0111i\u1ec1n \u0111i\u1ec3m m\u00e3 Unicode.</li> </ul> <p>H\u00ecnh d\u01b0\u1edbi \u0111\u00e2y cho th\u1ea5y m\u00e3 h\u00f3a UTF-8 cho \"Hello\u7b97\u6cd5\". C\u00f3 th\u1ec3 quan s\u00e1t th\u1ea5y r\u1eb1ng v\u00ec \\(n\\) bit cao nh\u1ea5t \u0111\u01b0\u1ee3c \u0111\u1eb7t th\u00e0nh \\(1\\), h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 x\u00e1c \u0111\u1ecbnh \u0111\u1ed9 d\u00e0i c\u1ee7a k\u00fd t\u1ef1 l\u00e0 \\(n\\) b\u1eb1ng c\u00e1ch \u0111\u1ebfm s\u1ed1 bit cao nh\u1ea5t \u0111\u01b0\u1ee3c \u0111\u1eb7t th\u00e0nh \\(1\\).</p> <p>Nh\u01b0ng t\u1ea1i sao \u0111\u1eb7t 2 bit cao nh\u1ea5t c\u1ee7a c\u00e1c byte c\u00f2n l\u1ea1i th\u00e0nh \\(10\\)? Th\u1ef1c ra, \\(10\\) n\u00e0y ph\u1ee5c v\u1ee5 nh\u01b0 m\u1ed9t lo\u1ea1i ki\u1ec3m tra t\u1ed5ng. N\u1ebfu h\u1ec7 th\u1ed1ng b\u1eaft \u0111\u1ea7u ph\u00e2n t\u00edch v\u0103n b\u1ea3n t\u1eeb m\u1ed9t byte sai, \\(10\\) \u1edf \u0111\u1ea7u byte c\u00f3 th\u1ec3 gi\u00fap h\u1ec7 th\u1ed1ng nhanh ch\u00f3ng ph\u00e1t hi\u1ec7n b\u1ea5t th\u01b0\u1eddng.</p> <p>L\u00fd do s\u1eed d\u1ee5ng \\(10\\) l\u00e0m ki\u1ec3m tra t\u1ed5ng l\u00e0 v\u00ec, d\u01b0\u1edbi quy t\u1eafc m\u00e3 h\u00f3a UTF-8, kh\u00f4ng th\u1ec3 c\u00f3 2 bit cao nh\u1ea5t c\u1ee7a m\u1ed9t k\u00fd t\u1ef1 l\u00e0 \\(10\\). \u0110i\u1ec1u n\u00e0y c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c ch\u1ee9ng minh b\u1eb1ng m\u00e2u thu\u1eabn: N\u1ebfu 2 bit cao nh\u1ea5t c\u1ee7a m\u1ed9t k\u00fd t\u1ef1 l\u00e0 \\(10\\), n\u00f3 ch\u1ec9 ra \u0111\u1ed9 d\u00e0i k\u00fd t\u1ef1 l\u00e0 \\(1\\), t\u01b0\u01a1ng \u1ee9ng v\u1edbi ASCII. Tuy nhi\u00ean, bit cao nh\u1ea5t c\u1ee7a k\u00fd t\u1ef1 ASCII n\u00ean l\u00e0 \\(0\\), \u0111i\u1ec1u n\u00e0y m\u00e2u thu\u1eabn v\u1edbi gi\u1ea3 \u0111\u1ecbnh.</p> <p></p> <p>Ngo\u00e0i UTF-8, c\u00e1c ph\u01b0\u01a1ng ph\u00e1p m\u00e3 h\u00f3a ph\u1ed5 bi\u1ebfn kh\u00e1c bao g\u1ed3m:</p> <ul> <li>M\u00e3 h\u00f3a UTF-16: S\u1eed d\u1ee5ng 2 ho\u1eb7c 4 byte \u0111\u1ec3 bi\u1ec3u di\u1ec5n m\u1ed9t k\u00fd t\u1ef1. T\u1ea5t c\u1ea3 k\u00fd t\u1ef1 ASCII v\u00e0 k\u00fd t\u1ef1 kh\u00f4ng ti\u1ebfng Anh th\u01b0\u1eddng d\u00f9ng \u0111\u01b0\u1ee3c bi\u1ec3u di\u1ec5n b\u1eb1ng 2 byte; m\u1ed9t v\u00e0i k\u00fd t\u1ef1 y\u00eau c\u1ea7u 4 byte. \u0110\u1ed1i v\u1edbi k\u00fd t\u1ef1 2 byte, m\u00e3 h\u00f3a UTF-16 b\u1eb1ng \u0111i\u1ec3m m\u00e3 Unicode.</li> <li>M\u00e3 h\u00f3a UTF-32: M\u1ed7i k\u00fd t\u1ef1 s\u1eed d\u1ee5ng 4 byte. \u0110i\u1ec1u n\u00e0y c\u00f3 ngh\u0129a l\u00e0 UTF-32 chi\u1ebfm nhi\u1ec1u kh\u00f4ng gian h\u01a1n UTF-8 v\u00e0 UTF-16, \u0111\u1eb7c bi\u1ec7t \u0111\u1ed1i v\u1edbi v\u0103n b\u1ea3n c\u00f3 t\u1ef7 l\u1ec7 cao k\u00fd t\u1ef1 ASCII.</li> </ul> <p>T\u1eeb g\u00f3c \u0111\u1ed9 kh\u00f4ng gian l\u01b0u tr\u1eef, s\u1eed d\u1ee5ng UTF-8 \u0111\u1ec3 bi\u1ec3u di\u1ec5n k\u00fd t\u1ef1 ti\u1ebfng Anh r\u1ea5t hi\u1ec7u qu\u1ea3 v\u00ec n\u00f3 ch\u1ec9 c\u1ea7n 1 byte; s\u1eed d\u1ee5ng UTF-16 \u0111\u1ec3 m\u00e3 h\u00f3a m\u1ed9t s\u1ed1 k\u00fd t\u1ef1 kh\u00f4ng ti\u1ebfng Anh (nh\u01b0 ti\u1ebfng Trung) c\u00f3 th\u1ec3 hi\u1ec7u qu\u1ea3 h\u01a1n v\u00ec n\u00f3 ch\u1ec9 c\u1ea7n 2 byte, trong khi UTF-8 c\u00f3 th\u1ec3 c\u1ea7n 3 byte.</p> <p>T\u1eeb g\u00f3c \u0111\u1ed9 t\u01b0\u01a1ng th\u00edch, UTF-8 l\u00e0 linh ho\u1ea1t nh\u1ea5t, v\u1edbi nhi\u1ec1u c\u00f4ng c\u1ee5 v\u00e0 th\u01b0 vi\u1ec7n h\u1ed7 tr\u1ee3 UTF-8 l\u00e0 \u01b0u ti\u00ean.</p>"},{"location":"chapter_data_structure/character_encoding/#ma-hoa-ky-tu-trong-ngon-ngu-lap-trinh","title":"M\u00e3 h\u00f3a k\u00fd t\u1ef1 trong ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh","text":"<p>L\u1ecbch s\u1eed, nhi\u1ec1u ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh s\u1eed d\u1ee5ng m\u00e3 h\u00f3a \u0111\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh nh\u01b0 UTF-16 ho\u1eb7c UTF-32 \u0111\u1ec3 x\u1eed l\u00fd chu\u1ed7i trong qu\u00e1 tr\u00ecnh th\u1ef1c thi ch\u01b0\u01a1ng tr\u00ecnh. \u0110i\u1ec1u n\u00e0y cho ph\u00e9p x\u1eed l\u00fd chu\u1ed7i nh\u01b0 m\u1ea3ng, mang l\u1ea1i m\u1ed9t s\u1ed1 l\u1ee3i th\u1ebf:</p> <ul> <li>Truy c\u1eadp ng\u1eabu nhi\u00ean: Chu\u1ed7i m\u00e3 h\u00f3a UTF-16 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c truy c\u1eadp ng\u1eabu nhi\u00ean d\u1ec5 d\u00e0ng. \u0110\u1ed1i v\u1edbi UTF-8, l\u00e0 m\u00e3 h\u00f3a \u0111\u1ed9 d\u00e0i bi\u1ebfn \u0111\u1ed5i, vi\u1ec7c \u0111\u1ecbnh v\u1ecb k\u00fd t\u1ef1 \\(i^{\\text{th}}\\) y\u00eau c\u1ea7u duy\u1ec7t chu\u1ed7i t\u1eeb \u0111\u1ea7u \u0111\u1ebfn v\u1ecb tr\u00ed \\(i^{\\text{th}}\\), m\u1ea5t th\u1eddi gian \\(O(n)\\).</li> <li>\u0110\u1ebfm k\u00fd t\u1ef1: T\u01b0\u01a1ng t\u1ef1 nh\u01b0 truy c\u1eadp ng\u1eabu nhi\u00ean, \u0111\u1ebfm s\u1ed1 l\u01b0\u1ee3ng k\u00fd t\u1ef1 trong chu\u1ed7i m\u00e3 h\u00f3a UTF-16 l\u00e0 thao t\u00e1c \\(O(1)\\). Tuy nhi\u00ean, \u0111\u1ebfm k\u00fd t\u1ef1 trong chu\u1ed7i m\u00e3 h\u00f3a UTF-8 y\u00eau c\u1ea7u duy\u1ec7t to\u00e0n b\u1ed9 chu\u1ed7i.</li> <li>Thao t\u00e1c chu\u1ed7i: Nhi\u1ec1u thao t\u00e1c chu\u1ed7i nh\u01b0 t\u00e1ch, n\u1ed1i, ch\u00e8n v\u00e0 x\u00f3a d\u1ec5 d\u00e0ng h\u01a1n tr\u00ean chu\u1ed7i m\u00e3 h\u00f3a UTF-16. C\u00e1c thao t\u00e1c n\u00e0y th\u01b0\u1eddng y\u00eau c\u1ea7u t\u00ednh to\u00e1n b\u1ed5 sung tr\u00ean chu\u1ed7i m\u00e3 h\u00f3a UTF-8 \u0111\u1ec3 \u0111\u1ea3m b\u1ea3o t\u00ednh h\u1ee3p l\u1ec7 c\u1ee7a m\u00e3 h\u00f3a UTF-8.</li> </ul> <p>Thi\u1ebft k\u1ebf l\u01b0\u1ee3c \u0111\u1ed3 m\u00e3 h\u00f3a k\u00fd t\u1ef1 trong ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh l\u00e0 ch\u1ee7 \u0111\u1ec1 th\u00fa v\u1ecb li\u00ean quan \u0111\u1ebfn nhi\u1ec1u y\u1ebfu t\u1ed1:</p> <ul> <li>Ki\u1ec3u <code>String</code> c\u1ee7a Java s\u1eed d\u1ee5ng m\u00e3 h\u00f3a UTF-16, v\u1edbi m\u1ed7i k\u00fd t\u1ef1 chi\u1ebfm 2 byte. \u0110i\u1ec1u n\u00e0y d\u1ef1a tr\u00ean ni\u1ec1m tin ban \u0111\u1ea7u r\u1eb1ng 16 bit \u0111\u1ee7 \u0111\u1ec3 bi\u1ec3u di\u1ec5n t\u1ea5t c\u1ea3 k\u00fd t\u1ef1 c\u00f3 th\u1ec3 v\u00e0 sau \u0111\u00f3 ch\u1ee9ng minh l\u00e0 sai. Khi ti\u00eau chu\u1ea9n Unicode m\u1edf r\u1ed9ng v\u01b0\u1ee3t qu\u00e1 16 bit, k\u00fd t\u1ef1 trong Java c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c bi\u1ec3u di\u1ec5n b\u1eb1ng c\u1eb7p gi\u00e1 tr\u1ecb 16 bit, \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 \"c\u1eb7p thay th\u1ebf.\"</li> <li>JavaScript v\u00e0 TypeScript s\u1eed d\u1ee5ng m\u00e3 h\u00f3a UTF-16 v\u00ec l\u00fd do t\u01b0\u01a1ng t\u1ef1 nh\u01b0 Java. Khi JavaScript \u0111\u01b0\u1ee3c gi\u1edbi thi\u1ec7u l\u1ea7n \u0111\u1ea7u b\u1edfi Netscape n\u0103m 1995, Unicode v\u1eabn \u1edf giai \u0111o\u1ea1n \u0111\u1ea7u, v\u00e0 m\u00e3 h\u00f3a 16 bit \u0111\u1ee7 \u0111\u1ec3 bi\u1ec3u di\u1ec5n t\u1ea5t c\u1ea3 k\u00fd t\u1ef1 Unicode.</li> <li>C# s\u1eed d\u1ee5ng m\u00e3 h\u00f3a UTF-16, ch\u1ee7 y\u1ebfu v\u00ec n\u1ec1n t\u1ea3ng .NET, \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf b\u1edfi Microsoft, v\u00e0 nhi\u1ec1u c\u00f4ng ngh\u1ec7 Microsoft, bao g\u1ed3m h\u1ec7 \u0111i\u1ec1u h\u00e0nh Windows, s\u1eed d\u1ee5ng r\u1ed9ng r\u00e3i m\u00e3 h\u00f3a UTF-16.</li> </ul> <p>Do \u0111\u00e1nh gi\u00e1 th\u1ea5p s\u1ed1 l\u01b0\u1ee3ng k\u00fd t\u1ef1, c\u00e1c ng\u00f4n ng\u1eef n\u00e0y ph\u1ea3i s\u1eed d\u1ee5ng \"c\u1eb7p thay th\u1ebf\" \u0111\u1ec3 bi\u1ec3u di\u1ec5n k\u00fd t\u1ef1 Unicode v\u01b0\u1ee3t qu\u00e1 16 bit. Ph\u01b0\u01a1ng ph\u00e1p n\u00e0y c\u00f3 nh\u01b0\u1ee3c \u0111i\u1ec3m: chu\u1ed7i ch\u1ee9a c\u1eb7p thay th\u1ebf c\u00f3 th\u1ec3 c\u00f3 k\u00fd t\u1ef1 chi\u1ebfm 2 ho\u1eb7c 4 byte, m\u1ea5t l\u1ee3i th\u1ebf c\u1ee7a m\u00e3 h\u00f3a \u0111\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh. Ngo\u00e0i ra, x\u1eed l\u00fd c\u1eb7p thay th\u1ebf th\u00eam \u0111\u1ed9 ph\u1ee9c t\u1ea1p v\u00e0 kh\u00f3 kh\u0103n trong g\u1ee1 l\u1ed7i.</p> <p>Gi\u1ea3i quy\u1ebft nh\u1eefng th\u00e1ch th\u1ee9c n\u00e0y, m\u1ed9t s\u1ed1 ng\u00f4n ng\u1eef \u0111\u00e3 \u00e1p d\u1ee5ng chi\u1ebfn l\u01b0\u1ee3c m\u00e3 h\u00f3a thay th\u1ebf:</p> <ul> <li>Ki\u1ec3u <code>str</code> c\u1ee7a Python s\u1eed d\u1ee5ng m\u00e3 h\u00f3a Unicode v\u1edbi bi\u1ec3u di\u1ec5n linh ho\u1ea1t n\u01a1i \u0111\u1ed9 d\u00e0i l\u01b0u tr\u1eef c\u1ee7a k\u00fd t\u1ef1 ph\u1ee5 thu\u1ed9c v\u00e0o \u0111i\u1ec3m m\u00e3 Unicode l\u1edbn nh\u1ea5t trong chu\u1ed7i. N\u1ebfu t\u1ea5t c\u1ea3 k\u00fd t\u1ef1 l\u00e0 ASCII, m\u1ed7i k\u00fd t\u1ef1 chi\u1ebfm 1 byte, 2 byte cho k\u00fd t\u1ef1 trong M\u1eb7t ph\u1eb3ng \u0111a ng\u00f4n ng\u1eef c\u01a1 b\u1ea3n (BMP), v\u00e0 4 byte cho k\u00fd t\u1ef1 v\u01b0\u1ee3t qu\u00e1 BMP.</li> <li>Ki\u1ec3u <code>string</code> c\u1ee7a Go s\u1eed d\u1ee5ng m\u00e3 h\u00f3a UTF-8 n\u1ed9i b\u1ed9. Go c\u0169ng cung c\u1ea5p ki\u1ec3u <code>rune</code> \u0111\u1ec3 bi\u1ec3u di\u1ec5n \u0111i\u1ec3m m\u00e3 Unicode ri\u00eang l\u1ebb.</li> <li>Ki\u1ec3u <code>str</code> v\u00e0 <code>String</code> c\u1ee7a Rust s\u1eed d\u1ee5ng m\u00e3 h\u00f3a UTF-8 n\u1ed9i b\u1ed9. Rust c\u0169ng cung c\u1ea5p ki\u1ec3u <code>char</code> cho \u0111i\u1ec3m m\u00e3 Unicode ri\u00eang l\u1ebb.</li> </ul> <p>Quan tr\u1ecdng l\u00e0 l\u01b0u \u00fd r\u1eb1ng th\u1ea3o lu\u1eadn tr\u00ean li\u00ean quan \u0111\u1ebfn c\u00e1ch chu\u1ed7i \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh, kh\u00e1c v\u1edbi c\u00e1ch chu\u1ed7i \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong t\u1ec7p ho\u1eb7c truy\u1ec1n qua m\u1ea1ng. \u0110\u1ed1i v\u1edbi l\u01b0u tr\u1eef t\u1ec7p ho\u1eb7c truy\u1ec1n m\u1ea1ng, chu\u1ed7i th\u01b0\u1eddng \u0111\u01b0\u1ee3c m\u00e3 h\u00f3a \u1edf \u0111\u1ecbnh d\u1ea1ng UTF-8 \u0111\u1ec3 t\u1ed1i \u01b0u t\u01b0\u01a1ng th\u00edch v\u00e0 hi\u1ec7u qu\u1ea3 kh\u00f4ng gian.</p>"},{"location":"chapter_data_structure/classification_of_data_structure/","title":"3.1 Classification of data structures","text":""},{"location":"chapter_data_structure/classification_of_data_structure/#phan-loai-cau-truc-du-lieu","title":"Ph\u00e2n lo\u1ea1i c\u1ea5u tr\u00fac d\u1eef li\u1ec7u","text":"<p>C\u00e1c c\u1ea5u tr\u00fac d\u1eef li\u1ec7u ph\u1ed5 bi\u1ebfn g\u1ed3m m\u1ea3ng, danh s\u00e1ch li\u00ean k\u1ebft, ng\u0103n x\u1ebfp, h\u00e0ng \u0111\u1ee3i, b\u1ea3ng b\u0103m, c\u00e2y, heap v\u00e0 \u0111\u1ed3 th\u1ecb. Ch\u00fang c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c ph\u00e2n lo\u1ea1i th\u00e0nh \"c\u1ea5u tr\u00fac logic\" v\u00e0 \"c\u1ea5u tr\u00fac v\u1eadt l\u00fd\".</p>"},{"location":"chapter_data_structure/classification_of_data_structure/#cau-truc-logic-tuyen-tinh-va-phi-tuyen-tinh","title":"C\u1ea5u tr\u00fac logic: tuy\u1ebfn t\u00ednh v\u00e0 phi tuy\u1ebfn t\u00ednh","text":"<p>C\u1ea5u tr\u00fac logic th\u1ec3 hi\u1ec7n m\u1ed1i quan h\u1ec7 logic gi\u1eefa c\u00e1c ph\u1ea7n t\u1eed d\u1eef li\u1ec7u. Trong m\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft, d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo m\u1ed9t tr\u00ecnh t\u1ef1 nh\u1ea5t \u0111\u1ecbnh, th\u1ec3 hi\u1ec7n m\u1ed1i quan h\u1ec7 tuy\u1ebfn t\u00ednh gi\u1eefa c\u00e1c ph\u1ea7n t\u1eed; c\u00f2n trong c\u00e2y, d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo d\u1ea1ng ph\u00e2n c\u1ea5p t\u1eeb tr\u00ean xu\u1ed1ng d\u01b0\u1edbi, th\u1ec3 hi\u1ec7n m\u1ed1i quan h\u1ec7 gi\u1eefa \"t\u1ed5 ti\u00ean\" v\u00e0 \"h\u1eadu du\u1ec7\"; c\u00f2n \u0111\u1ed3 th\u1ecb g\u1ed3m c\u00e1c n\u00fat v\u00e0 c\u1ea1nh, ph\u1ea3n \u00e1nh m\u1ed1i quan h\u1ec7 m\u1ea1ng l\u01b0\u1edbi ph\u1ee9c t\u1ea1p.</p> <p>Nh\u01b0 h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y, c\u1ea5u tr\u00fac logic c\u00f3 th\u1ec3 chia th\u00e0nh hai lo\u1ea1i l\u1edbn: \"tuy\u1ebfn t\u00ednh\" v\u00e0 \"phi tuy\u1ebfn t\u00ednh\". C\u1ea5u tr\u00fac tuy\u1ebfn t\u00ednh d\u1ec5 h\u00ecnh dung h\u01a1n, cho th\u1ea5y d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo quan h\u1ec7 tuy\u1ebfn t\u00ednh; ng\u01b0\u1ee3c l\u1ea1i, c\u1ea5u tr\u00fac phi tuy\u1ebfn t\u00ednh \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp kh\u00f4ng theo tuy\u1ebfn t\u00ednh.</p> <ul> <li>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u tuy\u1ebfn t\u00ednh: M\u1ea3ng, Danh s\u00e1ch li\u00ean k\u1ebft, Ng\u0103n x\u1ebfp, H\u00e0ng \u0111\u1ee3i, B\u1ea3ng b\u0103m.</li> <li>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u phi tuy\u1ebfn t\u00ednh: C\u00e2y, Heap, \u0110\u1ed3 th\u1ecb, B\u1ea3ng b\u0103m.</li> </ul> <p>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u phi tuy\u1ebfn t\u00ednh c\u00f3 th\u1ec3 chia nh\u1ecf th\u00e0nh c\u1ea5u tr\u00fac c\u00e2y v\u00e0 c\u1ea5u tr\u00fac m\u1ea1ng.</p> <ul> <li>C\u1ea5u tr\u00fac c\u00e2y: C\u00e2y, Heap, B\u1ea3ng b\u0103m, n\u01a1i c\u00e1c ph\u1ea7n t\u1eed c\u00f3 quan h\u1ec7 m\u1ed9t-nhi\u1ec1u.</li> <li>C\u1ea5u tr\u00fac m\u1ea1ng: \u0110\u1ed3 th\u1ecb, n\u01a1i c\u00e1c ph\u1ea7n t\u1eed c\u00f3 quan h\u1ec7 nhi\u1ec1u-nhi\u1ec1u.</li> </ul> <p></p>"},{"location":"chapter_data_structure/classification_of_data_structure/#cau-truc-vat-ly-lien-tuc-va-phan-tan","title":"C\u1ea5u tr\u00fac v\u1eadt l\u00fd: li\u00ean t\u1ee5c v\u00e0 ph\u00e2n t\u00e1n","text":"<p>Khi thu\u1eadt to\u00e1n th\u1ef1c thi, d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c x\u1eed l\u00fd s\u1ebd l\u01b0u trong b\u1ed9 nh\u1edb. H\u00ecnh d\u01b0\u1edbi \u0111\u00e2y l\u00e0 m\u1ed9t thanh RAM m\u00e1y t\u00ednh, m\u1ed7i \u00f4 vu\u00f4ng m\u00e0u \u0111en l\u00e0 m\u1ed9t v\u00f9ng nh\u1edb v\u1eadt l\u00fd. B\u1ea1n c\u00f3 th\u1ec3 h\u00ecnh dung b\u1ed9 nh\u1edb nh\u01b0 m\u1ed9t b\u1ea3ng Excel l\u1edbn, m\u1ed7i \u00f4 c\u00f3 th\u1ec3 l\u01b0u tr\u1eef m\u1ed9t l\u01b0\u1ee3ng d\u1eef li\u1ec7u nh\u1ea5t \u0111\u1ecbnh.</p> <p>H\u1ec7 th\u1ed1ng truy c\u1eadp d\u1eef li\u1ec7u t\u1ea1i v\u1ecb tr\u00ed m\u1ee5c ti\u00eau th\u00f4ng qua \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb. Nh\u01b0 h\u00ecnh d\u01b0\u1edbi, m\u00e1y t\u00ednh g\u00e1n m\u1ed9t m\u00e3 \u0111\u1ecbnh danh duy nh\u1ea5t cho m\u1ed7i \u00f4 trong b\u1ea3ng theo quy t\u1eafc nh\u1ea5t \u0111\u1ecbnh, \u0111\u1ea3m b\u1ea3o m\u1ed7i v\u00f9ng nh\u1edb c\u00f3 m\u1ed9t \u0111\u1ecba ch\u1ec9 b\u1ed9 nh\u1edb ri\u00eang bi\u1ec7t. Nh\u1edd c\u00e1c \u0111\u1ecba ch\u1ec9 n\u00e0y, ch\u01b0\u01a1ng tr\u00ecnh c\u00f3 th\u1ec3 truy c\u1eadp d\u1eef li\u1ec7u l\u01b0u trong b\u1ed9 nh\u1edb.</p> <p></p> <p>Tip</p> <p>Vi\u1ec7c so s\u00e1nh b\u1ed9 nh\u1edb v\u1edbi b\u1ea3ng Excel ch\u1ec9 l\u00e0 v\u00ed d\u1ee5 \u0111\u01a1n gi\u1ea3n. Th\u1ef1c t\u1ebf, c\u01a1 ch\u1ebf ho\u1ea1t \u0111\u1ed9ng c\u1ee7a b\u1ed9 nh\u1edb ph\u1ee9c t\u1ea1p h\u01a1n, li\u00ean quan \u0111\u1ebfn kh\u00f4ng gian \u0111\u1ecba ch\u1ec9, qu\u1ea3n l\u00fd b\u1ed9 nh\u1edb, b\u1ed9 nh\u1edb \u0111\u1ec7m, b\u1ed9 nh\u1edb \u1ea3o v\u00e0 b\u1ed9 nh\u1edb v\u1eadt l\u00fd.</p> <p>B\u1ed9 nh\u1edb l\u00e0 t\u00e0i nguy\u00ean d\u00f9ng chung cho m\u1ecdi ch\u01b0\u01a1ng tr\u00ecnh. Khi m\u1ed9t v\u00f9ng nh\u1edb b\u1ecb chi\u1ebfm b\u1edfi m\u1ed9t ch\u01b0\u01a1ng tr\u00ecnh, ch\u01b0\u01a1ng tr\u00ecnh kh\u00e1c kh\u00f4ng th\u1ec3 s\u1eed d\u1ee5ng v\u00f9ng \u0111\u00f3 c\u00f9ng l\u00fac. V\u00ec v\u1eady, vi\u1ec7c c\u00e2n nh\u1eafc t\u00e0i nguy\u00ean b\u1ed9 nh\u1edb r\u1ea5t quan tr\u1ecdng khi thi\u1ebft k\u1ebf c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n. V\u00ed d\u1ee5, l\u01b0\u1ee3ng b\u1ed9 nh\u1edb t\u1ed1i \u0111a thu\u1eadt to\u00e1n s\u1eed d\u1ee5ng kh\u00f4ng \u0111\u01b0\u1ee3c v\u01b0\u1ee3t qu\u00e1 b\u1ed9 nh\u1edb c\u00f2n tr\u1ed1ng c\u1ee7a h\u1ec7 th\u1ed1ng; n\u1ebfu thi\u1ebfu c\u00e1c v\u00f9ng nh\u1edb li\u00ean t\u1ee5c, c\u1ea5u tr\u00fac d\u1eef li\u1ec7u ch\u1ecdn ph\u1ea3i c\u00f3 kh\u1ea3 n\u0103ng l\u01b0u tr\u1eef \u1edf c\u00e1c v\u00f9ng nh\u1edb kh\u00f4ng li\u00ean t\u1ee5c.</p> <p>Nh\u01b0 h\u00ecnh d\u01b0\u1edbi, c\u1ea5u tr\u00fac v\u1eadt l\u00fd th\u1ec3 hi\u1ec7n c\u00e1ch d\u1eef li\u1ec7u \u0111\u01b0\u1ee3c l\u01b0u trong b\u1ed9 nh\u1edb m\u00e1y t\u00ednh v\u00e0 c\u00f3 th\u1ec3 chia th\u00e0nh l\u01b0u tr\u1eef \u1edf v\u00f9ng li\u00ean t\u1ee5c (m\u1ea3ng) v\u00e0 l\u01b0u tr\u1eef \u1edf v\u00f9ng kh\u00f4ng li\u00ean t\u1ee5c (danh s\u00e1ch li\u00ean k\u1ebft). Hai ki\u1ec3u c\u1ea5u tr\u00fac v\u1eadt l\u00fd n\u00e0y c\u00f3 \u0111\u1eb7c \u0111i\u1ec3m b\u1ed5 sung nhau v\u1ec1 hi\u1ec7u qu\u1ea3 th\u1eddi gian v\u00e0 hi\u1ec7u qu\u1ea3 kh\u00f4ng gian.</p> <p></p> <p>L\u01b0u \u00fd r\u1eb1ng m\u1ecdi c\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u1ec1u \u0111\u01b0\u1ee3c x\u00e2y d\u1ef1ng d\u1ef1a tr\u00ean m\u1ea3ng, danh s\u00e1ch li\u00ean k\u1ebft ho\u1eb7c k\u1ebft h\u1ee3p c\u1ea3 hai. V\u00ed d\u1ee5, ng\u0103n x\u1ebfp v\u00e0 h\u00e0ng \u0111\u1ee3i c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t b\u1eb1ng m\u1ea3ng ho\u1eb7c danh s\u00e1ch li\u00ean k\u1ebft; c\u00f2n b\u1ea3ng b\u0103m c\u00f3 th\u1ec3 d\u00f9ng c\u1ea3 m\u1ea3ng v\u00e0 danh s\u00e1ch li\u00ean k\u1ebft.</p> <ul> <li>C\u00e0i \u0111\u1eb7t d\u1ef1a tr\u00ean m\u1ea3ng: Ng\u0103n x\u1ebfp, H\u00e0ng \u0111\u1ee3i, B\u1ea3ng b\u0103m, C\u00e2y, Heap, \u0110\u1ed3 th\u1ecb, Ma tr\u1eadn, Tensor (m\u1ea3ng c\u00f3 s\u1ed1 chi\u1ec1u \\(\\geq 3\\)).</li> <li>C\u00e0i \u0111\u1eb7t d\u1ef1a tr\u00ean danh s\u00e1ch li\u00ean k\u1ebft: Ng\u0103n x\u1ebfp, H\u00e0ng \u0111\u1ee3i, B\u1ea3ng b\u0103m, C\u00e2y, Heap, \u0110\u1ed3 th\u1ecb, v.v.</li> </ul> <p>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u d\u1ef1a tr\u00ean m\u1ea3ng c\u00f2n g\u1ecdi l\u00e0 \u201cC\u1ea5u tr\u00fac d\u1eef li\u1ec7u t\u0129nh\u201d, ngh\u0129a l\u00e0 \u0111\u1ed9 d\u00e0i kh\u00f4ng thay \u0111\u1ed5i sau khi kh\u1edfi t\u1ea1o. Ng\u01b0\u1ee3c l\u1ea1i, c\u1ea5u tr\u00fac d\u1ef1a tr\u00ean danh s\u00e1ch li\u00ean k\u1ebft g\u1ecdi l\u00e0 \u201cC\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u1ed9ng\u201d, c\u00f3 th\u1ec3 thay \u0111\u1ed5i k\u00edch th\u01b0\u1edbc khi ch\u01b0\u01a1ng tr\u00ecnh ch\u1ea1y.</p> <p>Tip</p> <p>N\u1ebfu b\u1ea1n th\u1ea5y kh\u00f3 hi\u1ec3u v\u1ec1 c\u1ea5u tr\u00fac v\u1eadt l\u00fd, h\u00e3y \u0111\u1ecdc ch\u01b0\u01a1ng ti\u1ebfp theo \"M\u1ea3ng v\u00e0 Danh s\u00e1ch li\u00ean k\u1ebft\" r\u1ed3i quay l\u1ea1i ph\u1ea7n n\u00e0y sau.</p>"},{"location":"chapter_data_structure/number_encoding/","title":"3.3 Number encoding *","text":""},{"location":"chapter_data_structure/number_encoding/#ma-hoa-so","title":"M\u00e3 h\u00f3a s\u1ed1 *","text":"<p>Tip</p> <p>Trong cu\u1ed1n s\u00e1ch n\u00e0y, c\u00e1c ch\u01b0\u01a1ng \u0111\u01b0\u1ee3c \u0111\u00e1nh d\u1ea5u b\u1eb1ng d\u1ea5u sao '*' l\u00e0 ph\u1ea7n \u0111\u1ecdc th\u00eam t\u00f9y ch\u1ecdn. N\u1ebfu b\u1ea1n kh\u00f4ng c\u00f3 nhi\u1ec1u th\u1eddi gian ho\u1eb7c th\u1ea5y kh\u00f3 hi\u1ec3u, b\u1ea1n c\u00f3 th\u1ec3 b\u1ecf qua ch\u00fang l\u00fac \u0111\u1ea7u v\u00e0 quay l\u1ea1i sau khi ho\u00e0n th\u00e0nh c\u00e1c ch\u01b0\u01a1ng quan tr\u1ecdng.</p>"},{"location":"chapter_data_structure/number_encoding/#ma-hoa-so-nguyen","title":"M\u00e3 h\u00f3a s\u1ed1 nguy\u00ean","text":"<p>Trong b\u1ea3ng \u1edf ph\u1ea7n tr\u01b0\u1edbc, ta th\u1ea5y r\u1eb1ng t\u1ea5t c\u1ea3 c\u00e1c ki\u1ec3u s\u1ed1 nguy\u00ean \u0111\u1ec1u c\u00f3 th\u1ec3 bi\u1ec3u di\u1ec5n nhi\u1ec1u s\u1ed1 \u00e2m h\u01a1n s\u1ed1 d\u01b0\u01a1ng m\u1ed9t \u0111\u01a1n v\u1ecb, v\u00ed d\u1ee5 ph\u1ea1m vi c\u1ee7a <code>byte</code> l\u00e0 \\([-128, 127]\\). Hi\u1ec7n t\u01b0\u1ee3ng n\u00e0y c\u00f3 v\u1ebb kh\u00f3 hi\u1ec3u, v\u00e0 l\u00fd do \u0111\u1eb1ng sau li\u00ean quan \u0111\u1ebfn ki\u1ebfn th\u1ee9c v\u1ec1 m\u00e3 h\u00f3a d\u1ea5u-gi\u00e1 tr\u1ecb, b\u00f9 m\u1ed9t, v\u00e0 b\u00f9 hai.</p> <p>Tr\u01b0\u1edbc ti\u00ean, c\u1ea7n l\u01b0u \u00fd r\u1eb1ng c\u00e1c s\u1ed1 \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef trong m\u00e1y t\u00ednh d\u01b0\u1edbi d\u1ea1ng b\u00f9 hai. Tr\u01b0\u1edbc khi ph\u00e2n t\u00edch l\u00fd do, h\u00e3y \u0111\u1ecbnh ngh\u0129a ba ph\u01b0\u01a1ng ph\u00e1p m\u00e3 h\u00f3a n\u00e0y:</p> <ul> <li>D\u1ea5u-gi\u00e1 tr\u1ecb (Sign-magnitude): Bit cao nh\u1ea5t c\u1ee7a s\u1ed1 nh\u1ecb ph\u00e2n l\u00e0 bit d\u1ea5u, \\(0\\) l\u00e0 s\u1ed1 d\u01b0\u01a1ng, \\(1\\) l\u00e0 s\u1ed1 \u00e2m. C\u00e1c bit c\u00f2n l\u1ea1i bi\u1ec3u di\u1ec5n gi\u00e1 tr\u1ecb s\u1ed1.</li> <li>B\u00f9 m\u1ed9t (One's complement): B\u00f9 m\u1ed9t c\u1ee7a s\u1ed1 d\u01b0\u01a1ng gi\u1ed1ng d\u1ea5u-gi\u00e1 tr\u1ecb. V\u1edbi s\u1ed1 \u00e2m, b\u00f9 m\u1ed9t l\u00e0 \u0111\u1ea3o t\u1ea5t c\u1ea3 c\u00e1c bit tr\u1eeb bit d\u1ea5u.</li> <li>B\u00f9 hai (Two's complement): B\u00f9 hai c\u1ee7a s\u1ed1 d\u01b0\u01a1ng gi\u1ed1ng d\u1ea5u-gi\u00e1 tr\u1ecb. V\u1edbi s\u1ed1 \u00e2m, b\u00f9 hai l\u00e0 l\u1ea5y b\u00f9 m\u1ed9t r\u1ed3i c\u1ed9ng th\u00eam \\(1\\).</li> </ul> <p>H\u00ecnh d\u01b0\u1edbi minh h\u1ecda c\u00e1ch chuy\u1ec3n \u0111\u1ed5i gi\u1eefa d\u1ea5u-gi\u00e1 tr\u1ecb, b\u00f9 m\u1ed9t v\u00e0 b\u00f9 hai:</p> <p></p> <p>M\u1eb7c d\u00f9 d\u1ea5u-gi\u00e1 tr\u1ecb l\u00e0 tr\u1ef1c quan nh\u1ea5t, n\u00f3 c\u00f3 h\u1ea1n ch\u1ebf. V\u00ed d\u1ee5, s\u1ed1 \u00e2m \u1edf d\u1ea5u-gi\u00e1 tr\u1ecb kh\u00f4ng th\u1ec3 d\u00f9ng tr\u1ef1c ti\u1ebfp \u0111\u1ec3 t\u00ednh to\u00e1n. Ch\u1eb3ng h\u1ea1n, trong d\u1ea5u-gi\u00e1 tr\u1ecb, ph\u00e9p t\u00ednh \\(1 + (-2)\\) ra k\u1ebft qu\u1ea3 \\(-3\\), l\u00e0 sai.</p> \\[ \\begin{aligned} &amp; 1 + (-2) \\newline &amp; \\rightarrow 0000 \\; 0001 + 1000 \\; 0010 \\newline &amp; = 1000 \\; 0011 \\newline &amp; \\rightarrow -3 \\end{aligned} \\] <p>\u0110\u1ec3 kh\u1eafc ph\u1ee5c, m\u00e1y t\u00ednh \u0111\u01b0a ra b\u00f9 m\u1ed9t. N\u1ebfu chuy\u1ec3n sang b\u00f9 m\u1ed9t v\u00e0 t\u00ednh \\(1 + (-2)\\), r\u1ed3i chuy\u1ec3n k\u1ebft qu\u1ea3 v\u1ec1 d\u1ea5u-gi\u00e1 tr\u1ecb, ta \u0111\u01b0\u1ee3c k\u1ebft qu\u1ea3 \u0111\u00fang l\u00e0 \\(-1\\).</p> \\[ \\begin{aligned} &amp; 1 + (-2) \\newline &amp; \\rightarrow 0000 \\; 0001 \\; \\text{(D\u1ea5u-gi\u00e1 tr\u1ecb)} + 1000 \\; 0010 \\; \\text{(D\u1ea5u-gi\u00e1 tr\u1ecb)} \\newline &amp; = 0000 \\; 0001 \\; \\text{(B\u00f9 m\u1ed9t)} + 1111 \\; 1101 \\; \\text{(B\u00f9 m\u1ed9t)} \\newline &amp; = 1111 \\; 1110 \\; \\text{(B\u00f9 m\u1ed9t)} \\newline &amp; = 1000 \\; 0001 \\; \\text{(D\u1ea5u-gi\u00e1 tr\u1ecb)} \\newline &amp; \\rightarrow -1 \\end{aligned} \\] <p>Ngo\u00e0i ra, c\u00f3 hai c\u00e1ch bi\u1ec3u di\u1ec5n s\u1ed1 0 trong d\u1ea5u-gi\u00e1 tr\u1ecb: \\(+0\\) v\u00e0 \\(-0\\). \u0110i\u1ec1u n\u00e0y ngh\u0129a l\u00e0 c\u00f3 hai m\u00e3 nh\u1ecb ph\u00e2n kh\u00e1c nhau cho s\u1ed1 0, d\u1ec5 g\u00e2y nh\u1ea7m l\u1eabn. V\u00ed d\u1ee5, khi ki\u1ec3m tra \u0111i\u1ec1u ki\u1ec7n, kh\u00f4ng ph\u00e2n bi\u1ec7t \u0111\u01b0\u1ee3c 0 d\u01b0\u01a1ng v\u00e0 0 \u00e2m c\u00f3 th\u1ec3 d\u1eabn \u0111\u1ebfn k\u1ebft qu\u1ea3 sai. \u0110\u1ec3 x\u1eed l\u00fd, c\u1ea7n ki\u1ec3m tra b\u1ed5 sung, l\u00e0m gi\u1ea3m hi\u1ec7u su\u1ea5t t\u00ednh to\u00e1n.</p> \\[ \\begin{aligned} +0 &amp; \\rightarrow 0000 \\; 0000 \\newline -0 &amp; \\rightarrow 1000 \\; 0000 \\end{aligned} \\] <p>T\u01b0\u01a1ng t\u1ef1 d\u1ea5u-gi\u00e1 tr\u1ecb, b\u00f9 m\u1ed9t c\u0169ng g\u1eb7p v\u1ea5n \u0111\u1ec1 0 d\u01b0\u01a1ng v\u00e0 0 \u00e2m. V\u00ec v\u1eady, m\u00e1y t\u00ednh ti\u1ebfp t\u1ee5c d\u00f9ng b\u00f9 hai. H\u00e3y xem qu\u00e1 tr\u00ecnh chuy\u1ec3n \u0111\u1ed5i s\u1ed1 0 \u00e2m trong d\u1ea5u-gi\u00e1 tr\u1ecb, b\u00f9 m\u1ed9t v\u00e0 b\u00f9 hai:</p> \\[ \\begin{aligned} -0 \\rightarrow \\; &amp; 1000 \\; 0000 \\; \\text{(D\u1ea5u-gi\u00e1 tr\u1ecb)} \\newline = \\; &amp; 1111 \\; 1111 \\; \\text{(B\u00f9 m\u1ed9t)} \\newline = 1 \\; &amp; 0000 \\; 0000 \\; \\text{(B\u00f9 hai)} \\newline \\end{aligned} \\] <p>Khi c\u1ed9ng \\(1\\) v\u00e0o b\u00f9 m\u1ed9t c\u1ee7a s\u1ed1 0 \u00e2m s\u1ebd sinh ra s\u1ed1 d\u01b0, nh\u01b0ng v\u1edbi \u0111\u1ed9 d\u00e0i <code>byte</code> ch\u1ec9 8 bit, s\u1ed1 d\u01b0 \u1edf bit th\u1ee9 9 b\u1ecb lo\u1ea1i b\u1ecf. V\u00ec v\u1eady, b\u00f9 hai c\u1ee7a s\u1ed1 0 \u00e2m l\u00e0 \\(0000 \\; 0000\\), gi\u1ed1ng s\u1ed1 0 d\u01b0\u01a1ng, gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 nh\u1ea7m l\u1eabn.</p> <p>M\u1ed9t \u0111i\u1ec3m n\u1eefa l\u00e0 ph\u1ea1m vi \\([-128, 127]\\) c\u1ee7a <code>byte</code>, c\u00f3 th\u00eam s\u1ed1 \u00e2m \\(-128\\). Ta th\u1ea5y v\u1edbi \u0111o\u1ea1n \\([-127, +127]\\), m\u1ecdi s\u1ed1 nguy\u00ean \u0111\u1ec1u c\u00f3 d\u1ea5u-gi\u00e1 tr\u1ecb, b\u00f9 m\u1ed9t v\u00e0 b\u00f9 hai t\u01b0\u01a1ng \u1ee9ng, c\u00f3 th\u1ec3 chuy\u1ec3n \u0111\u1ed5i qua l\u1ea1i.</p> <p>Tuy nhi\u00ean, b\u00f9 hai \\(1000 \\; 0000\\) l\u00e0 ngo\u1ea1i l\u1ec7, kh\u00f4ng c\u00f3 d\u1ea5u-gi\u00e1 tr\u1ecb t\u01b0\u01a1ng \u1ee9ng. Theo c\u00e1ch chuy\u1ec3n \u0111\u1ed5i, d\u1ea5u-gi\u00e1 tr\u1ecb c\u1ee7a n\u00f3 s\u1ebd l\u00e0 \\(0000 \\; 0000\\), t\u1ee9c l\u00e0 s\u1ed1 0. \u0110i\u1ec1u n\u00e0y m\u00e2u thu\u1eabn v\u00ec b\u00f9 hai ph\u1ea3i bi\u1ec3u di\u1ec5n ch\u00ednh n\u00f3. M\u00e1y t\u00ednh quy \u0111\u1ecbnh b\u00f9 hai \u0111\u1eb7c bi\u1ec7t \\(1000 \\; 0000\\) l\u00e0 \\(-128\\). Th\u1ef1c t\u1ebf, ph\u00e9p t\u00ednh \\((-1) + (-127)\\) trong b\u00f9 hai ra \\(-128\\).</p> \\[ \\begin{aligned} &amp; (-127) + (-1) \\newline &amp; \\rightarrow 1111 \\; 1111 \\; \\text{(D\u1ea5u-gi\u00e1 tr\u1ecb)} + 1000 \\; 0001 \\; \\text{(D\u1ea5u-gi\u00e1 tr\u1ecb)} \\newline &amp; = 1000 \\; 0000 \\; \\text{(B\u00f9 m\u1ed9t)} + 1111 \\; 1110 \\; \\text{(B\u00f9 m\u1ed9t)} \\newline &amp; = 1000 \\; 0001 \\; \\text{(B\u00f9 hai)} + 1111 \\; 1111 \\; \\text{(B\u00f9 hai)} \\newline &amp; = 1000 \\; 0000 \\; \\text{(B\u00f9 hai)} \\newline &amp; \\rightarrow -128 \\end{aligned} \\] <p>B\u1ea1n c\u00f3 th\u1ec3 nh\u1eadn th\u1ea5y, t\u1ea5t c\u1ea3 c\u00e1c ph\u00e9p t\u00ednh tr\u00ean \u0111\u1ec1u l\u00e0 ph\u00e9p c\u1ed9ng, cho th\u1ea5y m\u1ed9t s\u1ef1 th\u1eadt quan tr\u1ecdng: c\u00e1c m\u1ea1ch ph\u1ea7n c\u1ee9ng trong m\u00e1y t\u00ednh ch\u1ee7 y\u1ebfu \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf \u0111\u1ec3 th\u1ef1c hi\u1ec7n ph\u00e9p c\u1ed9ng. V\u00ec ph\u00e9p c\u1ed9ng d\u1ec5 th\u1ef1c hi\u1ec7n h\u01a1n c\u00e1c ph\u00e9p kh\u00e1c nh\u01b0 nh\u00e2n, chia, tr\u1eeb, gi\u00fap d\u1ec5 song song h\u00f3a v\u00e0 t\u00ednh to\u00e1n nhanh h\u01a1n.</p> <p>L\u01b0u \u00fd r\u1eb1ng \u0111i\u1ec1u n\u00e0y kh\u00f4ng c\u00f3 ngh\u0129a m\u00e1y t\u00ednh ch\u1ec9 c\u1ed9ng \u0111\u01b0\u1ee3c. K\u1ebft h\u1ee3p ph\u00e9p c\u1ed9ng v\u1edbi c\u00e1c ph\u00e9p logic c\u01a1 b\u1ea3n, m\u00e1y t\u00ednh c\u00f3 th\u1ec3 th\u1ef1c hi\u1ec7n nhi\u1ec1u ph\u00e9p to\u00e1n kh\u00e1c. V\u00ed d\u1ee5, ph\u00e9p tr\u1eeb \\(a - b\\) c\u00f3 th\u1ec3 chuy\u1ec3n th\u00e0nh \\(a + (-b)\\); ph\u00e9p nh\u00e2n, chia c\u00f3 th\u1ec3 chuy\u1ec3n th\u00e0nh nhi\u1ec1u ph\u00e9p c\u1ed9ng ho\u1eb7c tr\u1eeb.</p> <p>T\u00f3m l\u1ea1i, l\u00fd do m\u00e1y t\u00ednh d\u00f9ng b\u00f9 hai l\u00e0: v\u1edbi b\u00f9 hai, m\u00e1y t\u00ednh c\u00f3 th\u1ec3 d\u00f9ng c\u00f9ng m\u1ed9t m\u1ea1ch v\u00e0 ph\u00e9p to\u00e1n \u0111\u1ec3 x\u1eed l\u00fd c\u1ea3 s\u1ed1 d\u01b0\u01a1ng v\u00e0 s\u1ed1 \u00e2m, kh\u00f4ng c\u1ea7n m\u1ea1ch \u0111\u1eb7c bi\u1ec7t cho ph\u00e9p tr\u1eeb, \u0111\u1ed3ng th\u1eddi tr\u00e1nh nh\u1ea7m l\u1eabn 0 d\u01b0\u01a1ng v\u00e0 0 \u00e2m. \u0110i\u1ec1u n\u00e0y \u0111\u01a1n gi\u1ea3n h\u00f3a thi\u1ebft k\u1ebf ph\u1ea7n c\u1ee9ng v\u00e0 t\u0103ng hi\u1ec7u su\u1ea5t t\u00ednh to\u00e1n.</p> <p>Thi\u1ebft k\u1ebf b\u00f9 hai r\u1ea5t th\u00f4ng minh, do gi\u1edbi h\u1ea1n n\u1ed9i dung, ch\u00fang ta d\u1eebng l\u1ea1i \u1edf \u0111\u00e2y. N\u1ebfu b\u1ea1n quan t\u00e2m, h\u00e3y t\u00ecm hi\u1ec3u th\u00eam.</p>"},{"location":"chapter_data_structure/number_encoding/#ma-hoa-so-thuc-floating-point","title":"M\u00e3 h\u00f3a s\u1ed1 th\u1ef1c (floating-point)","text":"<p>B\u1ea1n c\u00f3 th\u1ec3 th\u1ea5y \u0111i\u1ec1u th\u00fa v\u1ecb: d\u00f9 c\u00f9ng \u0111\u1ed9 d\u00e0i 4 byte, t\u1ea1i sao <code>float</code> l\u1ea1i c\u00f3 ph\u1ea1m vi gi\u00e1 tr\u1ecb l\u1edbn h\u01a1n nhi\u1ec1u so v\u1edbi <code>int</code>? \u0110i\u1ec1u n\u00e0y c\u00f3 v\u1ebb l\u1ea1, v\u00ec ta ngh\u0129 r\u1eb1ng ph\u1ea1m vi s\u1ebd nh\u1ecf h\u01a1n do ph\u1ea3i bi\u1ec3u di\u1ec5n s\u1ed1 th\u1eadp ph\u00e2n.</p> <p>Th\u1ef1c ra, \u0111i\u1ec1u n\u00e0y l\u00e0 do c\u00e1ch bi\u1ec3u di\u1ec5n kh\u00e1c c\u1ee7a s\u1ed1 th\u1ef1c (<code>float</code>). H\u00e3y x\u00e9t m\u1ed9t s\u1ed1 nh\u1ecb ph\u00e2n 32 bit:</p> \\[ b_{31} b_{30} b_{29} \\ldots b_2 b_1 b_0 \\] <p>Theo chu\u1ea9n IEEE 754, m\u1ed9t <code>float</code> 32 bit g\u1ed3m ba ph\u1ea7n:</p> <ul> <li>Bit d\u1ea5u \\(\\mathrm{S}\\): 1 bit, l\u00e0 \\(b_{31}\\).</li> <li>Bit s\u1ed1 m\u0169 \\(\\mathrm{E}\\): 8 bit, l\u00e0 \\(b_{30} b_{29} \\ldots b_{23}\\).</li> <li>Bit ph\u1ea7n th\u1eadp ph\u00e2n \\(\\mathrm{N}\\): 23 bit, l\u00e0 \\(b_{22} b_{21} \\ldots b_0\\).</li> </ul> <p>Gi\u00e1 tr\u1ecb c\u1ee7a m\u1ed9t s\u1ed1 <code>float</code> nh\u1ecb ph\u00e2n \u0111\u01b0\u1ee3c t\u00ednh nh\u01b0 sau:</p> \\[ \\text{val} = (-1)^{b_{31}} \\times 2^{\\left(b_{30} b_{29} \\ldots b_{23}\\right)_2 - 127} \\times \\left(1 . b_{22} b_{21} \\ldots b_0\\right)_2 \\] <p>Chuy\u1ec3n sang c\u00f4ng th\u1ee9c th\u1eadp ph\u00e2n:</p> \\[ \\text{val} = (-1)^{\\mathrm{S}} \\times 2^{\\mathrm{E} - 127} \\times (1 + \\mathrm{N}) \\] <p>Ph\u1ea1m vi c\u1ee7a t\u1eebng th\u00e0nh ph\u1ea7n:</p> \\[ \\begin{aligned} \\mathrm{S} \\in &amp; \\{ 0, 1\\}, \\quad \\mathrm{E} \\in \\{ 1, 2, \\dots, 254 \\} \\newline (1 + \\mathrm{N}) = &amp; (1 + \\sum_{i=1}^{23} b_{23-i} \\times 2^{-i}) \\subset [1, 2 - 2^{-23}] \\end{aligned} \\] <p></p> <p>Quan s\u00e1t h\u00ecnh tr\u00ean, v\u1edbi v\u00ed d\u1ee5 \\(\\mathrm{S} = 0\\), \\(\\mathrm{E} = 124\\), \\(\\mathrm{N} = 2^{-2} + 2^{-3} = 0.375\\), ta c\u00f3:</p> \\[ \\text{val} = (-1)^0 \\times 2^{124 - 127} \\times (1 + 0.375) = 0.171875 \\] <p>Gi\u1edd ta c\u00f3 th\u1ec3 tr\u1ea3 l\u1eddi c\u00e2u h\u1ecfi ban \u0111\u1ea7u: Ki\u1ec3u <code>float</code> c\u00f3 bit s\u1ed1 m\u0169 n\u00ean ph\u1ea1m vi l\u1edbn h\u01a1n nhi\u1ec1u so v\u1edbi <code>int</code>. Theo c\u00e1ch t\u00ednh tr\u00ean, s\u1ed1 d\u01b0\u01a1ng l\u1edbn nh\u1ea5t ki\u1ec3u <code>float</code> l\u00e0 kho\u1ea3ng \\(2^{254 - 127} \\times (2 - 2^{-23}) \\approx 3.4 \\times 10^{38}\\), s\u1ed1 \u00e2m nh\u1ecf nh\u1ea5t l\u00e0 \u0111\u1ed5i bit d\u1ea5u.</p> <p>Tuy nhi\u00ean, \u0111\u1ed5i l\u1ea1i ph\u1ea1m vi l\u1edbn, <code>float</code> b\u1ecb gi\u1ea3m \u0111\u1ed9 ch\u00ednh x\u00e1c. Ki\u1ec3u <code>int</code> d\u00f9ng c\u1ea3 32 bit \u0111\u1ec3 bi\u1ec3u di\u1ec5n s\u1ed1, c\u00e1c gi\u00e1 tr\u1ecb c\u00e1ch \u0111\u1ec1u nhau; c\u00f2n <code>float</code> do c\u00f3 bit s\u1ed1 m\u0169, gi\u00e1 tr\u1ecb c\u00e0ng l\u1edbn th\u00ec kho\u1ea3ng c\u00e1ch gi\u1eefa hai s\u1ed1 li\u1ec1n k\u1ec1 c\u00e0ng l\u1edbn.</p> <p>Nh\u01b0 b\u1ea3ng d\u01b0\u1edbi, bit s\u1ed1 m\u0169 \\(\\mathrm{E} = 0\\) v\u00e0 \\(\\mathrm{E} = 255\\) c\u00f3 \u00fd ngh\u0129a \u0111\u1eb7c bi\u1ec7t, d\u00f9ng \u0111\u1ec3 bi\u1ec3u di\u1ec5n s\u1ed1 0, v\u00f4 c\u1ef1c, \\(\\mathrm{NaN}\\), v.v.</p> <p> B\u1ea3ng  \u00a0 \u00dd ngh\u0129a c\u1ee7a bit s\u1ed1 m\u0169 </p> Bit s\u1ed1 m\u0169 E Bit ph\u1ea7n th\u1eadp ph\u00e2n \\(\\mathrm{N} = 0\\) Bit ph\u1ea7n th\u1eadp ph\u00e2n \\(\\mathrm{N} \\ne 0\\) C\u00f4ng th\u1ee9c t\u00ednh \\(0\\) \\(\\pm 0\\) S\u1ed1 ph\u1ee5 (subnormal) \\((-1)^{\\mathrm{S}} \\times 2^{-126} \\times (0.\\mathrm{N})\\) \\(1, 2, \\dots, 254\\) S\u1ed1 b\u00ecnh th\u01b0\u1eddng S\u1ed1 b\u00ecnh th\u01b0\u1eddng \\((-1)^{\\mathrm{S}} \\times 2^{(\\mathrm{E} -127)} \\times (1.\\mathrm{N})\\) \\(255\\) \\(\\pm \\infty\\) \\(\\mathrm{NaN}\\) <p>L\u01b0u \u00fd r\u1eb1ng s\u1ed1 ph\u1ee5 gi\u00fap t\u0103ng \u0111\u1ed9 ch\u00ednh x\u00e1c c\u1ee7a s\u1ed1 th\u1ef1c. S\u1ed1 d\u01b0\u01a1ng nh\u1ecf nh\u1ea5t ki\u1ec3u b\u00ecnh th\u01b0\u1eddng l\u00e0 \\(2^{-126}\\), s\u1ed1 d\u01b0\u01a1ng nh\u1ecf nh\u1ea5t ki\u1ec3u ph\u1ee5 l\u00e0 \\(2^{-126} \\times 2^{-23}\\).</p> <p>Ki\u1ec3u <code>double</code> (s\u1ed1 th\u1ef1c \u0111\u1ed9 ch\u00ednh x\u00e1c k\u00e9p) c\u0169ng d\u00f9ng c\u00e1ch bi\u1ec3u di\u1ec5n t\u01b0\u01a1ng t\u1ef1 <code>float</code>, \u1edf \u0111\u00e2y kh\u00f4ng tr\u00ecnh b\u00e0y chi ti\u1ebft.</p>"},{"location":"chapter_data_structure/summary/","title":"3.5 Summary","text":""},{"location":"chapter_data_structure/summary/#tom-tat","title":"T\u00f3m t\u1eaft","text":""},{"location":"chapter_data_structure/summary/#on-tap-chinh","title":"\u00d4n t\u1eadp ch\u00ednh","text":"<ul> <li>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u c\u00f3 hai lo\u1ea1i: c\u1ea5u tr\u00fac logic (c\u00e1ch d\u1eef li\u1ec7u li\u00ean k\u1ebft v\u1edbi nhau) v\u00e0 c\u1ea5u tr\u00fac v\u1eadt l\u00fd (c\u00e1ch d\u1eef li\u1ec7u l\u01b0u trong b\u1ed9 nh\u1edb).</li> <li>C\u1ea5u tr\u00fac logic g\u1ed3m tuy\u1ebfn t\u00ednh (m\u1ea3ng, danh s\u00e1ch li\u00ean k\u1ebft, ng\u0103n x\u1ebfp, h\u00e0ng \u0111\u1ee3i) v\u00e0 phi tuy\u1ebfn t\u00ednh (c\u00e2y, \u0111\u1ed3 th\u1ecb, heap). B\u1ea3ng b\u0103m c\u00f3 th\u1ec3 d\u00f9ng c\u1ea3 hai lo\u1ea1i n\u00e0y.</li> <li>Khi ch\u01b0\u01a1ng tr\u00ecnh ch\u1ea1y, d\u1eef li\u1ec7u l\u01b0u trong b\u1ed9 nh\u1edb, m\u1ed7i v\u00f9ng nh\u1edb c\u00f3 \u0111\u1ecba ch\u1ec9 ri\u00eang \u0111\u1ec3 truy c\u1eadp.</li> <li>C\u1ea5u tr\u00fac v\u1eadt l\u00fd g\u1ed3m l\u01b0u tr\u1eef li\u00ean t\u1ee5c (m\u1ea3ng) v\u00e0 l\u01b0u tr\u1eef r\u1eddi r\u1ea1c (danh s\u00e1ch li\u00ean k\u1ebft). C\u00e1c c\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u1ec1u x\u00e2y d\u1ef1ng t\u1eeb m\u1ea3ng, danh s\u00e1ch li\u00ean k\u1ebft ho\u1eb7c k\u1ebft h\u1ee3p c\u1ea3 hai.</li> <li>Ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n: s\u1ed1 nguy\u00ean (<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>), s\u1ed1 th\u1ef1c (<code>float</code>, <code>double</code>), k\u00fd t\u1ef1 (<code>char</code>), boolean (<code>bool</code>). Gi\u00e1 tr\u1ecb c\u1ee7a ki\u1ec3u d\u1eef li\u1ec7u ph\u1ee5 thu\u1ed9c v\u00e0o k\u00edch th\u01b0\u1edbc v\u00e0 c\u00e1ch bi\u1ec3u di\u1ec5n.</li> <li>C\u00f3 ba c\u00e1ch m\u00e3 h\u00f3a s\u1ed1 nguy\u00ean: d\u1ea5u-ch\u00e2n, b\u00f9 1, b\u00f9 2. Bit \u0111\u1ea7u l\u00e0 bit d\u1ea5u, c\u00e1c bit c\u00f2n l\u1ea1i l\u00e0 gi\u00e1 tr\u1ecb s\u1ed1.</li> <li>M\u00e1y t\u00ednh d\u00f9ng b\u00f9 2 \u0111\u1ec3 m\u00e3 h\u00f3a s\u1ed1 nguy\u00ean. \u01afu \u0111i\u1ec3m: (i) c\u1ed9ng s\u1ed1 d\u01b0\u01a1ng v\u00e0 \u00e2m d\u1ec5 d\u00e0ng, (ii) kh\u00f4ng c\u1ea7n m\u1ea1ch ph\u1ea7n c\u1ee9ng \u0111\u1eb7c bi\u1ec7t cho ph\u00e9p tr\u1eeb, (iii) kh\u00f4ng c\u00f3 hai s\u1ed1 0 kh\u00e1c nhau.</li> <li>S\u1ed1 th\u1ef1c \u0111\u01b0\u1ee3c m\u00e3 h\u00f3a b\u1eb1ng 1 bit d\u1ea5u, 8 bit s\u1ed1 m\u0169, 23 bit ph\u1ea7n th\u1eadp ph\u00e2n. Nh\u1edd s\u1ed1 m\u0169, ph\u1ea1m vi s\u1ed1 th\u1ef1c l\u1edbn h\u01a1n s\u1ed1 nguy\u00ean, nh\u01b0ng \u0111\u1ed9 ch\u00ednh x\u00e1c gi\u1ea3m.</li> <li>ASCII l\u00e0 b\u1ed9 k\u00fd t\u1ef1 ti\u1ebfng Anh, d\u00e0i 1 byte, c\u00f3 127 k\u00fd t\u1ef1. GBK l\u00e0 b\u1ed9 m\u00e3 ti\u1ebfng Trung, c\u00f3 h\u01a1n 20.000 k\u00fd t\u1ef1. Unicode l\u00e0 chu\u1ea9n chung cho c\u00e1c ng\u00f4n ng\u1eef, gi\u00fap tr\u00e1nh l\u1ed7i k\u00fd t\u1ef1 do m\u00e3 h\u00f3a kh\u00e1c nhau.</li> <li>UTF-8 l\u00e0 c\u00e1ch m\u00e3 h\u00f3a Unicode ph\u1ed5 bi\u1ebfn nh\u1ea5t, c\u00f3 \u0111\u1ed9 d\u00e0i thay \u0111\u1ed5i, ti\u1ebft ki\u1ec7m kh\u00f4ng gian. UTF-16 v\u00e0 UTF-32 c\u00f3 \u0111\u1ed9 d\u00e0i c\u1ed1 \u0111\u1ecbnh. Khi l\u01b0u k\u00fd t\u1ef1 Trung Qu\u1ed1c, UTF-16 ti\u1ebft ki\u1ec7m h\u01a1n UTF-8. Java v\u00e0 C# m\u1eb7c \u0111\u1ecbnh d\u00f9ng UTF-16.</li> </ul>"},{"location":"chapter_data_structure/summary/#hoi-ap","title":"H\u1ecfi &amp; \u0110\u00e1p","text":"<p>H\u1ecfi: T\u1ea1i sao b\u1ea3ng b\u0103m d\u00f9ng c\u1ea3 c\u1ea5u tr\u00fac tuy\u1ebfn t\u00ednh v\u00e0 phi tuy\u1ebfn t\u00ednh?</p> <p>B\u1ea3ng b\u0103m d\u00f9ng m\u1ea3ng l\u00e0m n\u1ec1n t\u1ea3ng. \u0110\u1ec3 x\u1eed l\u00fd va ch\u1ea1m, m\u1ed7i \u00f4 m\u1ea3ng c\u00f3 th\u1ec3 tr\u1ecf \u0111\u1ebfn danh s\u00e1ch li\u00ean k\u1ebft ho\u1eb7c c\u00e2y. V\u00ec v\u1eady, b\u1ea3ng b\u0103m v\u1eeba d\u00f9ng c\u1ea5u tr\u00fac tuy\u1ebfn t\u00ednh (m\u1ea3ng, danh s\u00e1ch li\u00ean k\u1ebft) v\u1eeba d\u00f9ng phi tuy\u1ebfn t\u00ednh (c\u00e2y).</p> <p>H\u1ecfi: Ki\u1ec3u <code>char</code> c\u00f3 lu\u00f4n d\u00e0i 1 byte kh\u00f4ng?</p> <p>\u0110\u1ed9 d\u00e0i ki\u1ec3u <code>char</code> ph\u1ee5 thu\u1ed9c v\u00e0o ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh. Java, JavaScript, TypeScript, C# d\u00f9ng UTF-16, n\u00ean <code>char</code> d\u00e0i 2 byte.</p> <p>H\u1ecfi: C\u1ea5u tr\u00fac d\u1eef li\u1ec7u d\u1ef1a tr\u00ean m\u1ea3ng g\u1ecdi l\u00e0 \"t\u0129nh\" c\u00f3 \u0111\u00fang kh\u00f4ng? Ng\u0103n x\u1ebfp v\u1eabn th\u00eam/x\u00f3a \u0111\u1ed9ng m\u00e0.</p> <p>Ng\u0103n x\u1ebfp thao t\u00e1c \u0111\u1ed9ng v\u1edbi d\u1eef li\u1ec7u, nh\u01b0ng dung l\u01b0\u1ee3ng m\u1ea3ng l\u00e0 c\u1ed1 \u0111\u1ecbnh. N\u1ebfu v\u01b0\u1ee3t qu\u00e1 dung l\u01b0\u1ee3ng, m\u1ea3ng s\u1ebd \u0111\u01b0\u1ee3c sao ch\u00e9p sang m\u1ea3ng m\u1edbi l\u1edbn h\u01a1n.</p> <p>H\u1ecfi: Khi x\u00e2y d\u1ef1ng ng\u0103n x\u1ebfp/h\u00e0ng \u0111\u1ee3i, kh\u00f4ng ch\u1ec9 \u0111\u1ecbnh k\u00edch th\u01b0\u1edbc, sao v\u1eabn g\u1ecdi l\u00e0 \"t\u0129nh\"?</p> <p>Trong ng\u00f4n ng\u1eef c\u1ea5p cao, dung l\u01b0\u1ee3ng ban \u0111\u1ea7u \u0111\u01b0\u1ee3c t\u1ef1 \u0111\u1ed9ng c\u1ea5p ph\u00e1t (v\u00ed d\u1ee5, <code>ArrayList</code> trong Java th\u01b0\u1eddng l\u00e0 10). Khi c\u1ea7n, dung l\u01b0\u1ee3ng s\u1ebd t\u1ef1 \u0111\u1ed9ng m\u1edf r\u1ed9ng.</p> <p>H\u1ecfi: Chuy\u1ec3n d\u1ea5u-ch\u00e2n sang b\u00f9 2 l\u00e0 \"\u0111\u1ed5i d\u1ea5u r\u1ed3i c\u1ed9ng 1\", v\u1eady chuy\u1ec3n ng\u01b0\u1ee3c l\u1ea1i l\u00e0 \"tr\u1eeb 1 r\u1ed3i \u0111\u1ed5i d\u1ea5u\". Nh\u01b0ng b\u00f9 2 c\u0169ng c\u00f3 th\u1ec3 chuy\u1ec3n sang d\u1ea5u-ch\u00e2n b\u1eb1ng \"\u0111\u1ed5i d\u1ea5u r\u1ed3i c\u1ed9ng 1\", t\u1ea1i sao?</p> <p>\u0110\u00e1p: Chuy\u1ec3n \u0111\u1ed5i gi\u1eefa d\u1ea5u-ch\u00e2n v\u00e0 b\u00f9 2 th\u1ef1c ch\u1ea5t l\u00e0 t\u00ednh \"b\u00f9\". N\u1ebfu \\(a + b = c\\), th\u00ec \\(a\\) l\u00e0 b\u00f9 c\u1ee7a \\(b\\) t\u1edbi \\(c\\).</p> <p>V\u00ed d\u1ee5, s\u1ed1 nh\u1ecb ph\u00e2n \\(0010\\) (4 bit), chuy\u1ec3n d\u1ea5u-ch\u00e2n sang b\u00f9 2 b\u1eb1ng \"\u0111\u1ed5i d\u1ea5u r\u1ed3i c\u1ed9ng 1\":</p> \\[ 0010 \\rightarrow 1101 \\rightarrow 1110 \\] <p>T\u1ed5ng \\(0010 + 1110 = 10000\\), ngh\u0129a l\u00e0 \\(1110\\) l\u00e0 b\u00f9 c\u1ee7a \\(0010\\) t\u1edbi \\(10000\\).</p> <p>Chuy\u1ec3n ng\u01b0\u1ee3c l\u1ea1i c\u0169ng d\u00f9ng \"\u0111\u1ed5i d\u1ea5u r\u1ed3i c\u1ed9ng 1\":</p> \\[ 1110 \\rightarrow 0001 \\rightarrow 0010 \\] <p>V\u00ec v\u1eady, c\u1ea3 hai chi\u1ec1u \u0111\u1ec1u d\u00f9ng \u0111\u01b0\u1ee3c \"\u0111\u1ed5i d\u1ea5u r\u1ed3i c\u1ed9ng 1\". Ngo\u00e0i ra, c\u00f3 th\u1ec3 d\u00f9ng \"tr\u1eeb 1 r\u1ed3i \u0111\u1ed5i d\u1ea5u\":</p> \\[ 1110 \\rightarrow 1101 \\rightarrow 0010 \\] <p>T\u00f3m l\u1ea1i, \"\u0111\u1ed5i d\u1ea5u r\u1ed3i c\u1ed9ng 1\" v\u00e0 \"tr\u1eeb 1 r\u1ed3i \u0111\u1ed5i d\u1ea5u\" \u0111\u1ec1u l\u00e0 t\u00ednh b\u00f9 t\u1edbi \\(10000\\), v\u00e0 \u0111\u1ec1u \u0111\u00fang.</p> <p>Th\u1ef1c ch\u1ea5t, \"\u0111\u1ed5i d\u1ea5u\" l\u00e0 t\u00ecm b\u00f9 t\u1edbi \\(1111\\) (v\u00ec d\u1ea5u-ch\u00e2n + b\u00f9 1 = \\(1111\\)), c\u00f2n b\u00f9 1 c\u1ed9ng 1 th\u00ec ra b\u00f9 2 t\u1edbi \\(10000\\).</p> <p>V\u00ed d\u1ee5 d\u00f9ng 4 bit, nh\u01b0ng \u00e1p d\u1ee5ng cho m\u1ecdi s\u1ed1 nh\u1ecb ph\u00e2n.</p>"},{"location":"chapter_divide_and_conquer/","title":"Divide and conquer","text":""},{"location":"chapter_divide_and_conquer/#divide-and-conquer","title":"Divide and conquer","text":"<p>Abstract</p> <p>Difficult problems are decomposed layer by layer, with each decomposition making them simpler.</p> <p>Divide and conquer unveils a profound truth: begin with simplicity, and complexity dissolves.</p>"},{"location":"chapter_divide_and_conquer/binary_search_recur/","title":"12.2 Divide and conquer search strategy","text":""},{"location":"chapter_divide_and_conquer/binary_search_recur/#divide-and-conquer-search-strategy","title":"Divide and conquer search strategy","text":"<p>We have learned that search algorithms fall into two main categories.</p> <ul> <li>Brute-force search: It is implemented by traversing the data structure, with a time complexity of \\(O(n)\\).</li> <li>Adaptive search: It utilizes a unique data organization form or prior information, and its time complexity can reach \\(O(\\log n)\\) or even \\(O(1)\\).</li> </ul> <p>In fact, search algorithms with a time complexity of \\(O(\\log n)\\) are usually based on the divide-and-conquer strategy, such as binary search and trees.</p> <ul> <li>Each step of binary search divides the problem (searching for a target element in an array) into a smaller problem (searching for the target element in half of the array), continuing until the array is empty or the target element is found.</li> <li>Trees represent the divide-and-conquer idea, where in data structures like binary search trees, AVL trees, and heaps, the time complexity of various operations is \\(O(\\log n)\\).</li> </ul> <p>The divide-and-conquer strategy of binary search is as follows.</p> <ul> <li>The problem can be divided: Binary search recursively divides the original problem (searching in an array) into subproblems (searching in half of the array), achieved by comparing the middle element with the target element.</li> <li>Subproblems are independent: In binary search, each round handles one subproblem, unaffected by other subproblems.</li> <li>The solutions of subproblems do not need to be merged: Binary search aims to find a specific element, so there is no need to merge the solutions of subproblems. When a subproblem is solved, the original problem is also solved.</li> </ul> <p>Divide-and-conquer can enhance search efficiency because brute-force search can only eliminate one option per round, whereas divide-and-conquer can eliminate half of the options.</p>"},{"location":"chapter_divide_and_conquer/binary_search_recur/#implementing-binary-search-based-on-divide-and-conquer","title":"Implementing binary search based on divide-and-conquer","text":"<p>In previous chapters, binary search was implemented based on iteration. Now, we implement it based on divide-and-conquer (recursion).</p> <p>Question</p> <p>Given an ordered array <code>nums</code> of length \\(n\\), where all elements are unique, please find the element <code>target</code>.</p> <p>From a divide-and-conquer perspective, we denote the subproblem corresponding to the search interval \\([i, j]\\) as \\(f(i, j)\\).</p> <p>Starting from the original problem \\(f(0, n-1)\\), perform the binary search through the following steps.</p> <ol> <li>Calculate the midpoint \\(m\\) of the search interval \\([i, j]\\), and use it to eliminate half of the search interval.</li> <li>Recursively solve the subproblem reduced by half in size, which could be \\(f(i, m-1)\\) or \\(f(m+1, j)\\).</li> <li>Repeat steps <code>1.</code> and <code>2.</code>, until <code>target</code> is found or the interval is empty and returns.</li> </ol> <p>The figure below shows the divide-and-conquer process of binary search for element \\(6\\) in an array.</p> <p></p> <p>In the implementation code, we declare a recursive function <code>dfs()</code> to solve the problem \\(f(i, j)\\):</p> <pre><code>[file]{binary_search_recur}-[class]{}-[func]{binary_search}\n</code></pre>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/","title":"12.3 Building binary tree problem","text":""},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#building-a-binary-tree-problem","title":"Building a binary tree problem","text":"<p>Question</p> <p>Given the pre-order traversal <code>preorder</code> sequence and the in-order traversal <code>inorder</code> sequence of a binary tree, construct the binary tree and return its root node. Assume there are no duplicate node values in the binary tree (as shown in the figure below).</p> <p></p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#determining-if-it-is-a-divide-and-conquer-problem","title":"Determining if it is a divide-and-conquer problem","text":"<p>The original problem of building a binary tree from the <code>preorder</code> and the <code>inorder</code> sequences is a typical divide-and-conquer problem.</p> <ul> <li>The problem can be decomposed: From the perspective of divide-and-conquer, we can divide the original problem into two subproblems\u2014building the left subtree and building the right subtree\u2014plus one operation of initializing the root node. For each subtree (subproblem), we continue applying the same approach, partitioning it into smaller subtrees (subproblems), until reaching the smallest subproblem (an empty subtree).</li> <li>The subproblems are independent: The left and right subtrees do not overlap. When building the left subtree, we only need the segments of the in-order and pre-order traversals that correspond to the left subtree. The same approach applies to the right subtree.</li> <li>Solutions to subproblems can be combined: Once we have constructed the left and right subtrees (the subproblem solutions), we can attach them to the root node to obtain the solution to the original problem.</li> </ul>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#how-to-divide-the-subtrees","title":"How to divide the subtrees","text":"<p>Based on the above analysis, this problem can be solved using divide-and-conquer. However, how do we use the pre-order traversal <code>preorder</code> sequence and the in-order traversal <code>inorder</code> sequence to divide the left and right subtrees?</p> <p>By definition, both the <code>preorder</code> and <code>inorder</code> sequences can be divided into three parts:</p> <ul> <li>Pre-order traversal: <code>[ Root | Left Subtree | Right Subtree ]</code>. For example, in the figure, the tree corresponds to <code>[ 3 | 9 | 2 1 7 ]</code>.</li> <li>In-order traversal: <code>[ Left Subtree | Root | Right Subtree ]</code>. For example, in the figure, the tree corresponds to <code>[ 9 | 3 | 1 2 7 ]</code>.</li> </ul> <p>Using the data from the preceding figure, we can follow the steps shown in the next figure to obtain the division results:</p> <ol> <li>The first element 3 in the pre-order traversal is the value of the root node.</li> <li>Find the index of the root node 3 in the <code>inorder</code> sequence, and use this index to split <code>inorder</code> into <code>[ 9 | 3 \uff5c 1 2 7 ]</code>.</li> <li>According to the split of the <code>inorder</code> sequence, it is straightforward to determine that the left and right subtrees contain 1 and 3 nodes, respectively, so we can split the <code>preorder</code> sequence into <code>[ 3 | 9 | 2 1 7 ]</code> accordingly.</li> </ol> <p></p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#describing-subtree-ranges-based-on-variables","title":"Describing subtree ranges based on variables","text":"<p>Based on the above division method, we have now obtained the index ranges of the root, left subtree, and right subtree in the <code>preorder</code> and <code>inorder</code> sequences. To describe these index ranges, we use several pointer variables.</p> <ul> <li>Let the index of the current tree's root node in the <code>preorder</code> sequence be denoted as \\(i\\).</li> <li>Let the index of the current tree's root node in the <code>inorder</code> sequence be denoted as \\(m\\).</li> <li>Let the index range of the current tree in the <code>inorder</code> sequence be denoted as \\([l, r]\\).</li> </ul> <p>As shown in the table below, these variables represent the root node\u2019s index in the <code>preorder</code> sequence and the index ranges of the subtrees in the <code>inorder</code> sequence.</p> <p> Table  \u00a0 Indexes of the root node and subtrees in pre-order and in-order traversals </p> Root node index in <code>preorder</code> Subtree index range in <code>inorder</code> Current tree \\(i\\) \\([l, r]\\) Left subtree \\(i + 1\\) \\([l, m-1]\\) Right subtree \\(i + 1 + (m - l)\\) \\([m+1, r]\\) <p>Please note that \\((m-l)\\) in the right subtree root index represents \"the number of nodes in the left subtree.\" It may help to consult the figure below for a clearer understanding.</p> <p></p>"},{"location":"chapter_divide_and_conquer/build_binary_tree_problem/#code-implementation","title":"Code implementation","text":"<p>To improve the efficiency of querying \\(m\\), we use a hash table <code>hmap</code> to store the mapping from elements in the <code>inorder</code> sequence to their indexes:</p> <pre><code>[file]{build_tree}-[class]{}-[func]{build_tree}\n</code></pre> <p>The figure below shows the recursive process of building the binary tree. Each node is created during the \"descending\" phase of the recursion, and each edge (reference) is formed during the \"ascending\" phase.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Each recursive function's division of the <code>preorder</code> and <code>inorder</code> sequences is illustrated in the figure below.</p> <p></p> <p>Assuming the binary tree has \\(n\\) nodes, initializing each node (calling the recursive function <code>dfs()</code>) takes \\(O(1)\\) time. Therefore, the overall time complexity is \\(O(n)\\).</p> <p>Because the hash table stores the mapping from <code>inorder</code> elements to their indexes, it requires \\(O(n)\\) space. In the worst case, if the binary tree degenerates into a linked list, the recursive depth can reach \\(n\\), consuming \\(O(n)\\) stack space. Hence, the overall space complexity is \\(O(n)\\).</p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/","title":"12.1 Divide and conquer algorithms","text":""},{"location":"chapter_divide_and_conquer/divide_and_conquer/#divide-and-conquer-algorithms","title":"Divide and conquer algorithms","text":"<p>Divide and conquer is an important and popular algorithm strategy. As the name suggests, the algorithm is typically implemented recursively and consists of two steps: \"divide\" and \"conquer\".</p> <ol> <li>Divide (partition phase): Recursively break down the original problem into two or more smaller sub-problems until the smallest sub-problem is reached.</li> <li>Conquer (merge phase): Starting from the smallest sub-problem with known solution, we construct the solution to the original problem by merging the solutions of sub-problems in a bottom-up manner.</li> </ol> <p>As shown in the figure below, \"merge sort\" is one of the typical applications of the divide and conquer strategy.</p> <ol> <li>Divide: Recursively divide the original array (original problem) into two sub-arrays (sub-problems), until the sub-array has only one element (smallest sub-problem).</li> <li>Conquer: Merge the ordered sub-arrays (solutions to the sub-problems) from bottom to top to obtain an ordered original array (solution to the original problem).</li> </ol> <p></p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#how-to-identify-divide-and-conquer-problems","title":"How to identify divide and conquer problems","text":"<p>Whether a problem is suitable for a divide-and-conquer solution can usually be decided based on the following criteria.</p> <ol> <li>The problem can be broken down into smaller ones: The original problem can be divided into smaller, similar sub-problems and such process can be recursively done in the same manner.</li> <li>Sub-problems are independent: There is no overlap between sub-problems, and they are independent and can be solved separately.</li> <li>Solutions to sub-problems can be merged: The solution to the original problem is derived by combining the solutions of the sub-problems.</li> </ol> <p>Clearly, merge sort meets these three criteria.</p> <ol> <li>The problem can be broken down into smaller ones: Recursively divide the array (original problem) into two sub-arrays (sub-problems).</li> <li>Sub-problems are independent: Each sub-array can be sorted independently (sub-problems can be solved independently).</li> <li>Solutions to sub-problems can be merged: Two ordered sub-arrays (solutions to the sub-problems) can be merged into one ordered array (solution to the original problem).</li> </ol>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#improve-efficiency-through-divide-and-conquer","title":"Improve efficiency through divide and conquer","text":"<p>The divide-and-conquer strategy not only effectively solves algorithm problems but also often enhances efficiency. In sorting algorithms, quick sort, merge sort, and heap sort are faster than selection sort, bubble sort, and insertion sort because they apply the divide-and-conquer strategy.</p> <p>We may have a question in mind: Why can divide and conquer improve algorithm efficiency, and what is the underlying logic? In other words, why is breaking a problem into sub-problems, solving them, and combining their solutions to address the original problem offer more efficiency than directly solving the original problem? This question can be analyzed from two aspects: operation count and parallel computation.</p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#optimization-of-operation-count","title":"Optimization of operation count","text":"<p>Taking \"bubble sort\" as an example, it requires \\(O(n^2)\\) time to process an array of length \\(n\\). Suppose we divide the array from the midpoint into two sub-arrays as shown in the figure below, such division requires \\(O(n)\\) time. Sorting each sub-array requires \\(O((n / 2)^2)\\) time. And merging the two sub-arrays requires \\(O(n)\\) time. Thus, the overall time complexity is:</p> \\[ O(n + (\\frac{n}{2})^2 \\times 2 + n) = O(\\frac{n^2}{2} + 2n) \\] <p></p> <p>Let's calculate the following inequality, where the left side represents the total number of operations before division and the right side represents the total number of operations after division, respectively:</p> \\[ \\begin{aligned} n^2 &amp; &gt; \\frac{n^2}{2} + 2n \\newline n^2 - \\frac{n^2}{2} - 2n &amp; &gt; 0 \\newline n(n - 4) &amp; &gt; 0 \\end{aligned} \\] <p>This means that when \\(n &gt; 4\\), the number of operations after partitioning is fewer, leading to better performance. Please note that the time complexity after partitioning is still quadratic \\(O(n^2)\\), but the constant factor in the complexity has decreased.</p> <p>We can go even further. How about keeping dividing the sub-arrays from their midpoints into two sub-arrays until the sub-arrays have only one element left? This idea is actually \"merge sort,\" with a time complexity of \\(O(n \\log n)\\).</p> <p>Let's try something a bit different again. How about splitting into more partitions instead of just two? For example, we evenly divide the original array into \\(k\\) sub-arrays? This approach is very similar to \"bucket sort,\" which is very suitable for sorting massive data. Theoretically, the time complexity can reach \\(O(n + k)\\).</p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#optimization-through-parallel-computation","title":"Optimization through parallel computation","text":"<p>We know that the sub-problems generated by divide and conquer are independent of each other, which means that they can be solved in parallel. As a result, divide and conquer not only reduces the algorithm's time complexity, but also facilitates parallel optimization by modern operating systems.</p> <p>Parallel optimization is particularly effective in environments with multiple cores or processors. As the system can process multiple sub-problems simultaneously, fully utilizing computing resources, the overall runtime is significantly reduced.</p> <p>For example, in the \"bucket sort\" shown in the figure below, we break massive data evenly into various buckets. The jobs of sorting each bucket can be allocated to available computing units. Once all jobs are done, all sorted buckets are merged to produce the final result.</p> <p></p>"},{"location":"chapter_divide_and_conquer/divide_and_conquer/#common-applications-of-divide-and-conquer","title":"Common applications of divide and conquer","text":"<p>Divide and conquer can be used to solve many classic algorithm problems.</p> <ul> <li>Finding the closest pair of points: This algorithm works by dividing the set of points into two halves. Then it recursively finds the closest pair in each half. Finally it considers pairs that span the two halves to find the overall closest pair.</li> <li>Large integer multiplication: One algorithm is called Karatsuba. It breaks down large integer multiplication into several smaller integer multiplications and additions.</li> <li>Matrix multiplication: One example is the Strassen algorithm. It breaks down a large matrix multiplication into multiple small matrix multiplications and additions.</li> <li>Tower of Hanoi problem: The Tower of Hanoi problem can be solved recursively, a typical application of the divide-and-conquer strategy.</li> <li>Solving inversion pairs: In a sequence, if a preceding number is greater than a following number, then these two numbers constitute an inversion pair. Solving inversion pair problem can utilize the idea of divide and conquer, with the aid of merge sort.</li> </ul> <p>Divide and conquer is also widely applied in the design of algorithms and data structures.</p> <ul> <li>Binary search: Binary search divides a sorted array into two halves from the midpoint index. And then based on the comparison result between the target value and the middle element value, one half is discarded. The search continues on the remaining half with the same process until the target is found or there is no remaining element.</li> <li>Merge sort: Already introduced at the beginning of this section, no further elaboration is needed.</li> <li>Quicksort: Quicksort picks a pivot value to divide the array into two sub-arrays, one with elements smaller than the pivot and the other with elements larger than the pivot. Such process goes on against each of these two sub-arrays until they hold only one element.</li> <li>Bucket sort: The basic idea of bucket sort is to distribute data to multiple buckets. After sorting the elements within each bucket, retrieve the elements from the buckets in order to obtain an ordered array.</li> <li>Trees: For example, binary search trees, AVL trees, red-black trees, B-trees, and B+ trees, etc. Their operations, such as search, insertion, and deletion, can all be regarded as applications of the divide-and-conquer strategy.</li> <li>Heap: A heap is a special type of complete binary tree. Its various operations, such as insertion, deletion, and heapify, actually imply the idea of divide and conquer.</li> <li>Hash table: Although hash tables do not directly apply divide and conquer, some hash collision resolution solutions indirectly apply the strategy. For example, long lists in chained addressing may be converted to red-black trees to improve query efficiency.</li> </ul> <p>It can be seen that divide and conquer is a subtly pervasive algorithmic idea, embedded within various algorithms and data structures.</p>"},{"location":"chapter_divide_and_conquer/hanota_problem/","title":"12.4 Tower of Hanoi Problem","text":""},{"location":"chapter_divide_and_conquer/hanota_problem/#tower-of-hanoi-problem","title":"Tower of Hanoi Problem","text":"<p>In both merge sort and binary tree construction, we break the original problem into two subproblems, each half the size of the original problem. However, for the Tower of Hanoi, we adopt a different decomposition strategy.</p> <p>Question</p> <p>We are given three pillars, denoted as <code>A</code>, <code>B</code>, and <code>C</code>. Initially, pillar <code>A</code> has \\(n\\) discs, arranged from top to bottom in ascending size. Our task is to move these \\(n\\) discs to pillar <code>C</code>, maintaining their original order (as shown in the figure below). The following rules apply during the movement:</p> <ol> <li>A disc can be removed only from the top of a pillar and must be placed on the top of another pillar.</li> <li>Only one disc can be moved at a time.</li> <li>A smaller disc must always be on top of a larger disc.</li> </ol> <p></p> <p>We denote the Tower of Hanoi problem of size \\(i\\) as \\(f(i)\\). For example, \\(f(3)\\) represents moving \\(3\\) discs from pillar <code>A</code> to pillar <code>C</code>.</p>"},{"location":"chapter_divide_and_conquer/hanota_problem/#consider-the-base-cases","title":"Consider the base cases","text":"<p>As shown in the figure below, for the problem \\(f(1)\\)\u2014which has only one disc\u2014we can directly move it from <code>A</code> to <code>C</code>.</p> &lt;1&gt;&lt;2&gt; <p></p> <p></p> <p>For \\(f(2)\\)\u2014which has two discs\u2014we rely on pillar <code>B</code> to help keep the smaller disc above the larger disc, as illustrated in the following figure:</p> <ol> <li>First, move the smaller disc from <code>A</code> to <code>B</code>.</li> <li>Then move the larger disc from <code>A</code> to <code>C</code>.</li> <li>Finally, move the smaller disc from <code>B</code> to <code>C</code>.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p>The process of solving \\(f(2)\\) can be summarized as: moving two discs from <code>A</code> to <code>C</code> with the help of <code>B</code>. Here, <code>C</code> is called the target pillar, and <code>B</code> is called the buffer pillar.</p>"},{"location":"chapter_divide_and_conquer/hanota_problem/#decomposition-of-subproblems","title":"Decomposition of subproblems","text":"<p>For the problem \\(f(3)\\)\u2014that is, when there are three discs\u2014the situation becomes slightly more complicated.</p> <p>Since we already know the solutions to \\(f(1)\\) and \\(f(2)\\), we can adopt a divide-and-conquer perspective and treat the top two discs on <code>A</code> as a single unit, performing the steps shown in the figure below. This allows the three discs to be successfully moved from <code>A</code> to <code>C</code>.</p> <ol> <li>Let <code>B</code> be the target pillar and <code>C</code> the buffer pillar, then move the two discs from <code>A</code> to <code>B</code>.</li> <li>Move the remaining disc from <code>A</code> directly to <code>C</code>.</li> <li>Let <code>C</code> be the target pillar and <code>A</code> the buffer pillar, then move the two discs from <code>B</code> to <code>C</code>.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p>Essentially, we decompose \\(f(3)\\) into two \\(f(2)\\) subproblems and one \\(f(1)\\) subproblem. By solving these three subproblems in sequence, the original problem is solved, indicating that the subproblems are independent and their solutions can be merged.</p> <p>From this, we can summarize the divide-and-conquer strategy for the Tower of Hanoi, illustrated in the figure below. We divide the original problem \\(f(n)\\) into two subproblems \\(f(n-1)\\) and one subproblem \\(f(1)\\), and solve these three subproblems in the following order:</p> <ol> <li>Move \\(n-1\\) discs from <code>A</code> to <code>B</code>, using <code>C</code> as a buffer. </li> <li>Move the remaining disc directly from <code>A</code> to <code>C</code>.</li> <li>Move \\(n-1\\) discs from <code>B</code> to <code>C</code>, using <code>A</code> as a buffer. </li> </ol> <p>For each \\(f(n-1)\\) subproblem, we can apply the same recursive partition until we reach the smallest subproblem \\(f(1)\\). Because \\(f(1)\\) is already known to require just a single move, it is trivial to solve.</p> <p></p>"},{"location":"chapter_divide_and_conquer/hanota_problem/#code-implementation","title":"Code implementation","text":"<p>In the code, we define a recursive function <code>dfs(i, src, buf, tar)</code> which moves the top \\(i\\) discs from pillar <code>src</code> to pillar <code>tar</code>, using pillar <code>buf</code> as a buffer:</p> <pre><code>[file]{hanota}-[class]{}-[func]{solve_hanota}\n</code></pre> <p>As shown in the figure below, the Tower of Hanoi problem can be visualized as a recursive tree of height \\(n\\). Each node represents a subproblem, corresponding to a call to <code>dfs()</code>, Hence, the time complexity is \\(O(2^n)\\), and the space complexity is \\(O(n)\\).</p> <p></p> <p>Quote</p> <p>The Tower of Hanoi originates from an ancient legend. In a temple in ancient India, monks had three tall diamond pillars and \\(64\\) differently sized golden discs. They believed that when the last disc was correctly placed, the world would end.</p> <p>However, even if the monks moved one disc every second, it would take about \\(2^{64} \\approx 1.84\u00d710^{19}\\) \u2014approximately 585 billion years\u2014far exceeding current estimates of the age of the universe. Thus, if the legend is true, we probably do not need to worry about the world ending.</p>"},{"location":"chapter_divide_and_conquer/summary/","title":"12.5 Summary","text":""},{"location":"chapter_divide_and_conquer/summary/#summary","title":"Summary","text":"<ul> <li>Divide and conquer is a common algorithm design strategy that consists of two stages\u2014divide (partition) and conquer (merge)\u2014and is generally implemented using recursion.</li> <li>To determine whether a problem is suited for a divide and conquer approach, we check if the problem can be decomposed, whether the subproblems are independent, and whether the subproblems can be merged.</li> <li>Merge sort is a typical example of the divide and conquer strategy. It recursively splits an array into two equal-length subarrays until only one element remains, and then merges these subarrays layer by layer to complete the sorting.</li> <li>Introducing the divide and conquer strategy often improves algorithm efficiency. On one hand, it reduces the number of operations; on the other hand, it facilitates parallel optimization of the system after division.</li> <li>Divide and conquer can be applied to numerous algorithmic problems and is widely used in data structures and algorithm design, appearing in many scenarios.</li> <li>Compared to brute force search, adaptive search is more efficient. Search algorithms with a time complexity of \\(O(\\log n)\\) are typically based on the divide and conquer strategy.</li> <li>Binary search is another classic application of the divide-and-conquer strategy. It does not involve merging subproblem solutions and can be implemented via a recursive divide-and-conquer approach.</li> <li>In the problem of constructing binary trees, building the tree (the original problem) can be divided into building the left subtree and right subtree (the subproblems). This can be achieved by partitioning the index ranges of the preorder and inorder traversals.</li> <li>In the Tower of Hanoi problem, a problem of size \\(n\\) can be broken down into two subproblems of size \\(n-1\\) and one subproblem of size \\(1\\). By solving these three subproblems in sequence, the original problem is resolved.</li> </ul>"},{"location":"chapter_dynamic_programming/","title":"Dynamic programming","text":""},{"location":"chapter_dynamic_programming/#dynamic-programming","title":"Dynamic programming","text":"<p>Abstract</p> <p>Streams merge into rivers, and rivers merge into the sea.</p> <p>Dynamic programming weaves smaller problems\u2019 solutions into larger ones, guiding us step by step toward the far shore\u2014where the ultimate answer awaits.</p>"},{"location":"chapter_dynamic_programming/dp_problem_features/","title":"14.2 Characteristics of DP problems","text":""},{"location":"chapter_dynamic_programming/dp_problem_features/#characteristics-of-dynamic-programming-problems","title":"Characteristics of dynamic programming problems","text":"<p>In the previous section, we learned how dynamic programming solves the original problem by decomposing it into subproblems. In fact, subproblem decomposition is a general algorithmic approach, with different emphases in divide and conquer, dynamic programming, and backtracking.</p> <ul> <li>Divide and conquer algorithms recursively divide the original problem into multiple independent subproblems until the smallest subproblems are reached, and combine the solutions of the subproblems during backtracking to ultimately obtain the solution to the original problem.</li> <li>Dynamic programming also decomposes the problem recursively, but the main difference from divide and conquer algorithms is that the subproblems in dynamic programming are interdependent, and many overlapping subproblems will appear during the decomposition process.</li> <li>Backtracking algorithms exhaust all possible solutions through trial and error and avoid unnecessary search branches by pruning. The solution to the original problem consists of a series of decision steps, and we can consider each sub-sequence before each decision step as a subproblem.</li> </ul> <p>In fact, dynamic programming is commonly used to solve optimization problems, which not only include overlapping subproblems but also have two other major characteristics: optimal substructure and statelessness.</p>"},{"location":"chapter_dynamic_programming/dp_problem_features/#optimal-substructure","title":"Optimal substructure","text":"<p>We make a slight modification to the stair climbing problem to make it more suitable to demonstrate the concept of optimal substructure.</p> <p>Minimum cost of climbing stairs</p> <p>Given a staircase, you can step up 1 or 2 steps at a time, and each step on the staircase has a non-negative integer representing the cost you need to pay at that step. Given a non-negative integer array \\(cost\\), where \\(cost[i]\\) represents the cost you need to pay at the \\(i\\)-th step, \\(cost[0]\\) is the ground (starting point). What is the minimum cost required to reach the top?</p> <p>As shown in the figure below, if the costs of the 1<sup>st</sup>, 2<sup>nd</sup>, and 3<sup>rd</sup> steps are \\(1\\), \\(10\\), and \\(1\\) respectively, then the minimum cost to climb to the 3<sup>rd</sup> step from the ground is \\(2\\).</p> <p></p> <p>Let \\(dp[i]\\) be the cumulative cost of climbing to the \\(i\\)-th step. Since the \\(i\\)-th step can only come from the \\(i-1\\) or \\(i-2\\) step, \\(dp[i]\\) can only be either \\(dp[i-1] + cost[i]\\) or \\(dp[i-2] + cost[i]\\). To minimize the cost, we should choose the smaller of the two:</p> \\[ dp[i] = \\min(dp[i-1], dp[i-2]) + cost[i] \\] <p>This leads us to the meaning of optimal substructure: The optimal solution to the original problem is constructed from the optimal solutions of subproblems.</p> <p>This problem obviously has optimal substructure: we select the better one from the optimal solutions of the two subproblems, \\(dp[i-1]\\) and \\(dp[i-2]\\), and use it to construct the optimal solution for the original problem \\(dp[i]\\).</p> <p>So, does the stair climbing problem from the previous section have optimal substructure? Its goal is to solve for the number of solutions, which seems to be a counting problem, but if we ask in another way: \"Solve for the maximum number of solutions\". We surprisingly find that although the problem has changed, the optimal substructure has emerged: the maximum number of solutions at the \\(n\\)-th step equals the sum of the maximum number of solutions at the \\(n-1\\) and \\(n-2\\) steps. Thus, the interpretation of optimal substructure is quite flexible and will have different meanings in different problems.</p> <p>According to the state transition equation, and the initial states \\(dp[1] = cost[1]\\) and \\(dp[2] = cost[2]\\), we can obtain the dynamic programming code:</p> <pre><code>[file]{min_cost_climbing_stairs_dp}-[class]{}-[func]{min_cost_climbing_stairs_dp}\n</code></pre> <p>The figure below shows the dynamic programming process for the above code.</p> <p></p> <p>This problem can also be space-optimized, compressing one dimension to zero, reducing the space complexity from \\(O(n)\\) to \\(O(1)\\):</p> <pre><code>[file]{min_cost_climbing_stairs_dp}-[class]{}-[func]{min_cost_climbing_stairs_dp_comp}\n</code></pre>"},{"location":"chapter_dynamic_programming/dp_problem_features/#statelessness","title":"Statelessness","text":"<p>Statelessness is one of the important characteristics that make dynamic programming effective in solving problems. Its definition is: Given a certain state, its future development is only related to the current state and unrelated to all past states experienced.</p> <p>Taking the stair climbing problem as an example, given state \\(i\\), it will develop into states \\(i+1\\) and \\(i+2\\), corresponding to jumping 1 step and 2 steps respectively. When making these two choices, we do not need to consider the states before state \\(i\\), as they do not affect the future of state \\(i\\).</p> <p>However, if we add a constraint to the stair climbing problem, the situation changes.</p> <p>Stair climbing with constraints</p> <p>Given a staircase with \\(n\\) steps, you can go up 1 or 2 steps each time, but you cannot jump 1 step twice in a row. How many ways are there to climb to the top?</p> <p>As shown in the figure below, there are only 2 feasible options for climbing to the 3<sup>rd</sup> step, among which the option of jumping 1 step three times in a row does not meet the constraint condition and is therefore discarded.</p> <p></p> <p>In this problem, if the last round was a jump of 1 step, then the next round must be a jump of 2 steps. This means that the next step choice cannot be independently determined by the current state (current stair step), but also depends on the previous state (last round's stair step).</p> <p>It is not difficult to find that this problem no longer satisfies statelessness, and the state transition equation \\(dp[i] = dp[i-1] + dp[i-2]\\) also fails, because \\(dp[i-1]\\) represents this round's jump of 1 step, but it includes many \"last round was a jump of 1 step\" options, which, to meet the constraint, cannot be directly included in \\(dp[i]\\).</p> <p>For this, we need to expand the state definition: State \\([i, j]\\) represents being on the \\(i\\)-th step and the last round was a jump of \\(j\\) steps, where \\(j \\in \\{1, 2\\}\\). This state definition effectively distinguishes whether the last round was a jump of 1 step or 2 steps, and we can judge accordingly where the current state came from.</p> <ul> <li>When the last round was a jump of 1 step, the round before last could only choose to jump 2 steps, that is, \\(dp[i, 1]\\) can only be transferred from \\(dp[i-1, 2]\\).</li> <li>When the last round was a jump of 2 steps, the round before last could choose to jump 1 step or 2 steps, that is, \\(dp[i, 2]\\) can be transferred from \\(dp[i-2, 1]\\) or \\(dp[i-2, 2]\\).</li> </ul> <p>As shown in the figure below, \\(dp[i, j]\\) represents the number of solutions for state \\([i, j]\\). At this point, the state transition equation is:</p> \\[ \\begin{cases} dp[i, 1] = dp[i-1, 2] \\\\ dp[i, 2] = dp[i-2, 1] + dp[i-2, 2] \\end{cases} \\] <p></p> <p>In the end, returning \\(dp[n, 1] + dp[n, 2]\\) will do, the sum of the two representing the total number of solutions for climbing to the \\(n\\)-th step:</p> <pre><code>[file]{climbing_stairs_constraint_dp}-[class]{}-[func]{climbing_stairs_constraint_dp}\n</code></pre> <p>In the above cases, since we only need to consider the previous state, we can still meet the statelessness by expanding the state definition. However, some problems have very serious \"state effects\".</p> <p>Stair climbing with obstacle generation</p> <p>Given a staircase with \\(n\\) steps, you can go up 1 or 2 steps each time. It is stipulated that when climbing to the \\(i\\)-th step, the system automatically places an obstacle on the \\(2i\\)-th step, and thereafter all rounds are not allowed to jump to the \\(2i\\)-th step. For example, if the first two rounds jump to the 2<sup>nd</sup> and 3<sup>rd</sup> steps, then later you cannot jump to the 4<sup>th</sup> and 6<sup>th</sup> steps. How many ways are there to climb to the top?</p> <p>In this problem, the next jump depends on all past states, as each jump places obstacles on higher steps, affecting future jumps. For such problems, dynamic programming often struggles to solve.</p> <p>In fact, many complex combinatorial optimization problems (such as the traveling salesman problem) do not satisfy statelessness. For these kinds of problems, we usually choose to use other methods, such as heuristic search, genetic algorithms, reinforcement learning, etc., to obtain usable local optimal solutions within a limited time.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/","title":"14.3 DP problem-solving approach\u00b6","text":""},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#dynamic-programming-problem-solving-approach","title":"Dynamic programming problem-solving approach","text":"<p>The last two sections introduced the main characteristics of dynamic programming problems. Next, let's explore two more practical issues together.</p> <ol> <li>How to determine whether a problem is a dynamic programming problem?</li> <li>What are the complete steps to solve a dynamic programming problem?</li> </ol>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#problem-determination","title":"Problem determination","text":"<p>Generally speaking, if a problem contains overlapping subproblems, optimal substructure, and exhibits no aftereffects, it is usually suitable for dynamic programming solutions. However, it is often difficult to directly extract these characteristics from the problem description. Therefore, we usually relax the conditions and first observe whether the problem is suitable for resolution using backtracking (exhaustive search).</p> <p>Problems suitable for backtracking usually fit the \"decision tree model\", which can be described using a tree structure, where each node represents a decision, and each path represents a sequence of decisions.</p> <p>In other words, if the problem contains explicit decision concepts, and the solution is produced through a series of decisions, then it fits the decision tree model and can usually be solved using backtracking.</p> <p>On this basis, there are some \"bonus points\" for determining dynamic programming problems.</p> <ul> <li>The problem contains descriptions of maximization (minimization) or finding the most (least) optimal solution.</li> <li>The problem's states can be represented using a list, multi-dimensional matrix, or tree, and a state has a recursive relationship with its surrounding states.</li> </ul> <p>Correspondingly, there are also some \"penalty points\".</p> <ul> <li>The goal of the problem is to find all possible solutions, not just the optimal solution.</li> <li>The problem description has obvious characteristics of permutations and combinations, requiring the return of specific multiple solutions.</li> </ul> <p>If a problem fits the decision tree model and has relatively obvious \"bonus points\", we can assume it is a dynamic programming problem and verify it during the solution process.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#problem-solving-steps","title":"Problem-solving steps","text":"<p>The dynamic programming problem-solving process varies with the nature and difficulty of the problem but generally follows these steps: describe decisions, define states, establish a \\(dp\\) table, derive state transition equations, and determine boundary conditions, etc.</p> <p>To illustrate the problem-solving steps more vividly, we use a classic problem, \"Minimum Path Sum\", as an example.</p> <p>Question</p> <p>Given an \\(n \\times m\\) two-dimensional grid <code>grid</code>, each cell in the grid contains a non-negative integer representing the cost of that cell. The robot starts from the top-left cell and can only move down or right at each step until it reaches the bottom-right cell. Return the minimum path sum from the top-left to the bottom-right.</p> <p>The figure below shows an example, where the given grid's minimum path sum is \\(13\\).</p> <p></p> <p>First step: Think about each round of decisions, define the state, and thereby obtain the \\(dp\\) table</p> <p>Each round of decisions in this problem is to move one step down or right from the current cell. Suppose the row and column indices of the current cell are \\([i, j]\\), then after moving down or right, the indices become \\([i+1, j]\\) or \\([i, j+1]\\). Therefore, the state should include two variables: the row index and the column index, denoted as \\([i, j]\\).</p> <p>The state \\([i, j]\\) corresponds to the subproblem: the minimum path sum from the starting point \\([0, 0]\\) to \\([i, j]\\), denoted as \\(dp[i, j]\\).</p> <p>Thus, we obtain the two-dimensional \\(dp\\) matrix shown in the figure below, whose size is the same as the input grid \\(grid\\).</p> <p></p> <p>Note</p> <p>Dynamic programming and backtracking can be described as a sequence of decisions, while a state consists of all decision variables. It should include all variables that describe the progress of solving the problem, containing enough information to derive the next state.</p> <p>Each state corresponds to a subproblem, and we define a \\(dp\\) table to store the solutions to all subproblems. Each independent variable of the state is a dimension of the \\(dp\\) table. Essentially, the \\(dp\\) table is a mapping between states and solutions to subproblems.</p> <p>Second step: Identify the optimal substructure, then derive the state transition equation</p> <p>For the state \\([i, j]\\), it can only be derived from the cell above \\([i-1, j]\\) or the cell to the left \\([i, j-1]\\). Therefore, the optimal substructure is: the minimum path sum to reach \\([i, j]\\) is determined by the smaller of the minimum path sums of \\([i, j-1]\\) and \\([i-1, j]\\).</p> <p>Based on the above analysis, the state transition equation shown in the figure below can be derived:</p> \\[ dp[i, j] = \\min(dp[i-1, j], dp[i, j-1]) + grid[i, j] \\] <p></p> <p>Note</p> <p>Based on the defined \\(dp\\) table, think about the relationship between the original problem and the subproblems, and find out how to construct the optimal solution to the original problem from the optimal solutions to the subproblems, i.e., the optimal substructure.</p> <p>Once we have identified the optimal substructure, we can use it to build the state transition equation.</p> <p>Third step: Determine boundary conditions and state transition order</p> <p>In this problem, the states in the first row can only come from the states to their left, and the states in the first column can only come from the states above them, so the first row \\(i = 0\\) and the first column \\(j = 0\\) are the boundary conditions.</p> <p>As shown in the figure below, since each cell is derived from the cell to its left and the cell above it, we use loops to traverse the matrix, the outer loop iterating over the rows and the inner loop iterating over the columns.</p> <p></p> <p>Note</p> <p>Boundary conditions are used in dynamic programming to initialize the \\(dp\\) table, and in search to prune.</p> <p>The core of the state transition order is to ensure that when calculating the solution to the current problem, all the smaller subproblems it depends on have already been correctly calculated.</p> <p>Based on the above analysis, we can directly write the dynamic programming code. However, the decomposition of subproblems is a top-down approach, so implementing it in the order of \"brute-force search \u2192 memoized search \u2192 dynamic programming\" is more in line with habitual thinking.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#method-1-brute-force-search","title":"Method 1: Brute-force search","text":"<p>Start searching from the state \\([i, j]\\), constantly decomposing it into smaller states \\([i-1, j]\\) and \\([i, j-1]\\). The recursive function includes the following elements.</p> <ul> <li>Recursive parameter: state \\([i, j]\\).</li> <li>Return value: the minimum path sum from \\([0, 0]\\) to \\([i, j]\\) \\(dp[i, j]\\).</li> <li>Termination condition: when \\(i = 0\\) and \\(j = 0\\), return the cost \\(grid[0, 0]\\).</li> <li>Pruning: when \\(i &lt; 0\\) or \\(j &lt; 0\\) index out of bounds, return the cost \\(+\\infty\\), representing infeasibility.</li> </ul> <p>Implementation code as follows:</p> <pre><code>[file]{min_path_sum}-[class]{}-[func]{min_path_sum_dfs}\n</code></pre> <p>The figure below shows the recursive tree rooted at \\(dp[2, 1]\\), which includes some overlapping subproblems, the number of which increases sharply as the size of the grid <code>grid</code> increases.</p> <p>Essentially, the reason for overlapping subproblems is: there are multiple paths to reach a certain cell from the top-left corner.</p> <p></p> <p>Each state has two choices, down and right, so the total number of steps from the top-left corner to the bottom-right corner is \\(m + n - 2\\), so the worst-case time complexity is \\(O(2^{m + n})\\). Please note that this calculation method does not consider the situation near the grid edge, where there is only one choice left when reaching the network edge, so the actual number of paths will be less.</p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#method-2-memoized-search","title":"Method 2: Memoized search","text":"<p>We introduce a memo list <code>mem</code> of the same size as the grid <code>grid</code>, used to record the solutions to various subproblems, and prune overlapping subproblems:</p> <pre><code>[file]{min_path_sum}-[class]{}-[func]{min_path_sum_dfs_mem}\n</code></pre> <p>As shown in the figure below, after introducing memoization, all subproblem solutions only need to be calculated once, so the time complexity depends on the total number of states, i.e., the grid size \\(O(nm)\\).</p> <p></p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#method-3-dynamic-programming","title":"Method 3: Dynamic programming","text":"<p>Implement the dynamic programming solution iteratively, code as shown below:</p> <pre><code>[file]{min_path_sum}-[class]{}-[func]{min_path_sum_dp}\n</code></pre> <p>The figure below show the state transition process of the minimum path sum, traversing the entire grid, thus the time complexity is \\(O(nm)\\).</p> <p>The array <code>dp</code> is of size \\(n \\times m\\), therefore the space complexity is \\(O(nm)\\).</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"chapter_dynamic_programming/dp_solution_pipeline/#space-optimization","title":"Space optimization","text":"<p>Since each cell is only related to the cell to its left and above, we can use a single-row array to implement the \\(dp\\) table.</p> <p>Please note, since the array <code>dp</code> can only represent the state of one row, we cannot initialize the first column state in advance, but update it as we traverse each row:</p> <pre><code>[file]{min_path_sum}-[class]{}-[func]{min_path_sum_dp_comp}\n</code></pre>"},{"location":"chapter_dynamic_programming/edit_distance_problem/","title":"14.6 Edit distance problem","text":""},{"location":"chapter_dynamic_programming/edit_distance_problem/#edit-distance-problem","title":"Edit distance problem","text":"<p>Edit distance, also known as Levenshtein distance, refers to the minimum number of modifications required to transform one string into another, commonly used in information retrieval and natural language processing to measure the similarity between two sequences.</p> <p>Question</p> <p>Given two strings \\(s\\) and \\(t\\), return the minimum number of edits required to transform \\(s\\) into \\(t\\).</p> <p>You can perform three types of edits on a string: insert a character, delete a character, or replace a character with any other character.</p> <p>As shown in the figure below, transforming <code>kitten</code> into <code>sitting</code> requires 3 edits, including 2 replacements and 1 insertion; transforming <code>hello</code> into <code>algo</code> requires 3 steps, including 2 replacements and 1 deletion.</p> <p></p> <p>The edit distance problem can naturally be explained with a decision tree model. Strings correspond to tree nodes, and a round of decision (an edit operation) corresponds to an edge of the tree.</p> <p>As shown in the figure below, with unrestricted operations, each node can derive many edges, each corresponding to one operation, meaning there are many possible paths to transform <code>hello</code> into <code>algo</code>.</p> <p>From the perspective of the decision tree, the goal of this problem is to find the shortest path between the node <code>hello</code> and the node <code>algo</code>.</p> <p></p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/#dynamic-programming-approach","title":"Dynamic programming approach","text":"<p>Step one: Think about each round of decision, define the state, thus obtaining the \\(dp\\) table</p> <p>Each round of decision involves performing one edit operation on string \\(s\\).</p> <p>We aim to gradually reduce the problem size during the edit process, which enables us to construct subproblems. Let the lengths of strings \\(s\\) and \\(t\\) be \\(n\\) and \\(m\\), respectively. We first consider the tail characters of both strings \\(s[n-1]\\) and \\(t[m-1]\\).</p> <ul> <li>If \\(s[n-1]\\) and \\(t[m-1]\\) are the same, we can skip them and directly consider \\(s[n-2]\\) and \\(t[m-2]\\).</li> <li>If \\(s[n-1]\\) and \\(t[m-1]\\) are different, we need to perform one edit on \\(s\\) (insert, delete, replace) so that the tail characters of the two strings match, allowing us to skip them and consider a smaller-scale problem.</li> </ul> <p>Thus, each round of decision (edit operation) in string \\(s\\) changes the remaining characters in \\(s\\) and \\(t\\) to be matched. Therefore, the state is the \\(i\\)-th and \\(j\\)-th characters currently considered in \\(s\\) and \\(t\\), denoted as \\([i, j]\\).</p> <p>State \\([i, j]\\) corresponds to the subproblem: The minimum number of edits required to change the first \\(i\\) characters of \\(s\\) into the first \\(j\\) characters of \\(t\\).</p> <p>From this, we obtain a two-dimensional \\(dp\\) table of size \\((i+1) \\times (j+1)\\).</p> <p>Step two: Identify the optimal substructure and then derive the state transition equation</p> <p>Consider the subproblem \\(dp[i, j]\\), whose corresponding tail characters of the two strings are \\(s[i-1]\\) and \\(t[j-1]\\), which can be divided into three scenarios as shown in the figure below.</p> <ol> <li>Add \\(t[j-1]\\) after \\(s[i-1]\\), then the remaining subproblem is \\(dp[i, j-1]\\).</li> <li>Delete \\(s[i-1]\\), then the remaining subproblem is \\(dp[i-1, j]\\).</li> <li>Replace \\(s[i-1]\\) with \\(t[j-1]\\), then the remaining subproblem is \\(dp[i-1, j-1]\\).</li> </ol> <p></p> <p>Based on the analysis above, we can determine the optimal substructure: The minimum number of edits for \\(dp[i, j]\\) is the minimum among \\(dp[i, j-1]\\), \\(dp[i-1, j]\\), and \\(dp[i-1, j-1]\\), plus the edit step \\(1\\). The corresponding state transition equation is:</p> \\[ dp[i, j] = \\min(dp[i, j-1], dp[i-1, j], dp[i-1, j-1]) + 1 \\] <p>Please note, when \\(s[i-1]\\) and \\(t[j-1]\\) are the same, no edit is required for the current character, in which case the state transition equation is:</p> \\[ dp[i, j] = dp[i-1, j-1] \\] <p>Step three: Determine the boundary conditions and the order of state transitions</p> <p>When both strings are empty, the number of edits is \\(0\\), i.e., \\(dp[0, 0] = 0\\). When \\(s\\) is empty but \\(t\\) is not, the minimum number of edits equals the length of \\(t\\), that is, the first row \\(dp[0, j] = j\\). When \\(s\\) is not empty but \\(t\\) is, the minimum number of edits equals the length of \\(s\\), that is, the first column \\(dp[i, 0] = i\\).</p> <p>Observing the state transition equation, solving \\(dp[i, j]\\) depends on the solutions to the left, above, and upper left, so a double loop can be used to traverse the entire \\(dp\\) table in the correct order.</p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/#code-implementation","title":"Code implementation","text":"<pre><code>[file]{edit_distance}-[class]{}-[func]{edit_distance_dp}\n</code></pre> <p>As shown in the figure below, the process of state transition in the edit distance problem is very similar to that in the knapsack problem, which can be seen as filling a two-dimensional grid.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt;&lt;13&gt;&lt;14&gt;&lt;15&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"chapter_dynamic_programming/edit_distance_problem/#space-optimization","title":"Space optimization","text":"<p>Since \\(dp[i, j]\\) is derived from the solutions above \\(dp[i-1, j]\\), to the left \\(dp[i, j-1]\\), and to the upper left \\(dp[i-1, j-1]\\), and direct traversal will lose the upper left solution \\(dp[i-1, j-1]\\), and reverse traversal cannot build \\(dp[i, j-1]\\) in advance, therefore, both traversal orders are not feasible.</p> <p>For this reason, we can use a variable <code>leftup</code> to temporarily store the solution from the upper left \\(dp[i-1, j-1]\\), thus only needing to consider the solutions to the left and above. This situation is similar to the unbounded knapsack problem, allowing for direct traversal. The code is as follows:</p> <pre><code>[file]{edit_distance}-[class]{}-[func]{edit_distance_dp_comp}\n</code></pre>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/","title":"14.1 Introduction to dynamic programming","text":""},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#introduction-to-dynamic-programming","title":"Introduction to dynamic programming","text":"<p>Dynamic programming is an important algorithmic paradigm that decomposes a problem into a series of smaller subproblems, and stores the solutions of these subproblems to avoid redundant computations, thereby significantly improving time efficiency.</p> <p>In this section, we start with a classic problem, first presenting its brute force backtracking solution, identifying the overlapping subproblems, and then gradually deriving a more efficient dynamic programming solution.</p> <p>Climbing stairs</p> <p>Given a staircase with \\(n\\) steps, where you can climb \\(1\\) or \\(2\\) steps at a time, how many different ways are there to reach the top?</p> <p>As shown in the figure below, there are \\(3\\) ways to reach the top of a \\(3\\)-step staircase.</p> <p></p> <p>This problem aims to calculate the number of ways by using backtracking to exhaust all possibilities. Specifically, it considers the problem of climbing stairs as a multi-round choice process: starting from the ground, choosing to move up either \\(1\\) or \\(2\\) steps each round, incrementing the count of ways upon reaching the top of the stairs, and pruning the process when it exceeds the top. The code is as follows:</p> <pre><code>[file]{climbing_stairs_backtrack}-[class]{}-[func]{climbing_stairs_backtrack}\n</code></pre>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#method-1-brute-force-search","title":"Method 1: Brute force search","text":"<p>Backtracking algorithms do not explicitly decompose the problem into subproblems. Instead, they treat the problem as a sequence of decision steps, exploring all possibilities through trial and pruning.</p> <p>We can analyze this problem using a decomposition approach. Let \\(dp[i]\\) represent the number of ways to reach the \\(i^{th}\\) step. In this case, \\(dp[i]\\) is the original problem, and its subproblems are:</p> \\[ dp[i-1], dp[i-2], \\dots, dp[2], dp[1] \\] <p>Since each move can only advance \\(1\\) or \\(2\\) steps, when we stand on the \\(i^{th}\\) step, the previous step must have been either on the \\(i-1^{th}\\) or the \\(i-2^{th}\\) step. In other words, we can only reach the \\(i^{th}\\) from the \\(i-1^{th}\\) or \\(i-2^{th}\\) step.</p> <p>This leads to an important conclusion: the number of ways to reach the \\(i-1^{th}\\) step plus the number of ways to reach the \\(i-2^{th}\\) step equals the number of ways to reach the \\(i^{th}\\) step. The formula is as follows:</p> \\[ dp[i] = dp[i-1] + dp[i-2] \\] <p>This means that in the stair climbing problem, there is a recursive relationship between the subproblems, the solution to the original problem can be constructed from the solutions to the subproblems. The figure below shows this recursive relationship.</p> <p></p> <p>We can obtain the brute force search solution according to the recursive formula. Starting with \\(dp[n]\\), we recursively break a larger problem into the sum of two smaller subproblems, until reaching the smallest subproblems \\(dp[1]\\) and \\(dp[2]\\) where the solutions are known, with \\(dp[1] = 1\\) and \\(dp[2] = 2\\), representing \\(1\\) and \\(2\\) ways to climb to the first and second steps, respectively.</p> <p>Observe the following code, which, like standard backtracking code, belongs to depth-first search but is more concise:</p> <pre><code>[file]{climbing_stairs_dfs}-[class]{}-[func]{climbing_stairs_dfs}\n</code></pre> <p>The figure below shows the recursive tree formed by brute force search. For the problem \\(dp[n]\\), the depth of its recursive tree is \\(n\\), with a time complexity of \\(O(2^n)\\). This exponential growth causes the program to run much more slowly when \\(n\\) is large, leading to long wait times.</p> <p></p> <p>Observing the figure above, the exponential time complexity is caused by 'overlapping subproblems'. For example, \\(dp[9]\\) is broken down into \\(dp[8]\\) and \\(dp[7]\\), and \\(dp[8]\\) is further broken into \\(dp[7]\\) and \\(dp[6]\\), both containing the subproblem \\(dp[7]\\).</p> <p>Thus, subproblems include even smaller overlapping subproblems, endlessly. A vast majority of computational resources are wasted on these overlapping subproblems.</p>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#method-2-memoized-search","title":"Method 2: Memoized search","text":"<p>To enhance algorithm efficiency, we hope that all overlapping subproblems are calculated only once. For this purpose, we declare an array <code>mem</code> to record the solution of each subproblem, and prune overlapping subproblems during the search process.</p> <ol> <li>When \\(dp[i]\\) is calculated for the first time, we record it in <code>mem[i]</code> for later use.</li> <li>When \\(dp[i]\\) needs to be calculated again, we can directly retrieve the result from <code>mem[i]</code>, thus avoiding redundant calculations of that subproblem.</li> </ol> <p>The code is as follows:</p> <pre><code>[file]{climbing_stairs_dfs_mem}-[class]{}-[func]{climbing_stairs_dfs_mem}\n</code></pre> <p>Observe the figure below, after memoization, all overlapping subproblems need to be calculated only once, optimizing the time complexity to \\(O(n)\\), which is a significant leap.</p> <p></p>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#method-3-dynamic-programming","title":"Method 3: Dynamic programming","text":"<p>Memoized search is a 'top-down' method: we start with the original problem (root node), recursively break larger subproblems into smaller ones until the solutions to the smallest known subproblems (leaf nodes) are reached. Subsequently, by backtracking, we collect the solutions of the subproblems, constructing the solution to the original problem.</p> <p>On the contrary, dynamic programming is a 'bottom-up' method: starting with the solutions to the smallest subproblems, it iteratively constructs the solutions to larger subproblems until the original problem is solved.</p> <p>Since dynamic programming does not involve backtracking, it only requires iteration using loops and does not need recursion. In the following code, we initialize an array <code>dp</code> to store the solutions to subproblems, serving the same recording function as the array <code>mem</code> in memoized search:</p> <pre><code>[file]{climbing_stairs_dp}-[class]{}-[func]{climbing_stairs_dp}\n</code></pre> <p>The figure below simulates the execution process of the above code.</p> <p></p> <p>Like the backtracking algorithm, dynamic programming also uses the concept of \"states\" to represent specific stages in problem solving, each state corresponding to a subproblem and its local optimal solution. For example, the state of the climbing stairs problem is defined as the current step number \\(i\\).</p> <p>Based on the above content, we can summarize the commonly used terminology in dynamic programming.</p> <ul> <li>The array <code>dp</code> is referred to as the DP table, with \\(dp[i]\\) representing the solution to the subproblem corresponding to state \\(i\\).</li> <li>The states corresponding to the smallest subproblems (steps \\(1\\) and \\(2\\)) are called initial states.</li> <li>The recursive formula \\(dp[i] = dp[i-1] + dp[i-2]\\) is called the state transition equation.</li> </ul>"},{"location":"chapter_dynamic_programming/intro_to_dynamic_programming/#space-optimization","title":"Space optimization","text":"<p>Observant readers may have noticed that since \\(dp[i]\\) is only related to \\(dp[i-1]\\) and \\(dp[i-2]\\), we do not need to use an array <code>dp</code> to store the solutions to all subproblems, but can simply use two variables to progress iteratively. The code is as follows:</p> <pre><code>[file]{climbing_stairs_dp}-[class]{}-[func]{climbing_stairs_dp_comp}\n</code></pre> <p>Observing the above code, since the space occupied by the array <code>dp</code> is eliminated, the space complexity is reduced from \\(O(n)\\) to \\(O(1)\\).</p> <p>In many dynamic programming problems, the current state depends only on a limited number of previous states, allowing us to retain only the necessary states and save memory space by \"dimension reduction\". This space optimization technique is known as 'rolling variable' or 'rolling array'.</p>"},{"location":"chapter_dynamic_programming/knapsack_problem/","title":"14.4 0-1 Knapsack problem","text":""},{"location":"chapter_dynamic_programming/knapsack_problem/#0-1-knapsack-problem","title":"0-1 Knapsack problem","text":"<p>The knapsack problem is an excellent introductory problem for dynamic programming and is the most common type of problem in dynamic programming. It has many variants, such as the 0-1 knapsack problem, the unbounded knapsack problem, and the multiple knapsack problem, etc.</p> <p>In this section, we will first solve the most common 0-1 knapsack problem.</p> <p>Question</p> <p>Given \\(n\\) items, the weight of the \\(i\\)-th item is \\(wgt[i-1]\\) and its value is \\(val[i-1]\\), and a knapsack with a capacity of \\(cap\\). Each item can be chosen only once. What is the maximum value of items that can be placed in the knapsack under the capacity limit?</p> <p>Observe the figure below, since the item number \\(i\\) starts counting from 1, and the array index starts from 0, thus the weight of item \\(i\\) corresponds to \\(wgt[i-1]\\) and the value corresponds to \\(val[i-1]\\).</p> <p></p> <p>We can consider the 0-1 knapsack problem as a process consisting of \\(n\\) rounds of decisions, where for each item there are two decisions: not to put it in or to put it in, thus the problem fits the decision tree model.</p> <p>The objective of this problem is to \"maximize the value of the items that can be put in the knapsack under the limited capacity,\" thus it is more likely a dynamic programming problem.</p> <p>First step: Think about each round of decisions, define states, thereby obtaining the \\(dp\\) table</p> <p>For each item, if not put into the knapsack, the capacity remains unchanged; if put in, the capacity is reduced. From this, the state definition can be obtained: the current item number \\(i\\) and knapsack capacity \\(c\\), denoted as \\([i, c]\\).</p> <p>State \\([i, c]\\) corresponds to the sub-problem: the maximum value of the first \\(i\\) items in a knapsack of capacity \\(c\\), denoted as \\(dp[i, c]\\).</p> <p>The solution we are looking for is \\(dp[n, cap]\\), so we need a two-dimensional \\(dp\\) table of size \\((n+1) \\times (cap+1)\\).</p> <p>Second step: Identify the optimal substructure, then derive the state transition equation</p> <p>After making the decision for item \\(i\\), what remains is the sub-problem of decisions for the first \\(i-1\\) items, which can be divided into two cases.</p> <ul> <li>Not putting item \\(i\\): The knapsack capacity remains unchanged, state changes to \\([i-1, c]\\).</li> <li>Putting item \\(i\\): The knapsack capacity decreases by \\(wgt[i-1]\\), and the value increases by \\(val[i-1]\\), state changes to \\([i-1, c-wgt[i-1]]\\).</li> </ul> <p>The above analysis reveals the optimal substructure of this problem: the maximum value \\(dp[i, c]\\) is equal to the larger value of the two schemes of not putting item \\(i\\) and putting item \\(i\\). From this, the state transition equation can be derived:</p> \\[ dp[i, c] = \\max(dp[i-1, c], dp[i-1, c - wgt[i-1]] + val[i-1]) \\] <p>It is important to note that if the current item's weight \\(wgt[i - 1]\\) exceeds the remaining knapsack capacity \\(c\\), then the only option is not to put it in the knapsack.</p> <p>Third step: Determine the boundary conditions and the order of state transitions</p> <p>When there are no items or the knapsack capacity is \\(0\\), the maximum value is \\(0\\), i.e., the first column \\(dp[i, 0]\\) and the first row \\(dp[0, c]\\) are both equal to \\(0\\).</p> <p>The current state \\([i, c]\\) transitions from the state directly above \\([i-1, c]\\) and the state to the upper left \\([i-1, c-wgt[i-1]]\\), thus, the entire \\(dp\\) table is traversed in order through two layers of loops.</p> <p>Following the above analysis, we will next implement the solutions in the order of brute force search, memoized search, and dynamic programming.</p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#method-one-brute-force-search","title":"Method one: Brute force search","text":"<p>The search code includes the following elements.</p> <ul> <li>Recursive parameters: State \\([i, c]\\).</li> <li>Return value: Solution to the sub-problem \\(dp[i, c]\\).</li> <li>Termination condition: When the item number is out of bounds \\(i = 0\\) or the remaining capacity of the knapsack is \\(0\\), terminate the recursion and return the value \\(0\\).</li> <li>Pruning: If the current item's weight exceeds the remaining capacity of the knapsack, the only option is not to put it in the knapsack.</li> </ul> <pre><code>[file]{knapsack}-[class]{}-[func]{knapsack_dfs}\n</code></pre> <p>As shown in the figure below, since each item generates two search branches of not selecting and selecting, the time complexity is \\(O(2^n)\\).</p> <p>Observing the recursive tree, it is easy to see that there are overlapping sub-problems, such as \\(dp[1, 10]\\), etc. When there are many items and the knapsack capacity is large, especially when there are many items of the same weight, the number of overlapping sub-problems will increase significantly.</p> <p></p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#method-two-memoized-search","title":"Method two: Memoized search","text":"<p>To ensure that overlapping sub-problems are only calculated once, we use a memoization list <code>mem</code> to record the solutions to sub-problems, where <code>mem[i][c]</code> corresponds to \\(dp[i, c]\\).</p> <p>After introducing memoization, the time complexity depends on the number of sub-problems, which is \\(O(n \\times cap)\\). The implementation code is as follows:</p> <pre><code>[file]{knapsack}-[class]{}-[func]{knapsack_dfs_mem}\n</code></pre> <p>The figure below shows the search branches that are pruned in memoized search.</p> <p></p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#method-three-dynamic-programming","title":"Method three: Dynamic programming","text":"<p>Dynamic programming essentially involves filling the \\(dp\\) table during the state transition, the code is shown in the figure below:</p> <pre><code>[file]{knapsack}-[class]{}-[func]{knapsack_dp}\n</code></pre> <p>As shown in the figure below, both the time complexity and space complexity are determined by the size of the array <code>dp</code>, i.e., \\(O(n \\times cap)\\).</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt;&lt;13&gt;&lt;14&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"chapter_dynamic_programming/knapsack_problem/#space-optimization","title":"Space optimization","text":"<p>Since each state is only related to the state in the row above it, we can use two arrays to roll forward, reducing the space complexity from \\(O(n^2)\\) to \\(O(n)\\).</p> <p>Further thinking, can we use just one array to achieve space optimization? It can be observed that each state is transferred from the cell directly above or from the upper left cell. If there is only one array, when starting to traverse the \\(i\\)-th row, that array still stores the state of row \\(i-1\\).</p> <ul> <li>If using normal order traversal, then when traversing to \\(dp[i, j]\\), the values from the upper left \\(dp[i-1, 1]\\) ~ \\(dp[i-1, j-1]\\) may have already been overwritten, thus the correct state transition result cannot be obtained.</li> <li>If using reverse order traversal, there will be no overwriting problem, and the state transition can be conducted correctly.</li> </ul> <p>The figures below show the transition process from row \\(i = 1\\) to row \\(i = 2\\) in a single array. Please think about the differences between normal order traversal and reverse order traversal.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>In the code implementation, we only need to delete the first dimension \\(i\\) of the array <code>dp</code> and change the inner loop to reverse traversal:</p> <pre><code>[file]{knapsack}-[class]{}-[func]{knapsack_dp_comp}\n</code></pre>"},{"location":"chapter_dynamic_programming/summary/","title":"14.7 Summary","text":""},{"location":"chapter_dynamic_programming/summary/#summary","title":"Summary","text":"<ul> <li>Dynamic programming decomposes problems and improves computational efficiency by avoiding redundant computations through storing solutions of subproblems.</li> <li>Without considering time, all dynamic programming problems can be solved using backtracking (brute force search), but the recursion tree has many overlapping subproblems, resulting in very low efficiency. By introducing a memorization list, it's possible to store solutions of all computed subproblems, ensuring that overlapping subproblems are only computed once.</li> <li>Memorization search is a top-down recursive solution, whereas dynamic programming corresponds to a bottom-up iterative approach, akin to \"filling out a table.\" Since the current state only depends on certain local states, we can eliminate one dimension of the dp table to reduce space complexity.</li> <li>Decomposition of subproblems is a universal algorithmic approach, differing in characteristics among divide and conquer, dynamic programming, and backtracking.</li> <li>Dynamic programming problems have three main characteristics: overlapping subproblems, optimal substructure, and no aftereffects.</li> <li>If the optimal solution of the original problem can be constructed from the optimal solutions of its subproblems, it has an optimal substructure.</li> <li>No aftereffects mean that the future development of a state depends only on the current state and not on all past states experienced. Many combinatorial optimization problems do not have this property and cannot be quickly solved using dynamic programming.</li> </ul> <p>Knapsack problem</p> <ul> <li>The knapsack problem is one of the most typical dynamic programming problems, with variants including the 0-1 knapsack, unbounded knapsack, and multiple knapsacks.</li> <li>The state definition of the 0-1 knapsack is the maximum value in a knapsack of capacity \\(c\\) with the first \\(i\\) items. Based on decisions not to include or to include an item in the knapsack, optimal substructures can be identified and state transition equations constructed. In space optimization, since each state depends on the state directly above and to the upper left, the list should be traversed in reverse order to avoid overwriting the upper left state.</li> <li>In the unbounded knapsack problem, there is no limit on the number of each kind of item that can be chosen, thus the state transition for including items differs from the 0-1 knapsack. Since the state depends on the state directly above and to the left, space optimization should involve forward traversal.</li> <li>The coin change problem is a variant of the unbounded knapsack problem, shifting from seeking the \u201cmaximum\u201d value to seeking the \u201cminimum\u201d number of coins, thus the state transition equation should change \\(\\max()\\) to \\(\\min()\\). From pursuing \u201cnot exceeding\u201d the capacity of the knapsack to seeking exactly the target amount, thus use \\(amt + 1\\) to represent the invalid solution of \u201cunable to make up the target amount.\u201d</li> <li>Coin Change Problem II shifts from seeking the \u201cminimum number of coins\u201d to seeking the \u201cnumber of coin combinations,\u201d changing the state transition equation accordingly from \\(\\min()\\) to summation operator.</li> </ul> <p>Edit distance problem</p> <ul> <li>Edit distance (Levenshtein distance) measures the similarity between two strings, defined as the minimum number of editing steps needed to change one string into another, with editing operations including adding, deleting, or replacing.</li> <li>The state definition for the edit distance problem is the minimum number of editing steps needed to change the first \\(i\\) characters of \\(s\\) into the first \\(j\\) characters of \\(t\\). When \\(s[i] \\ne t[j]\\), there are three decisions: add, delete, replace, each with their corresponding residual subproblems. From this, optimal substructures can be identified, and state transition equations built. When \\(s[i] = t[j]\\), no editing of the current character is necessary.</li> <li>In edit distance, the state depends on the state directly above, to the left, and to the upper left. Therefore, after space optimization, neither forward nor reverse traversal can correctly perform state transitions. To address this, we use a variable to temporarily store the upper left state, making it equivalent to the situation in the unbounded knapsack problem, allowing for forward traversal after space optimization.</li> </ul>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/","title":"14.5 Unbounded knapsack problem","text":""},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#unbounded-knapsack-problem","title":"Unbounded knapsack problem","text":"<p>In this section, we first solve another common knapsack problem: the unbounded knapsack, and then explore a special case of it: the coin change problem.</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#unbounded-knapsack-problem_1","title":"Unbounded knapsack problem","text":"<p>Question</p> <p>Given \\(n\\) items, where the weight of the \\(i^{th}\\) item is \\(wgt[i-1]\\) and its value is \\(val[i-1]\\), and a backpack with a capacity of \\(cap\\). Each item can be selected multiple times. What is the maximum value of the items that can be put into the backpack without exceeding its capacity? See the example below.</p> <p></p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#dynamic-programming-approach","title":"Dynamic programming approach","text":"<p>The unbounded knapsack problem is very similar to the 0-1 knapsack problem, the only difference being that there is no limit on the number of times an item can be chosen.</p> <ul> <li>In the 0-1 knapsack problem, there is only one of each item, so after placing item \\(i\\) into the backpack, you can only choose from the previous \\(i-1\\) items.</li> <li>In the unbounded knapsack problem, the quantity of each item is unlimited, so after placing item \\(i\\) in the backpack, you can still choose from the previous \\(i\\) items.</li> </ul> <p>Under the rules of the unbounded knapsack problem, the state \\([i, c]\\) can change in two ways.</p> <ul> <li>Not putting item \\(i\\) in: As with the 0-1 knapsack problem, transition to \\([i-1, c]\\).</li> <li>Putting item \\(i\\) in: Unlike the 0-1 knapsack problem, transition to \\([i, c-wgt[i-1]]\\).</li> </ul> <p>The state transition equation thus becomes:</p> \\[ dp[i, c] = \\max(dp[i-1, c], dp[i, c - wgt[i-1]] + val[i-1]) \\]"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#code-implementation","title":"Code implementation","text":"<p>Comparing the code for the two problems, the state transition changes from \\(i-1\\) to \\(i\\), the rest is completely identical:</p> <pre><code>[file]{unbounded_knapsack}-[class]{}-[func]{unbounded_knapsack_dp}\n</code></pre>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#space-optimization","title":"Space optimization","text":"<p>Since the current state comes from the state to the left and above, the space-optimized solution should perform a forward traversal for each row in the \\(dp\\) table.</p> <p>This traversal order is the opposite of that for the 0-1 knapsack. Please refer to the figure below to understand the difference.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>The code implementation is quite simple, just remove the first dimension of the array <code>dp</code>:</p> <pre><code>[file]{unbounded_knapsack}-[class]{}-[func]{unbounded_knapsack_dp_comp}\n</code></pre>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#coin-change-problem","title":"Coin change problem","text":"<p>The knapsack problem is a representative of a large class of dynamic programming problems and has many variants, such as the coin change problem.</p> <p>Question</p> <p>Given \\(n\\) types of coins, the denomination of the \\(i^{th}\\) type of coin is \\(coins[i - 1]\\), and the target amount is \\(amt\\). Each type of coin can be selected multiple times. What is the minimum number of coins needed to make up the target amount? If it is impossible to make up the target amount, return \\(-1\\). See the example below.</p> <p></p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#dynamic-programming-approach_1","title":"Dynamic programming approach","text":"<p>The coin change can be seen as a special case of the unbounded knapsack problem, sharing the following similarities and differences.</p> <ul> <li>The two problems can be converted into each other: \"item\" corresponds to \"coin\", \"item weight\" corresponds to \"coin denomination\", and \"backpack capacity\" corresponds to \"target amount\".</li> <li>The optimization goals are opposite: the unbounded knapsack problem aims to maximize the value of items, while the coin change problem aims to minimize the number of coins.</li> <li>The unbounded knapsack problem seeks solutions \"not exceeding\" the backpack capacity, while the coin change seeks solutions that \"exactly\" make up the target amount.</li> </ul> <p>First step: Think through each round's decision-making, define the state, and thus derive the \\(dp\\) table</p> <p>The state \\([i, a]\\) corresponds to the sub-problem: the minimum number of coins that can make up the amount \\(a\\) using the first \\(i\\) types of coins, denoted as \\(dp[i, a]\\).</p> <p>The two-dimensional \\(dp\\) table is of size \\((n+1) \\times (amt+1)\\).</p> <p>Second step: Identify the optimal substructure and derive the state transition equation</p> <p>This problem differs from the unbounded knapsack problem in two aspects of the state transition equation.</p> <ul> <li>This problem seeks the minimum, so the operator \\(\\max()\\) needs to be changed to \\(\\min()\\).</li> <li>The optimization is focused on the number of coins, so simply add \\(+1\\) when a coin is chosen.</li> </ul> \\[ dp[i, a] = \\min(dp[i-1, a], dp[i, a - coins[i-1]] + 1) \\] <p>Third step: Define boundary conditions and state transition order</p> <p>When the target amount is \\(0\\), the minimum number of coins needed to make it up is \\(0\\), so all \\(dp[i, 0]\\) in the first column are \\(0\\).</p> <p>When there are no coins, it is impossible to make up any amount &gt;0, which is an invalid solution. To allow the \\(\\min()\\) function in the state transition equation to recognize and filter out invalid solutions, consider using \\(+\\infty\\) to represent them, i.e., set all \\(dp[0, a]\\) in the first row to \\(+\\infty\\).</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#code-implementation_1","title":"Code implementation","text":"<p>Most programming languages do not provide a \\(+\\infty\\) variable, only the maximum value of an integer <code>int</code> can be used as a substitute. This can lead to overflow: the \\(+1\\) operation in the state transition equation may overflow.</p> <p>For this reason, we use the number \\(amt + 1\\) to represent an invalid solution, because the maximum number of coins needed to make up \\(amt\\) is at most \\(amt\\). Before returning the result, check if \\(dp[n, amt]\\) equals \\(amt + 1\\), and if so, return \\(-1\\), indicating that the target amount cannot be made up. The code is as follows:</p> <pre><code>[file]{coin_change}-[class]{}-[func]{coin_change_dp}\n</code></pre> <p>The figure below show the dynamic programming process for the coin change problem, which is very similar to the unbounded knapsack problem.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt;&lt;13&gt;&lt;14&gt;&lt;15&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#space-optimization_1","title":"Space optimization","text":"<p>The space optimization for the coin change problem is handled in the same way as for the unbounded knapsack problem:</p> <pre><code>[file]{coin_change}-[class]{}-[func]{coin_change_dp_comp}\n</code></pre>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#coin-change-problem-ii","title":"Coin change problem II","text":"<p>Question</p> <p>Given \\(n\\) types of coins, where the denomination of the \\(i^{th}\\) type of coin is \\(coins[i - 1]\\), and the target amount is \\(amt\\). Each type of coin can be selected multiple times, ask how many combinations of coins can make up the target amount. See the example below.</p> <p></p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#dynamic-programming-approach_2","title":"Dynamic programming approach","text":"<p>Compared to the previous problem, the goal of this problem is to determine the number of combinations, so the sub-problem becomes: the number of combinations that can make up amount \\(a\\) using the first \\(i\\) types of coins. The \\(dp\\) table remains a two-dimensional matrix of size \\((n+1) \\times (amt + 1)\\).</p> <p>The number of combinations for the current state is the sum of the combinations from not selecting the current coin and selecting the current coin. The state transition equation is:</p> \\[ dp[i, a] = dp[i-1, a] + dp[i, a - coins[i-1]] \\] <p>When the target amount is \\(0\\), no coins are needed to make up the target amount, so all \\(dp[i, 0]\\) in the first column should be initialized to \\(1\\). When there are no coins, it is impossible to make up any amount &gt;0, so all \\(dp[0, a]\\) in the first row should be set to \\(0\\).</p>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#code-implementation_2","title":"Code implementation","text":"<pre><code>[file]{coin_change_ii}-[class]{}-[func]{coin_change_ii_dp}\n</code></pre>"},{"location":"chapter_dynamic_programming/unbounded_knapsack_problem/#space-optimization_2","title":"Space optimization","text":"<p>The space optimization approach is the same, just remove the coin dimension:</p> <pre><code>[file]{coin_change_ii}-[class]{}-[func]{coin_change_ii_dp_comp}\n</code></pre>"},{"location":"chapter_graph/","title":"Graph","text":""},{"location":"chapter_graph/#graph","title":"Graph","text":"<p>Abstract</p> <p>In the journey of life, each of us is a node, connected by countless invisible edges.</p> <p>Each encounter and parting leaves a unique imprint on this vast graph of life.</p>"},{"location":"chapter_graph/graph/","title":"9.1 Graph","text":""},{"location":"chapter_graph/graph/#graph","title":"Graph","text":"<p>A graph is a type of nonlinear data structure, consisting of vertices and edges. A graph \\(G\\) can be abstractly represented as a collection of a set of vertices \\(V\\) and a set of edges \\(E\\). The following example shows a graph containing 5 vertices and 7 edges.</p> \\[ \\begin{aligned} V &amp; = \\{ 1, 2, 3, 4, 5 \\} \\newline E &amp; = \\{ (1,2), (1,3), (1,5), (2,3), (2,4), (2,5), (4,5) \\} \\newline G &amp; = \\{ V, E \\} \\newline \\end{aligned} \\] <p>If vertices are viewed as nodes and edges as references (pointers) connecting the nodes, graphs can be seen as a data structure that extends from linked lists. As shown in the figure below, compared to linear relationships (linked lists) and divide-and-conquer relationships (trees), network relationships (graphs) are more complex due to their higher degree of freedom.</p> <p></p>"},{"location":"chapter_graph/graph/#common-types-and-terminologies-of-graphs","title":"Common types and terminologies of graphs","text":"<p>Graphs can be divided into  undirected graphs and directed graphs depending on whether edges have direction, as shown in the figure below.</p> <ul> <li>In undirected graphs, edges represent a \"bidirectional\" connection between two vertices, for example, the \"friends\" in Facebook.</li> <li>In directed graphs, edges have directionality, that is, the edges \\(A \\rightarrow B\\) and \\(A \\leftarrow B\\) are independent of each other. For example, the \"follow\" and \"followed\" relationship on Instagram or TikTok.</li> </ul> <p></p> <p>Depending on whether all vertices are connected, graphs can be divided into connected graphs and disconnected graphs, as shown in the figure below.</p> <ul> <li>For connected graphs, it is possible to reach any other vertex starting from an arbitrary vertex.</li> <li>For disconnected graphs, there is at least one vertex that cannot be reached from an arbitrary starting vertex.</li> </ul> <p></p> <p>We can also add a weight variable to edges, resulting in weighted graphs as shown in the figure below. For example, in Instagram, the system sorts your follower and following list by the level of interaction between you and other users (likes, views, comments, etc.). Such an interaction network can be represented by a weighted graph.</p> <p></p> <p>Graph data structures include the following commonly used terms.</p> <ul> <li>Adjacency: When there is an edge connecting two vertices, these two vertices are said to be \"adjacent\". In the figure above, the adjacent vertices of vertex 1 are vertices 2, 3, and 5.</li> <li>Path: The sequence of edges passed from vertex A to vertex B is called a path from A to B. In the figure above, the edge sequence 1-5-2-4 is a path from vertex 1 to vertex 4.</li> <li>Degree: The number of edges a vertex has. For directed graphs, in-degree refers to how many edges point to the vertex, and out-degree refers to how many edges point out from the vertex.</li> </ul>"},{"location":"chapter_graph/graph/#representation-of-graphs","title":"Representation of graphs","text":"<p>Common representations of graphs include \"adjacency matrix\" and \"adjacency list\". The following examples use undirected graphs.</p>"},{"location":"chapter_graph/graph/#adjacency-matrix","title":"Adjacency matrix","text":"<p>Let the number of vertices in the graph be \\(n\\), the adjacency matrix uses an \\(n \\times n\\) matrix to represent the graph, where each row (column) represents a vertex, and the matrix elements represent edges, with \\(1\\) or \\(0\\) indicating whether there is an edge between two vertices.</p> <p>As shown in the figure below, let the adjacency matrix be \\(M\\), and the list of vertices be \\(V\\), then the matrix element \\(M[i, j] = 1\\) indicates there is an edge between vertex \\(V[i]\\) and vertex \\(V[j]\\), conversely \\(M[i, j] = 0\\) indicates there is no edge between the two vertices.</p> <p></p> <p>Adjacency matrices have the following characteristics.</p> <ul> <li>A vertex cannot be connected to itself, so the elements on the main diagonal of the adjacency matrix are meaningless.</li> <li>For undirected graphs, edges in both directions are equivalent, thus the adjacency matrix is symmetric with regard to the main diagonal.</li> <li>By replacing the elements of the adjacency matrix from \\(1\\) and \\(0\\) to weights, we can represent weighted graphs.</li> </ul> <p>When representing graphs with adjacency matrices, it is possible to directly access matrix elements to obtain edges, resulting in efficient operations of addition, deletion, lookup, and modification, all with a time complexity of \\(O(1)\\). However, the space complexity of the matrix is \\(O(n^2)\\), which consumes more memory.</p>"},{"location":"chapter_graph/graph/#adjacency-list","title":"Adjacency list","text":"<p>The adjacency list uses \\(n\\) linked lists to represent the graph, with each linked list node representing a vertex. The \\(i\\)-th linked list corresponds to vertex \\(i\\) and contains all adjacent vertices (vertices connected to that vertex). The figure below shows an example of a graph stored using an adjacency list.</p> <p></p> <p>The adjacency list only stores actual edges, and the total number of edges is often much less than \\(n^2\\), making it more space-efficient. However, finding edges in the adjacency list requires traversing the linked list, so its time efficiency is not as good as that of the adjacency matrix.</p> <p>Observing the figure above, the structure of the adjacency list is very similar to the \"chaining\" in hash tables, hence we can use similar methods to optimize efficiency. For example, when the linked list is long, it can be transformed into an AVL tree or red-black tree, thus optimizing the time efficiency from \\(O(n)\\) to \\(O(\\log n)\\); the linked list can also be transformed into a hash table, thus reducing the time complexity to \\(O(1)\\).</p>"},{"location":"chapter_graph/graph/#common-applications-of-graphs","title":"Common applications of graphs","text":"<p>As shown in the table below, many real-world systems can be modeled with graphs, and corresponding problems can be reduced to graph computing problems.</p> <p> Table  \u00a0 Common graphs in real life </p> Vertices Edges Graph Computing Problem Social Networks Users Follow / Followed Potential Following Recommendations Subway Lines Stations Connectivity Between Stations Shortest Route Recommendations Solar System Celestial Bodies Gravitational Forces Between Celestial Bodies Planetary Orbit Calculations"},{"location":"chapter_graph/graph_operations/","title":"9.2 Basic graph operations","text":""},{"location":"chapter_graph/graph_operations/#basic-operations-on-graphs","title":"Basic operations on graphs","text":"<p>The basic operations on graphs can be divided into operations on \"edges\" and operations on \"vertices\". Under the two representation methods of \"adjacency matrix\" and \"adjacency list\", the implementations are different.</p>"},{"location":"chapter_graph/graph_operations/#implementation-based-on-adjacency-matrix","title":"Implementation based on adjacency matrix","text":"<p>Given an undirected graph with \\(n\\) vertices, the various operations are implemented as shown in the figure below.</p> <ul> <li>Adding or removing an edge: Directly modify the specified edge in the adjacency matrix, using \\(O(1)\\) time. Since it is an undirected graph, it is necessary to update the edges in both directions simultaneously.</li> <li>Adding a vertex: Add a row and a column at the end of the adjacency matrix and fill them all with \\(0\\)s, using \\(O(n)\\) time.</li> <li>Removing a vertex: Delete a row and a column in the adjacency matrix. The worst case is when the first row and column are removed, requiring \\((n-1)^2\\) elements to be \"moved up and to the left\", thus using \\(O(n^2)\\) time.</li> <li>Initialization: Pass in \\(n\\) vertices, initialize a vertex list <code>vertices</code> of length \\(n\\), using \\(O(n)\\) time; initialize an \\(n \\times n\\) size adjacency matrix <code>adjMat</code>, using \\(O(n^2)\\) time.</li> </ul> Initialize adjacency matrixAdd an edgeRemove an edgeAdd a vertexRemove a vertex <p></p> <p></p> <p></p> <p></p> <p></p> <p>Below is the implementation code for graphs represented using an adjacency matrix:</p> <pre><code>[file]{graph_adjacency_matrix}-[class]{graph_adj_mat}-[func]{}\n</code></pre>"},{"location":"chapter_graph/graph_operations/#implementation-based-on-adjacency-list","title":"Implementation based on adjacency list","text":"<p>Given an undirected graph with a total of \\(n\\) vertices and \\(m\\) edges, the various operations can be implemented as shown in the figure below.</p> <ul> <li>Adding an edge: Simply add the edge at the end of the corresponding vertex's linked list, using \\(O(1)\\) time. Because it is an undirected graph, it is necessary to add edges in both directions simultaneously.</li> <li>Removing an edge: Find and remove the specified edge in the corresponding vertex's linked list, using \\(O(m)\\) time. In an undirected graph, it is necessary to remove edges in both directions simultaneously.</li> <li>Adding a vertex: Add a linked list in the adjacency list and make the new vertex the head node of the list, using \\(O(1)\\) time.</li> <li>Removing a vertex: It is necessary to traverse the entire adjacency list, removing all edges that include the specified vertex, using \\(O(n + m)\\) time.</li> <li>Initialization: Create \\(n\\) vertices and \\(2m\\) edges in the adjacency list, using \\(O(n + m)\\) time.</li> </ul> Initialize adjacency listAdd an edgeRemove an edgeAdd a vertexRemove a vertex <p></p> <p></p> <p></p> <p></p> <p></p> <p>Below is the adjacency list code implementation. Compared to the figure above, the actual code has the following differences.</p> <ul> <li>For convenience in adding and removing vertices, and to simplify the code, we use lists (dynamic arrays) instead of linked lists.</li> <li>Use a hash table to store the adjacency list, <code>key</code> being the vertex instance, <code>value</code> being the list (linked list) of adjacent vertices of that vertex.</li> </ul> <p>Additionally, we use the <code>Vertex</code> class to represent vertices in the adjacency list. The reason for this is: if, like with the adjacency matrix, list indexes were used to distinguish different vertices, then suppose you want to delete the vertex at index \\(i\\), you would need to traverse the entire adjacency list and decrement all indexes greater than \\(i\\) by \\(1\\), which is very inefficient. However, if each vertex is a unique <code>Vertex</code> instance, then deleting a vertex does not require any changes to other vertices.</p> <pre><code>[file]{graph_adjacency_list}-[class]{graph_adj_list}-[func]{}\n</code></pre>"},{"location":"chapter_graph/graph_operations/#efficiency-comparison","title":"Efficiency comparison","text":"<p>Assuming there are \\(n\\) vertices and \\(m\\) edges in the graph, the table below compares the time efficiency and space efficiency of the adjacency matrix and adjacency list.</p> <p> Table  \u00a0 Comparison of adjacency matrix and adjacency list </p> Adjacency matrix Adjacency list (Linked list) Adjacency list (Hash table) Determine adjacency \\(O(1)\\) \\(O(m)\\) \\(O(1)\\) Add an edge \\(O(1)\\) \\(O(1)\\) \\(O(1)\\) Remove an edge \\(O(1)\\) \\(O(m)\\) \\(O(1)\\) Add a vertex \\(O(n)\\) \\(O(1)\\) \\(O(1)\\) Remove a vertex \\(O(n^2)\\) \\(O(n + m)\\) \\(O(n)\\) Memory space usage \\(O(n^2)\\) \\(O(n + m)\\) \\(O(n + m)\\) <p>Observing the table above, it seems that the adjacency list (hash table) has the best time efficiency and space efficiency. However, in practice, operating on edges in the adjacency matrix is more efficient, requiring only a single array access or assignment operation. Overall, the adjacency matrix exemplifies the principle of \"space for time\", while the adjacency list exemplifies \"time for space\".</p>"},{"location":"chapter_graph/graph_traversal/","title":"9.3 Graph traversal","text":""},{"location":"chapter_graph/graph_traversal/#graph-traversal","title":"Graph traversal","text":"<p>Trees represent a \"one-to-many\" relationship, while graphs have a higher degree of freedom and can represent any \"many-to-many\" relationship. Therefore, we can consider tree as a special case of graph. Clearly, tree traversal operations are also a special case of graph traversal operations.</p> <p>Both graphs and trees require the application of search algorithms to implement traversal operations. Graph traversal can be divided into two types: Breadth-First Search (BFS) and Depth-First Search (DFS).</p>"},{"location":"chapter_graph/graph_traversal/#breadth-first-search","title":"Breadth-first search","text":"<p>Breadth-first search is a near-to-far traversal method, starting from a certain node, always prioritizing the visit to the nearest vertices and expanding outwards layer by layer. As shown in the figure below, starting from the top left vertex, first traverse all adjacent vertices of that vertex, then traverse all adjacent vertices of the next vertex, and so on, until all vertices have been visited.</p> <p></p>"},{"location":"chapter_graph/graph_traversal/#algorithm-implementation","title":"Algorithm implementation","text":"<p>BFS is usually implemented with the help of a queue, as shown in the code below. The queue is \"first in, first out\", which aligns with the BFS idea of traversing \"from near to far\".</p> <ol> <li>Add the starting vertex <code>startVet</code> to the queue and start the loop.</li> <li>In each iteration of the loop, pop the vertex at the front of the queue and record it as visited, then add all adjacent vertices of that vertex to the back of the queue.</li> <li>Repeat step <code>2.</code> until all vertices have been visited.</li> </ol> <p>To prevent revisiting vertices, we use a hash set <code>visited</code> to record which nodes have been visited.</p> <pre><code>[file]{graph_bfs}-[class]{}-[func]{graph_bfs}\n</code></pre> <p>The code is relatively abstract, you can compare it with the figure below to get a better understanding.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Is the sequence of breadth-first traversal unique?</p> <p>Not unique. Breadth-first traversal only requires traversing in a \"near to far\" order, and the traversal order of the vertices with the same distance can be arbitrary. For example, in the figure above, the visit order of vertices \\(1\\) and \\(3\\) can be swapped, as can the order of vertices \\(2\\), \\(4\\), and \\(6\\).</p>"},{"location":"chapter_graph/graph_traversal/#complexity-analysis","title":"Complexity analysis","text":"<p>Time complexity: All vertices will be enqueued and dequeued once, using \\(O(|V|)\\) time; in the process of traversing adjacent vertices, since it is an undirected graph, all edges will be visited \\(2\\) times, using \\(O(2|E|)\\) time; overall using \\(O(|V| + |E|)\\) time.</p> <p>Space complexity: The maximum number of vertices in list <code>res</code>, hash set <code>visited</code>, and queue <code>que</code> is \\(|V|\\), using \\(O(|V|)\\) space.</p>"},{"location":"chapter_graph/graph_traversal/#depth-first-search","title":"Depth-first search","text":"<p>Depth-first search is a traversal method that prioritizes going as far as possible and then backtracks when no further path is available. As shown in the figure below, starting from the top left vertex, visit some adjacent vertex of the current vertex until no further path is available, then return and continue until all vertices are traversed.</p> <p></p>"},{"location":"chapter_graph/graph_traversal/#algorithm-implementation_1","title":"Algorithm implementation","text":"<p>This \"go as far as possible and then return\" algorithm paradigm is usually implemented based on recursion. Similar to breadth-first search, in depth-first search, we also need the help of a hash set <code>visited</code> to record the visited vertices to avoid revisiting.</p> <pre><code>[file]{graph_dfs}-[class]{}-[func]{graph_dfs}\n</code></pre> <p>The algorithm process of depth-first search is shown in the figure below.</p> <ul> <li>Dashed lines represent downward recursion, indicating that a new recursive method has been initiated to visit a new vertex.</li> <li>Curved dashed lines represent upward backtracking, indicating that this recursive method has returned to the position where this method was initiated.</li> </ul> <p>To deepen the understanding, it is suggested to combine the figure below with the code to simulate (or draw) the entire DFS process in your mind, including when each recursive method is initiated and when it returns.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Is the sequence of depth-first traversal unique?</p> <p>Similar to breadth-first traversal, the order of the depth-first traversal sequence is also not unique. Given a certain vertex, exploring in any direction first is possible, that is, the order of adjacent vertices can be arbitrarily shuffled, all being part of depth-first traversal.</p> <p>Taking tree traversal as an example, \"root \\(\\rightarrow\\) left \\(\\rightarrow\\) right\", \"left \\(\\rightarrow\\) root \\(\\rightarrow\\) right\", \"left \\(\\rightarrow\\) right \\(\\rightarrow\\) root\" correspond to pre-order, in-order, and post-order traversals, respectively. They showcase three types of traversal priorities, yet all three are considered depth-first traversal.</p>"},{"location":"chapter_graph/graph_traversal/#complexity-analysis_1","title":"Complexity analysis","text":"<p>Time complexity: All vertices will be visited once, using \\(O(|V|)\\) time; all edges will be visited twice, using \\(O(2|E|)\\) time; overall using \\(O(|V| + |E|)\\) time.</p> <p>Space complexity: The maximum number of vertices in list <code>res</code>, hash set <code>visited</code> is \\(|V|\\), and the maximum recursion depth is \\(|V|\\), therefore using \\(O(|V|)\\) space.</p>"},{"location":"chapter_graph/summary/","title":"9.4 Summary","text":""},{"location":"chapter_graph/summary/#summary","title":"Summary","text":""},{"location":"chapter_graph/summary/#key-review","title":"Key review","text":"<ul> <li>A graph is made up of vertices and edges. It can be described as a set of vertices and a set of edges.</li> <li>Compared to linear relationships (like linked lists) and hierarchical relationships (like trees), network relationships (graphs) offer greater flexibility, making them more complex.</li> <li>In a directed graph, edges have directions. In a connected graph, any vertex can be reached from any other vertex. In a weighted graph, each edge has an associated weight variable.</li> <li>An adjacency matrix is a way to represent a graph using matrix (2D array). The rows and columns represent the vertices. The matrix element value indicates whether there is an edge between two vertices, using \\(1\\) for an edge or \\(0\\) for no edge. Adjacency matrices are highly efficient for operations like adding, deleting, or checking edges, but they require more space.</li> <li>An adjacency list is another common way to represent a graph using a collection of linked lists. Each vertex in the graph has a list that contains all its adjacent vertices. The \\(i^{th}\\) list represents vertex \\(i\\). Adjacency lists use less space compared to adjacency matrices. However, since it requires traversing the list to find edges, the time efficiency is lower.</li> <li>When the linked lists in an adjacency list are long enough, they can be converted into red-black trees or hash tables to improve lookup efficiency.</li> <li>From the perspective of algorithmic design, an adjacency matrix reflects the concept of \"trading space for time\", whereas an adjacency list reflects \"trading time for space\".</li> <li>Graphs can be used to model various real-world systems, such as social networks, subway routes.</li> <li>A tree is a special case of a graph, and tree traversal is also a special case of graph traversal.</li> <li>Breadth-first traversal of a graph is a search method that expands layer by layer from near to far, typically using a queue.</li> <li>Depth-first traversal of a graph is a search method that prioritizes reaching the end before backtracking when no further path is available. It is often implemented using recursion.</li> </ul>"},{"location":"chapter_graph/summary/#q-a","title":"Q &amp; A","text":"<p>Q: Is a path defined as a sequence of vertices or a sequence of edges?</p> <p>In graph theory, a path in a graph is a finite or infinite sequence of edges which joins a sequence of vertices.</p> <p>In this document, a path is considered a sequence of edges, rather than a sequence of vertices. This is because there might be multiple edges connecting two vertices, in which case each edge corresponds to a path.</p> <p>Q: In a disconnected graph, are there points that cannot be traversed?</p> <p>In a disconnected graph, there is at least one vertex that cannot be reached from a specific point. To traverse a disconnected graph, you need to set multiple starting points to traverse all the connected components of the graph.</p> <p>Q: In an adjacency list, does the order of \"all vertices connected to that vertex\" matter?</p> <p>It can be in any order. However, in real-world applications, it might be necessary to sort them according to certain rules, such as the order in which vertices are added, or the order of vertex values. This can help find vertices quickly with certain extreme values.</p>"},{"location":"chapter_greedy/","title":"Greedy","text":""},{"location":"chapter_greedy/#greedy","title":"Greedy","text":"<p>Abstract</p> <p>Sunflowers turn towards the sun, always seeking the greatest possible growth for themselves.</p> <p>Greedy strategy guides to the best answer step by step through rounds of simple choices.</p>"},{"location":"chapter_greedy/fractional_knapsack_problem/","title":"15.2 Fractional knapsack problem","text":""},{"location":"chapter_greedy/fractional_knapsack_problem/#fractional-knapsack-problem","title":"Fractional knapsack problem","text":"<p>Question</p> <p>Given \\(n\\) items, the weight of the \\(i\\)-th item is \\(wgt[i-1]\\) and its value is \\(val[i-1]\\), and a knapsack with a capacity of \\(cap\\). Each item can be chosen only once, but a part of the item can be selected, with its value calculated based on the proportion of the weight chosen, what is the maximum value of the items in the knapsack under the limited capacity? An example is shown in the figure below.</p> <p></p> <p>The fractional knapsack problem is very similar overall to the 0-1 knapsack problem, involving the current item \\(i\\) and capacity \\(c\\), aiming to maximize the value within the limited capacity of the knapsack.</p> <p>The difference is that, in this problem, only a part of an item can be chosen. As shown in the figure below, we can arbitrarily split the items and calculate the corresponding value based on the weight proportion.</p> <ol> <li>For item \\(i\\), its value per unit weight is \\(val[i-1] / wgt[i-1]\\), referred to as the unit value.</li> <li>Suppose we put a part of item \\(i\\) with weight \\(w\\) into the knapsack, then the value added to the knapsack is \\(w \\times val[i-1] / wgt[i-1]\\).</li> </ol> <p></p>"},{"location":"chapter_greedy/fractional_knapsack_problem/#greedy-strategy-determination","title":"Greedy strategy determination","text":"<p>Maximizing the total value of the items in the knapsack essentially means maximizing the value per unit weight. From this, the greedy strategy shown in the figure below can be deduced.</p> <ol> <li>Sort the items by their unit value from high to low.</li> <li>Iterate over all items, greedily choosing the item with the highest unit value in each round.</li> <li>If the remaining capacity of the knapsack is insufficient, use part of the current item to fill the knapsack.</li> </ol> <p></p>"},{"location":"chapter_greedy/fractional_knapsack_problem/#code-implementation","title":"Code implementation","text":"<p>We have created an <code>Item</code> class in order to sort the items by their unit value. We loop and make greedy choices until the knapsack is full, then exit and return the solution:</p> <pre><code>[file]{fractional_knapsack}-[class]{}-[func]{fractional_knapsack}\n</code></pre> <p>Apart from sorting, in the worst case, the entire list of items needs to be traversed, hence the time complexity is \\(O(n)\\), where \\(n\\) is the number of items.</p> <p>Since an <code>Item</code> object list is initialized, the space complexity is \\(O(n)\\).</p>"},{"location":"chapter_greedy/fractional_knapsack_problem/#correctness-proof","title":"Correctness proof","text":"<p>Using proof by contradiction. Suppose item \\(x\\) has the highest unit value, and some algorithm yields a maximum value <code>res</code>, but the solution does not include item \\(x\\).</p> <p>Now remove a unit weight of any item from the knapsack and replace it with a unit weight of item \\(x\\). Since the unit value of item \\(x\\) is the highest, the total value after replacement will definitely be greater than <code>res</code>. This contradicts the assumption that <code>res</code> is the optimal solution, proving that the optimal solution must include item \\(x\\).</p> <p>For other items in this solution, we can also construct the above contradiction. Overall, items with greater unit value are always better choices, proving that the greedy strategy is effective.</p> <p>As shown in the figure below, if the item weight and unit value are viewed as the horizontal and vertical axes of a two-dimensional chart respectively, the fractional knapsack problem can be transformed into \"seeking the largest area enclosed within a limited horizontal axis range\". This analogy can help us understand the effectiveness of the greedy strategy from a geometric perspective.</p> <p></p>"},{"location":"chapter_greedy/greedy_algorithm/","title":"15.1 Greedy algorithms","text":""},{"location":"chapter_greedy/greedy_algorithm/#greedy-algorithms","title":"Greedy algorithms","text":"<p>Greedy algorithm is a common algorithm for solving optimization problems, which fundamentally involves making the seemingly best choice at each decision-making stage of the problem, i.e., greedily making locally optimal decisions in hopes of finding a globally optimal solution. Greedy algorithms are concise and efficient, and are widely used in many practical problems.</p> <p>Greedy algorithms and dynamic programming are both commonly used to solve optimization problems. They share some similarities, such as relying on the property of optimal substructure, but they operate differently.</p> <ul> <li>Dynamic programming considers all previous decisions at the current decision stage and uses solutions to past subproblems to construct solutions for the current subproblem.</li> <li>Greedy algorithms do not consider past decisions; instead, they proceed with greedy choices, continually narrowing the scope of the problem until it is solved.</li> </ul> <p>Let's first understand the working principle of the greedy algorithm through the example of \"coin change,\" which has been introduced in the \"Complete Knapsack Problem\" chapter. I believe you are already familiar with it.</p> <p>Question</p> <p>Given \\(n\\) types of coins, where the denomination of the \\(i\\)th type of coin is \\(coins[i - 1]\\), and the target amount is \\(amt\\), with each type of coin available indefinitely, what is the minimum number of coins needed to make up the target amount? If it is not possible to make up the target amount, return \\(-1\\).</p> <p>The greedy strategy adopted in this problem is shown in the figure below. Given the target amount, we greedily choose the coin that is closest to and not greater than it, repeatedly following this step until the target amount is met.</p> <p></p> <p>The implementation code is as follows:</p> <pre><code>[file]{coin_change_greedy}-[class]{}-[func]{coin_change_greedy}\n</code></pre> <p>You might exclaim: So clean! The greedy algorithm solves the coin change problem in about ten lines of code.</p>"},{"location":"chapter_greedy/greedy_algorithm/#advantages-and-limitations-of-greedy-algorithms","title":"Advantages and limitations of greedy algorithms","text":"<p>Greedy algorithms are not only straightforward and simple to implement, but they are also usually very efficient. In the code above, if the smallest coin denomination is \\(\\min(coins)\\), the greedy choice loops at most \\(amt / \\min(coins)\\) times, giving a time complexity of \\(O(amt / \\min(coins))\\). This is an order of magnitude smaller than the time complexity of the dynamic programming solution, which is \\(O(n \\times amt)\\).</p> <p>However, for some combinations of coin denominations, greedy algorithms cannot find the optimal solution. The figure below provides two examples.</p> <ul> <li>Positive example \\(coins = [1, 5, 10, 20, 50, 100]\\): In this coin combination, given any \\(amt\\), the greedy algorithm can find the optimal solution.</li> <li>Negative example \\(coins = [1, 20, 50]\\): Suppose \\(amt = 60\\), the greedy algorithm can only find the combination \\(50 + 1 \\times 10\\), totaling 11 coins, but dynamic programming can find the optimal solution of \\(20 + 20 + 20\\), needing only 3 coins.</li> <li>Negative example \\(coins = [1, 49, 50]\\): Suppose \\(amt = 98\\), the greedy algorithm can only find the combination \\(50 + 1 \\times 48\\), totaling 49 coins, but dynamic programming can find the optimal solution of \\(49 + 49\\), needing only 2 coins.</li> </ul> <p></p> <p>This means that for the coin change problem, greedy algorithms cannot guarantee finding the globally optimal solution, and they might find a very poor solution. They are better suited for dynamic programming.</p> <p>Generally, the suitability of greedy algorithms falls into two categories.</p> <ol> <li>Guaranteed to find the optimal solution: In these cases, greedy algorithms are often the best choice, as they tend to be more efficient than backtracking or dynamic programming.</li> <li>Can find a near-optimal solution: Greedy algorithms are also applicable here. For many complex problems, finding the global optimal solution is very challenging, and being able to find a high-efficiency suboptimal solution is also very commendable.</li> </ol>"},{"location":"chapter_greedy/greedy_algorithm/#characteristics-of-greedy-algorithms","title":"Characteristics of greedy algorithms","text":"<p>So, what kind of problems are suitable for solving with greedy algorithms? Or rather, under what conditions can greedy algorithms guarantee to find the optimal solution?</p> <p>Compared to dynamic programming, greedy algorithms have stricter usage conditions, focusing mainly on two properties of the problem.</p> <ul> <li>Greedy choice property: Only when the locally optimal choice can always lead to a globally optimal solution can greedy algorithms guarantee to obtain the optimal solution.</li> <li>Optimal substructure: The optimal solution to the original problem contains the optimal solutions to its subproblems.</li> </ul> <p>Optimal substructure has already been introduced in the \"Dynamic Programming\" chapter, so it is not discussed further here. It's important to note that some problems do not have an obvious optimal substructure, but can still be solved using greedy algorithms.</p> <p>We mainly explore the method for determining the greedy choice property. Although its description seems simple, in practice, proving the greedy choice property for many problems is not easy.</p> <p>For example, in the coin change problem, although we can easily cite counterexamples to disprove the greedy choice property, proving it is much more challenging. If asked, what conditions must a coin combination meet to be solvable using a greedy algorithm? We often have to rely on intuition or examples to provide an ambiguous answer, as it is difficult to provide a rigorous mathematical proof.</p> <p>Quote</p> <p>A paper presents an algorithm with a time complexity of \\(O(n^3)\\) for determining whether a coin combination can use a greedy algorithm to find the optimal solution for any amount.</p> <p>Pearson, D. A polynomial-time algorithm for the change-making problem[J]. Operations Research Letters, 2005, 33(3): 231-234.</p>"},{"location":"chapter_greedy/greedy_algorithm/#steps-for-solving-problems-with-greedy-algorithms","title":"Steps for solving problems with greedy algorithms","text":"<p>The problem-solving process for greedy problems can generally be divided into the following three steps.</p> <ol> <li>Problem analysis: Sort out and understand the characteristics of the problem, including state definition, optimization objectives, and constraints, etc. This step is also involved in backtracking and dynamic programming.</li> <li>Determine the greedy strategy: Determine how to make a greedy choice at each step. This strategy can reduce the scale of the problem at each step and eventually solve the entire problem.</li> <li>Proof of correctness: It is usually necessary to prove that the problem has both a greedy choice property and optimal substructure. This step may require mathematical proofs, such as induction or reductio ad absurdum.</li> </ol> <p>Determining the greedy strategy is the core step in solving the problem, but it may not be easy to implement, mainly for the following reasons.</p> <ul> <li>Greedy strategies vary greatly between different problems. For many problems, the greedy strategy is fairly straightforward, and we can come up with it through some general thinking and attempts. However, for some complex problems, the greedy strategy may be very elusive, which is a real test of individual problem-solving experience and algorithmic capability.</li> <li>Some greedy strategies are quite misleading. When we confidently design a greedy strategy, write the code, and submit it for testing, it is quite possible that some test cases will not pass. This is because the designed greedy strategy is only \"partially correct,\" as described above with the coin change example.</li> </ul> <p>To ensure accuracy, we should provide rigorous mathematical proofs for the greedy strategy, usually involving reductio ad absurdum or mathematical induction.</p> <p>However, proving correctness may not be an easy task. If we are at a loss, we usually choose to debug the code based on test cases, modifying and verifying the greedy strategy step by step.</p>"},{"location":"chapter_greedy/greedy_algorithm/#typical-problems-solved-by-greedy-algorithms","title":"Typical problems solved by greedy algorithms","text":"<p>Greedy algorithms are often applied to optimization problems that satisfy the properties of greedy choice and optimal substructure. Below are some typical greedy algorithm problems.</p> <ul> <li>Coin change problem: In some coin combinations, the greedy algorithm always provides the optimal solution.</li> <li>Interval scheduling problem: Suppose you have several tasks, each of which takes place over a period of time. Your goal is to complete as many tasks as possible. If you always choose the task that ends the earliest, then the greedy algorithm can achieve the optimal solution.</li> <li>Fractional knapsack problem: Given a set of items and a carrying capacity, your goal is to select a set of items such that the total weight does not exceed the carrying capacity and the total value is maximized. If you always choose the item with the highest value-to-weight ratio (value / weight), the greedy algorithm can achieve the optimal solution in some cases.</li> <li>Stock trading problem: Given a set of historical stock prices, you can make multiple trades, but you cannot buy again until after you have sold if you already own stocks. The goal is to achieve the maximum profit.</li> <li>Huffman coding: Huffman coding is a greedy algorithm used for lossless data compression. By constructing a Huffman tree, it always merges the two nodes with the lowest frequency, resulting in a Huffman tree with the minimum weighted path length (coding length).</li> <li>Dijkstra's algorithm: It is a greedy algorithm for solving the shortest path problem from a given source vertex to all other vertices.</li> </ul>"},{"location":"chapter_greedy/max_capacity_problem/","title":"15.3 Maximum capacity problem","text":""},{"location":"chapter_greedy/max_capacity_problem/#maximum-capacity-problem","title":"Maximum capacity problem","text":"<p>Question</p> <p>Input an array \\(ht\\), where each element represents the height of a vertical partition. Any two partitions in the array, along with the space between them, can form a container.</p> <p>The capacity of the container is the product of the height and the width (area), where the height is determined by the shorter partition, and the width is the difference in array indices between the two partitions.</p> <p>Please select two partitions in the array that maximize the container's capacity and return this maximum capacity. An example is shown in the figure below.</p> <p></p> <p>The container is formed by any two partitions, therefore the state of this problem is represented by the indices of the two partitions, denoted as \\([i, j]\\).</p> <p>According to the problem statement, the capacity equals the product of height and width, where the height is determined by the shorter partition, and the width is the difference in array indices between the two partitions. The formula for capacity \\(cap[i, j]\\) is:</p> \\[ cap[i, j] = \\min(ht[i], ht[j]) \\times (j - i) \\] <p>Assuming the length of the array is \\(n\\), the number of combinations of two partitions (total number of states) is \\(C_n^2 = \\frac{n(n - 1)}{2}\\). The most straightforward approach is to enumerate all possible states, resulting in a time complexity of \\(O(n^2)\\).</p>"},{"location":"chapter_greedy/max_capacity_problem/#determination-of-a-greedy-strategy","title":"Determination of a greedy strategy","text":"<p>There is a more efficient solution to this problem. As shown in the figure below, we select a state \\([i, j]\\) where the indices \\(i &lt; j\\) and the height \\(ht[i] &lt; ht[j]\\), meaning \\(i\\) is the shorter partition, and \\(j\\) is the taller one.</p> <p></p> <p>As shown in the figure below, if we move the taller partition \\(j\\) closer to the shorter partition \\(i\\), the capacity will definitely decrease.</p> <p>This is because when moving the taller partition \\(j\\), the width \\(j-i\\) definitely decreases; and since the height is determined by the shorter partition, the height can only remain the same (if \\(i\\) remains the shorter partition) or decrease (if the moved \\(j\\) becomes the shorter partition).</p> <p></p> <p>Conversely, we can only possibly increase the capacity by moving the shorter partition \\(i\\) inward. Although the width will definitely decrease, the height may increase (if the moved shorter partition \\(i\\) becomes taller). For example, in the figure below, the area increases after moving the shorter partition.</p> <p></p> <p>This leads us to the greedy strategy for this problem: initialize two pointers at the ends of the container, and in each round, move the pointer corresponding to the shorter partition inward until the two pointers meet.</p> <p>The figure below illustrate the execution of the greedy strategy.</p> <ol> <li>Initially, the pointers \\(i\\) and \\(j\\) are positioned at the ends of the array.</li> <li>Calculate the current state's capacity \\(cap[i, j]\\) and update the maximum capacity.</li> <li>Compare the heights of partitions \\(i\\) and \\(j\\), and move the shorter partition inward by one step.</li> <li>Repeat steps <code>2.</code> and <code>3.</code> until \\(i\\) and \\(j\\) meet.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"chapter_greedy/max_capacity_problem/#implementation","title":"Implementation","text":"<p>The code loops at most \\(n\\) times, thus the time complexity is \\(O(n)\\).</p> <p>The variables \\(i\\), \\(j\\), and \\(res\\) use a constant amount of extra space, thus the space complexity is \\(O(1)\\).</p> <pre><code>[file]{max_capacity}-[class]{}-[func]{max_capacity}\n</code></pre>"},{"location":"chapter_greedy/max_capacity_problem/#proof-of-correctness","title":"Proof of correctness","text":"<p>The reason why the greedy method is faster than enumeration is that each round of greedy selection \"skips\" some states.</p> <p>For example, under the state \\(cap[i, j]\\) where \\(i\\) is the shorter partition and \\(j\\) is the taller partition, greedily moving the shorter partition \\(i\\) inward by one step leads to the \"skipped\" states shown in the figure below. This means that these states' capacities cannot be verified later.</p> \\[ cap[i, i+1], cap[i, i+2], \\dots, cap[i, j-2], cap[i, j-1] \\] <p></p> <p>It is observed that these skipped states are actually all states where the taller partition \\(j\\) is moved inward. We have already proven that moving the taller partition inward will definitely decrease the capacity. Therefore, the skipped states cannot possibly be the optimal solution, and skipping them does not lead to missing the optimal solution.</p> <p>The analysis shows that the operation of moving the shorter partition is \"safe\", and the greedy strategy is effective.</p>"},{"location":"chapter_greedy/max_product_cutting_problem/","title":"15.4 Maximum product cutting problem","text":""},{"location":"chapter_greedy/max_product_cutting_problem/#maximum-product-cutting-problem","title":"Maximum product cutting problem","text":"<p>Question</p> <p>Given a positive integer \\(n\\), split it into at least two positive integers that sum up to \\(n\\), and find the maximum product of these integers, as illustrated in the figure below.</p> <p></p> <p>Assume we split \\(n\\) into \\(m\\) integer factors, where the \\(i\\)-th factor is denoted as \\(n_i\\), that is,</p> \\[ n = \\sum_{i=1}^{m}n_i \\] <p>The goal of this problem is to find the maximum product of all integer factors, namely,</p> \\[ \\max(\\prod_{i=1}^{m}n_i) \\] <p>We need to consider: How large should the number of splits \\(m\\) be, and what should each \\(n_i\\) be?</p>"},{"location":"chapter_greedy/max_product_cutting_problem/#greedy-strategy-determination","title":"Greedy strategy determination","text":"<p>Experience suggests that the product of two integers is often greater than their sum. Suppose we split a factor of \\(2\\) from \\(n\\), then their product is \\(2(n-2)\\). Compare this product with \\(n\\):</p> \\[ \\begin{aligned} 2(n-2) &amp; \\geq n \\newline 2n - n - 4 &amp; \\geq 0 \\newline n &amp; \\geq 4 \\end{aligned} \\] <p>As shown in the figure below, when \\(n \\geq 4\\), splitting out a \\(2\\) increases the product, which indicates that integers greater than or equal to \\(4\\) should be split.</p> <p>Greedy strategy one: If the splitting scheme includes factors \\(\\geq 4\\), they should be further split. The final split should only include factors \\(1\\), \\(2\\), and \\(3\\).</p> <p></p> <p>Next, consider which factor is optimal. Among the factors \\(1\\), \\(2\\), and \\(3\\), clearly \\(1\\) is the worst, as \\(1 \\times (n-1) &lt; n\\) always holds, meaning splitting out \\(1\\) actually decreases the product.</p> <p>As shown in the figure below, when \\(n = 6\\), \\(3 \\times 3 &gt; 2 \\times 2 \\times 2\\). This means splitting out \\(3\\) is better than splitting out \\(2\\).</p> <p>Greedy strategy two: In the splitting scheme, there should be at most two \\(2\\)s. Because three \\(2\\)s can always be replaced by two \\(3\\)s to obtain a higher product.</p> <p></p> <p>From the above, the following greedy strategies can be derived.</p> <ol> <li>Input integer \\(n\\), continually split out factor \\(3\\) until the remainder is \\(0\\), \\(1\\), or \\(2\\).</li> <li>When the remainder is \\(0\\), it means \\(n\\) is a multiple of \\(3\\), so no further action is taken.</li> <li>When the remainder is \\(2\\), do not continue to split, keep it.</li> <li>When the remainder is \\(1\\), since \\(2 \\times 2 &gt; 1 \\times 3\\), the last \\(3\\) should be replaced with \\(2\\).</li> </ol>"},{"location":"chapter_greedy/max_product_cutting_problem/#code-implementation","title":"Code implementation","text":"<p>As shown in the figure below, we do not need to use loops to split the integer but can use the floor division operation to get the number of \\(3\\)s, \\(a\\), and the modulo operation to get the remainder, \\(b\\), thus:</p> \\[ n = 3a + b \\] <p>Please note, for the boundary case where \\(n \\leq 3\\), a \\(1\\) must be split out, with a product of \\(1 \\times (n - 1)\\).</p> <pre><code>[file]{max_product_cutting}-[class]{}-[func]{max_product_cutting}\n</code></pre> <p></p> <p>Time complexity depends on the implementation of the power operation in the programming language. For Python, the commonly used power calculation functions are three types:</p> <ul> <li>Both the operator <code>**</code> and the function <code>pow()</code> have a time complexity of \\(O(\\log\u2061 a)\\).</li> <li>The <code>math.pow()</code> function internally calls the C language library's <code>pow()</code> function, performing floating-point exponentiation, with a time complexity of \\(O(1)\\).</li> </ul> <p>Variables \\(a\\) and \\(b\\) use constant size of extra space, hence the space complexity is \\(O(1)\\).</p>"},{"location":"chapter_greedy/max_product_cutting_problem/#correctness-proof","title":"Correctness proof","text":"<p>Using the proof by contradiction, only analyze cases where \\(n \\geq 3\\).</p> <ol> <li>All factors \\(\\leq 3\\): Assume the optimal splitting scheme includes a factor \\(x \\geq 4\\), then it can definitely be further split into \\(2(x-2)\\), obtaining a larger product. This contradicts the assumption.</li> <li>The splitting scheme does not contain \\(1\\): Assume the optimal splitting scheme includes a factor of \\(1\\), then it can definitely be merged into another factor to obtain a larger product. This contradicts the assumption.</li> <li>The splitting scheme contains at most two \\(2\\)s: Assume the optimal splitting scheme includes three \\(2\\)s, then they can definitely be replaced by two \\(3\\)s, achieving a higher product. This contradicts the assumption.</li> </ol>"},{"location":"chapter_greedy/summary/","title":"15.5 Summary","text":""},{"location":"chapter_greedy/summary/#summary","title":"Summary","text":"<ul> <li>Greedy algorithms are often used to solve optimization problems, where the principle is to make locally optimal decisions at each decision stage in order to achieve a globally optimal solution.</li> <li>Greedy algorithms iteratively make one greedy choice after another, transforming the problem into a smaller sub-problem with each round, until the problem is resolved.</li> <li>Greedy algorithms are not only simple to implement but also have high problem-solving efficiency. Compared to dynamic programming, greedy algorithms generally have a lower time complexity.</li> <li>In the problem of coin change, greedy algorithms can guarantee the optimal solution for certain combinations of coins; for others, however, the greedy algorithm might find a very poor solution.</li> <li>Problems suitable for greedy algorithm solutions possess two main properties: greedy-choice property and optimal substructure. The greedy-choice property represents the effectiveness of the greedy strategy.</li> <li>For some complex problems, proving the greedy-choice property is not straightforward. Contrarily, proving the invalidity is often easier, such as with the coin change problem.</li> <li>Solving greedy problems mainly consists of three steps: problem analysis, determining the greedy strategy, and proving correctness. Among these, determining the greedy strategy is the key step, while proving correctness often poses the challenge.</li> <li>The fractional knapsack problem builds on the 0-1 knapsack problem by allowing the selection of a part of the items, hence it can be solved using a greedy algorithm. The correctness of the greedy strategy can be proved by contradiction.</li> <li>The maximum capacity problem can be solved using the exhaustive method, with a time complexity of \\(O(n^2)\\). By designing a greedy strategy, each round moves inwardly shortening the board, optimizing the time complexity to \\(O(n)\\).</li> <li>In the problem of maximum product after cutting, we deduce two greedy strategies: integers \\(\\geq 4\\) should continue to be cut, with the optimal cutting factor being \\(3\\). The code includes power operations, and the time complexity depends on the method of implementing power operations, generally being \\(O(1)\\) or \\(O(\\log n)\\).</li> </ul>"},{"location":"chapter_hashing/","title":"Hash table","text":""},{"location":"chapter_hashing/#hash-table","title":"Hash table","text":"<p>Abstract</p> <p>In the world of computing, a hash table is akin to an intelligent librarian.</p> <p>It understands how to compute index numbers, enabling swift retrieval of the desired book.</p>"},{"location":"chapter_hashing/hash_algorithm/","title":"6.3 Hash algorithm","text":""},{"location":"chapter_hashing/hash_algorithm/#hash-algorithms","title":"Hash algorithms","text":"<p>The previous two sections introduced the working principle of hash tables and the methods to handle hash collisions. However, both open addressing and chaining can only ensure that the hash table functions normally when collisions occur, but cannot reduce the frequency of hash collisions.</p> <p>If hash collisions occur too frequently, the performance of the hash table will deteriorate drastically. As shown in the figure below, for a chaining hash table, in the ideal case, the key-value pairs are evenly distributed across the buckets, achieving optimal query efficiency; in the worst case, all key-value pairs are stored in the same bucket, degrading the time complexity to \\(O(n)\\).</p> <p></p> <p>The distribution of key-value pairs is determined by the hash function. Recalling the steps of calculating a hash function, first compute the hash value, then modulo it by the array length:</p> <pre><code>index = hash(key) % capacity\n</code></pre> <p>Observing the above formula, when the hash table capacity <code>capacity</code> is fixed, the hash algorithm <code>hash()</code> determines the output value, thereby determining the distribution of key-value pairs in the hash table.</p> <p>This means that, to reduce the probability of hash collisions, we should focus on the design of the hash algorithm <code>hash()</code>.</p>"},{"location":"chapter_hashing/hash_algorithm/#goals-of-hash-algorithms","title":"Goals of hash algorithms","text":"<p>To achieve a \"fast and stable\" hash table data structure, hash algorithms should have the following characteristics:</p> <ul> <li>Determinism: For the same input, the hash algorithm should always produce the same output. Only then can the hash table be reliable.</li> <li>High efficiency: The process of computing the hash value should be fast enough. The smaller the computational overhead, the more practical the hash table.</li> <li>Uniform distribution: The hash algorithm should ensure that key-value pairs are evenly distributed in the hash table. The more uniform the distribution, the lower the probability of hash collisions.</li> </ul> <p>In fact, hash algorithms are not only used to implement hash tables but are also widely applied in other fields.</p> <ul> <li>Password storage: To protect the security of user passwords, systems usually do not store the plaintext passwords but rather the hash values of the passwords. When a user enters a password, the system calculates the hash value of the input and compares it with the stored hash value. If they match, the password is considered correct.</li> <li>Data integrity check: The data sender can calculate the hash value of the data and send it along; the receiver can recalculate the hash value of the received data and compare it with the received hash value. If they match, the data is considered intact.</li> </ul> <p>For cryptographic applications, to prevent reverse engineering such as deducing the original password from the hash value, hash algorithms need higher-level security features.</p> <ul> <li>Unidirectionality: It should be impossible to deduce any information about the input data from the hash value.</li> <li>Collision resistance: It should be extremely difficult to find two different inputs that produce the same hash value.</li> <li>Avalanche effect: Minor changes in the input should lead to significant and unpredictable changes in the output.</li> </ul> <p>Note that \"Uniform Distribution\" and \"Collision Resistance\" are two separate concepts. Satisfying uniform distribution does not necessarily mean collision resistance. For example, under random input <code>key</code>, the hash function <code>key % 100</code> can produce a uniformly distributed output. However, this hash algorithm is too simple, and all <code>key</code> with the same last two digits will have the same output, making it easy to deduce a usable <code>key</code> from the hash value, thereby cracking the password.</p>"},{"location":"chapter_hashing/hash_algorithm/#design-of-hash-algorithms","title":"Design of hash algorithms","text":"<p>The design of hash algorithms is a complex issue that requires consideration of many factors. However, for some less demanding scenarios, we can also design some simple hash algorithms.</p> <ul> <li>Additive hash: Add up the ASCII codes of each character in the input and use the total sum as the hash value.</li> <li>Multiplicative hash: Utilize the non-correlation of multiplication, multiplying each round by a constant, accumulating the ASCII codes of each character into the hash value.</li> <li>XOR hash: Accumulate the hash value by XORing each element of the input data.</li> <li>Rotating hash: Accumulate the ASCII code of each character into a hash value, performing a rotation operation on the hash value before each accumulation.</li> </ul> <pre><code>[file]{simple_hash}-[class]{}-[func]{rot_hash}\n</code></pre> <p>It is observed that the last step of each hash algorithm is to take the modulus of the large prime number \\(1000000007\\) to ensure that the hash value is within an appropriate range. It is worth pondering why emphasis is placed on modulo a prime number, or what are the disadvantages of modulo a composite number? This is an interesting question.</p> <p>To conclude: Using a large prime number as the modulus can maximize the uniform distribution of hash values. Since a prime number does not share common factors with other numbers, it can reduce the periodic patterns caused by the modulo operation, thus avoiding hash collisions.</p> <p>For example, suppose we choose the composite number \\(9\\) as the modulus, which can be divided by \\(3\\), then all <code>key</code> divisible by \\(3\\) will be mapped to hash values \\(0\\), \\(3\\), \\(6\\).</p> \\[ \\begin{aligned} \\text{modulus} &amp; = 9 \\newline \\text{key} &amp; = \\{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \\dots \\} \\newline \\text{hash} &amp; = \\{ 0, 3, 6, 0, 3, 6, 0, 3, 6, 0, 3, 6,\\dots \\} \\end{aligned} \\] <p>If the input <code>key</code> happens to have this kind of arithmetic sequence distribution, then the hash values will cluster, thereby exacerbating hash collisions. Now, suppose we replace <code>modulus</code> with the prime number \\(13\\), since there are no common factors between <code>key</code> and <code>modulus</code>, the uniformity of the output hash values will be significantly improved.</p> \\[ \\begin{aligned} \\text{modulus} &amp; = 13 \\newline \\text{key} &amp; = \\{ 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, \\dots \\} \\newline \\text{hash} &amp; = \\{ 0, 3, 6, 9, 12, 2, 5, 8, 11, 1, 4, 7, \\dots \\} \\end{aligned} \\] <p>It is worth noting that if the <code>key</code> is guaranteed to be randomly and uniformly distributed, then choosing a prime number or a composite number as the modulus can both produce uniformly distributed hash values. However, when the distribution of <code>key</code> has some periodicity, modulo a composite number is more likely to result in clustering.</p> <p>In summary, we usually choose a prime number as the modulus, and this prime number should be large enough to eliminate periodic patterns as much as possible, enhancing the robustness of the hash algorithm.</p>"},{"location":"chapter_hashing/hash_algorithm/#common-hash-algorithms","title":"Common hash algorithms","text":"<p>It is not hard to see that the simple hash algorithms mentioned above are quite \"fragile\" and far from reaching the design goals of hash algorithms. For example, since addition and XOR obey the commutative law, additive hash and XOR hash cannot distinguish strings with the same content but in different order, which may exacerbate hash collisions and cause security issues.</p> <p>In practice, we usually use some standard hash algorithms, such as MD5, SHA-1, SHA-2, and SHA-3. They can map input data of any length to a fixed-length hash value.</p> <p>Over the past century, hash algorithms have been in a continuous process of upgrading and optimization. Some researchers strive to improve the performance of hash algorithms, while others, including hackers, are dedicated to finding security issues in hash algorithms. The table below shows hash algorithms commonly used in practical applications.</p> <ul> <li>MD5 and SHA-1 have been successfully attacked multiple times and are thus abandoned in various security applications.</li> <li>SHA-2 series, especially SHA-256, is one of the most secure hash algorithms to date, with no successful attacks reported, hence commonly used in various security applications and protocols.</li> <li>SHA-3 has lower implementation costs and higher computational efficiency compared to SHA-2, but its current usage coverage is not as extensive as the SHA-2 series.</li> </ul> <p> Table  \u00a0 Common hash algorithms </p> MD5 SHA-1 SHA-2 SHA-3 Release Year 1992 1995 2002 2008 Output Length 128 bit 160 bit 256/512 bit 224/256/384/512 bit Hash Collisions Frequent Frequent Rare Rare Security Level Low, has been successfully attacked Low, has been successfully attacked High High Applications Abandoned, still used for data integrity checks Abandoned Cryptocurrency transaction verification, digital signatures, etc. Can be used to replace SHA-2"},{"location":"chapter_hashing/hash_algorithm/#hash-values-in-data-structures","title":"Hash values in data structures","text":"<p>We know that the keys in a hash table can be of various data types such as integers, decimals, or strings. Programming languages usually provide built-in hash algorithms for these data types to calculate the bucket indices in the hash table. Taking Python as an example, we can use the <code>hash()</code> function to compute the hash values for various data types.</p> <ul> <li>The hash values of integers and booleans are their own values.</li> <li>The calculation of hash values for floating-point numbers and strings is more complex, and interested readers are encouraged to study this on their own.</li> <li>The hash value of a tuple is a combination of the hash values of each of its elements, resulting in a single hash value.</li> <li>The hash value of an object is generated based on its memory address. By overriding the hash method of an object, hash values can be generated based on content.</li> </ul> <p>Tip</p> <p>Be aware that the definition and methods of the built-in hash value calculation functions in different programming languages vary.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig built_in_hash.py<pre><code>num = 3\nhash_num = hash(num)\n# Hash value of integer 3 is 3\n\nbol = True\nhash_bol = hash(bol)\n# Hash value of boolean True is 1\n\ndec = 3.14159\nhash_dec = hash(dec)\n# Hash value of decimal 3.14159 is 326484311674566659\n\nstr = \"Hello \u7b97\u6cd5\"\nhash_str = hash(str)\n# Hash value of string \"Hello \u7b97\u6cd5\" is 4617003410720528961\n\ntup = (12836, \"\u5c0f\u54c8\")\nhash_tup = hash(tup)\n# Hash value of tuple (12836, '\u5c0f\u54c8') is 1029005403108185979\n\nobj = ListNode(0)\nhash_obj = hash(obj)\n# Hash value of ListNode object at 0x1058fd810 is 274267521\n</code></pre> built_in_hash.cpp<pre><code>int num = 3;\nsize_t hashNum = hash&lt;int&gt;()(num);\n// Hash value of integer 3 is 3\n\nbool bol = true;\nsize_t hashBol = hash&lt;bool&gt;()(bol);\n// Hash value of boolean 1 is 1\n\ndouble dec = 3.14159;\nsize_t hashDec = hash&lt;double&gt;()(dec);\n// Hash value of decimal 3.14159 is 4614256650576692846\n\nstring str = \"Hello \u7b97\u6cd5\";\nsize_t hashStr = hash&lt;string&gt;()(str);\n// Hash value of string \"Hello \u7b97\u6cd5\" is 15466937326284535026\n\n// In C++, built-in std::hash() only provides hash values for basic data types\n// Hash values for arrays and objects need to be implemented separately\n</code></pre> built_in_hash.java<pre><code>int num = 3;\nint hashNum = Integer.hashCode(num);\n// Hash value of integer 3 is 3\n\nboolean bol = true;\nint hashBol = Boolean.hashCode(bol);\n// Hash value of boolean true is 1231\n\ndouble dec = 3.14159;\nint hashDec = Double.hashCode(dec);\n// Hash value of decimal 3.14159 is -1340954729\n\nString str = \"Hello \u7b97\u6cd5\";\nint hashStr = str.hashCode();\n// Hash value of string \"Hello \u7b97\u6cd5\" is -727081396\n\nObject[] arr = { 12836, \"\u5c0f\u54c8\" };\nint hashTup = Arrays.hashCode(arr);\n// Hash value of array [12836, \u5c0f\u54c8] is 1151158\n\nListNode obj = new ListNode(0);\nint hashObj = obj.hashCode();\n// Hash value of ListNode object utils.ListNode@7dc5e7b4 is 2110121908\n</code></pre> built_in_hash.cs<pre><code>int num = 3;\nint hashNum = num.GetHashCode();\n// Hash value of integer 3 is 3;\n\nbool bol = true;\nint hashBol = bol.GetHashCode();\n// Hash value of boolean true is 1;\n\ndouble dec = 3.14159;\nint hashDec = dec.GetHashCode();\n// Hash value of decimal 3.14159 is -1340954729;\n\nstring str = \"Hello \u7b97\u6cd5\";\nint hashStr = str.GetHashCode();\n// Hash value of string \"Hello \u7b97\u6cd5\" is -586107568;\n\nobject[] arr = [12836, \"\u5c0f\u54c8\"];\nint hashTup = arr.GetHashCode();\n// Hash value of array [12836, \u5c0f\u54c8] is 42931033;\n\nListNode obj = new(0);\nint hashObj = obj.GetHashCode();\n// Hash value of ListNode object 0 is 39053774;\n</code></pre> built_in_hash.go<pre><code>// Go does not provide built-in hash code functions\n</code></pre> built_in_hash.swift<pre><code>let num = 3\nlet hashNum = num.hashValue\n// Hash value of integer 3 is 9047044699613009734\n\nlet bol = true\nlet hashBol = bol.hashValue\n// Hash value of boolean true is -4431640247352757451\n\nlet dec = 3.14159\nlet hashDec = dec.hashValue\n// Hash value of decimal 3.14159 is -2465384235396674631\n\nlet str = \"Hello \u7b97\u6cd5\"\nlet hashStr = str.hashValue\n// Hash value of string \"Hello \u7b97\u6cd5\" is -7850626797806988787\n\nlet arr = [AnyHashable(12836), AnyHashable(\"\u5c0f\u54c8\")]\nlet hashTup = arr.hashValue\n// Hash value of array [AnyHashable(12836), AnyHashable(\"\u5c0f\u54c8\")] is -2308633508154532996\n\nlet obj = ListNode(x: 0)\nlet hashObj = obj.hashValue\n// Hash value of ListNode object utils.ListNode is -2434780518035996159\n</code></pre> built_in_hash.js<pre><code>// JavaScript does not provide built-in hash code functions\n</code></pre> built_in_hash.ts<pre><code>// TypeScript does not provide built-in hash code functions\n</code></pre> built_in_hash.dart<pre><code>int num = 3;\nint hashNum = num.hashCode;\n// Hash value of integer 3 is 34803\n\nbool bol = true;\nint hashBol = bol.hashCode;\n// Hash value of boolean true is 1231\n\ndouble dec = 3.14159;\nint hashDec = dec.hashCode;\n// Hash value of decimal 3.14159 is 2570631074981783\n\nString str = \"Hello \u7b97\u6cd5\";\nint hashStr = str.hashCode;\n// Hash value of string \"Hello \u7b97\u6cd5\" is 468167534\n\nList arr = [12836, \"\u5c0f\u54c8\"];\nint hashArr = arr.hashCode;\n// Hash value of array [12836, \u5c0f\u54c8] is 976512528\n\nListNode obj = new ListNode(0);\nint hashObj = obj.hashCode;\n// Hash value of ListNode object Instance of 'ListNode' is 1033450432\n</code></pre> built_in_hash.rs<pre><code>use std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nlet num = 3;\nlet mut num_hasher = DefaultHasher::new();\nnum.hash(&amp;mut num_hasher);\nlet hash_num = num_hasher.finish();\n// Hash value of integer 3 is 568126464209439262\n\nlet bol = true;\nlet mut bol_hasher = DefaultHasher::new();\nbol.hash(&amp;mut bol_hasher);\nlet hash_bol = bol_hasher.finish();\n// Hash value of boolean true is 4952851536318644461\n\nlet dec: f32 = 3.14159;\nlet mut dec_hasher = DefaultHasher::new();\ndec.to_bits().hash(&amp;mut dec_hasher);\nlet hash_dec = dec_hasher.finish();\n// Hash value of decimal 3.14159 is 2566941990314602357\n\nlet str = \"Hello \u7b97\u6cd5\";\nlet mut str_hasher = DefaultHasher::new();\nstr.hash(&amp;mut str_hasher);\nlet hash_str = str_hasher.finish();\n// Hash value of string \"Hello \u7b97\u6cd5\" is 16092673739211250988\n\nlet arr = (&amp;12836, &amp;\"\u5c0f\u54c8\");\nlet mut tup_hasher = DefaultHasher::new();\narr.hash(&amp;mut tup_hasher);\nlet hash_tup = tup_hasher.finish();\n// Hash value of tuple (12836, \"\u5c0f\u54c8\") is 1885128010422702749\n\nlet node = ListNode::new(42);\nlet mut hasher = DefaultHasher::new();\nnode.borrow().val.hash(&amp;mut hasher);\nlet hash = hasher.finish();\n// Hash value of ListNode object RefCell { value: ListNode { val: 42, next: None } } is 15387811073369036852\n</code></pre> built_in_hash.c<pre><code>// C does not provide built-in hash code functions\n</code></pre> built_in_hash.kt<pre><code>\n</code></pre> built_in_hash.zig<pre><code>\n</code></pre> Code Visualization <p>https://pythontutor.com/render.html#code=class%20ListNode%3A%0A%20%20%20%20%22%22%22%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%B1%BB%22%22%22%0A%20%20%20%20def%20__init__%28self,%20val%3A%20int%29%3A%0A%20%20%20%20%20%20%20%20self.val%3A%20int%20%3D%20val%20%20%23%20%E8%8A%82%E7%82%B9%E5%80%BC%0A%20%20%20%20%20%20%20%20self.next%3A%20ListNode%20%7C%20None%20%3D%20None%20%20%23%20%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20num%20%3D%203%0A%20%20%20%20hash_num%20%3D%20hash%28num%29%0A%20%20%20%20%23%20%E6%95%B4%E6%95%B0%203%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%203%0A%0A%20%20%20%20bol%20%3D%20True%0A%20%20%20%20hash_bol%20%3D%20hash%28bol%29%0A%20%20%20%20%23%20%E5%B8%83%E5%B0%94%E9%87%8F%20True%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%201%0A%0A%20%20%20%20dec%20%3D%203.14159%0A%20%20%20%20hash_dec%20%3D%20hash%28dec%29%0A%20%20%20%20%23%20%E5%B0%8F%E6%95%B0%203.14159%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%20326484311674566659%0A%0A%20%20%20%20str%20%3D%20%22Hello%20%E7%AE%97%E6%B3%95%22%0A%20%20%20%20hash_str%20%3D%20hash%28str%29%0A%20%20%20%20%23%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9CHello%20%E7%AE%97%E6%B3%95%E2%80%9D%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%204617003410720528961%0A%0A%20%20%20%20tup%20%3D%20%2812836,%20%22%E5%B0%8F%E5%93%88%22%29%0A%20%20%20%20hash_tup%20%3D%20hash%28tup%29%0A%20%20%20%20%23%20%E5%85%83%E7%BB%84%20%2812836,%20'%E5%B0%8F%E5%93%88'%29%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%201029005403108185979%0A%0A%20%20%20%20obj%20%3D%20ListNode%280%29%0A%20%20%20%20hash_obj%20%3D%20hash%28obj%29%0A%20%20%20%20%23%20%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1%20%3CListNode%20object%20at%200x1058fd810%3E%20%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC%E4%B8%BA%20274267521&amp;cumulative=false&amp;curInstr=19&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p> <p>In many programming languages, only immutable objects can serve as the <code>key</code> in a hash table. If we use a list (dynamic array) as a <code>key</code>, when the contents of the list change, its hash value also changes, and we would no longer be able to find the original <code>value</code> in the hash table.</p> <p>Although the member variables of a custom object (such as a linked list node) are mutable, it is hashable. This is because the hash value of an object is usually generated based on its memory address, and even if the contents of the object change, the memory address remains the same, so the hash value remains unchanged.</p> <p>You might have noticed that the hash values output in different consoles are different. This is because the Python interpreter adds a random salt to the string hash function each time it starts up. This approach effectively prevents HashDoS attacks and enhances the security of the hash algorithm.</p>"},{"location":"chapter_hashing/hash_collision/","title":"6.2 Hash collision","text":""},{"location":"chapter_hashing/hash_collision/#hash-collision","title":"Hash collision","text":"<p>The previous section mentioned that, in most cases, the input space of a hash function is much larger than the output space, so theoretically, hash collisions are inevitable. For example, if the input space is all integers and the output space is the size of the array capacity, then multiple integers will inevitably be mapped to the same bucket index.</p> <p>Hash collisions can lead to incorrect query results, severely impacting the usability of the hash table. To address this issue, whenever a hash collision occurs, we perform hash table resizing until the collision disappears. This approach is pretty simple, straightforward, and working well. However, it appears to be pretty inefficient as the table expansion involves a lot of data migration as well as recalculation of hash code, which are expansive. To improve efficiency, we can adopt the following strategies:</p> <ol> <li>Improve the hash table data structure in a way that locating target element is still functioning well in the event of a hash collision.</li> <li>Expansion is the last resort before it becomes necessary, when severe collisions are observed.</li> </ol> <p>There are mainly two methods for improving the structure of hash tables: \"Separate Chaining\" and \"Open Addressing\".</p>"},{"location":"chapter_hashing/hash_collision/#separate-chaining","title":"Separate chaining","text":"<p>In the original hash table, each bucket can store only one key-value pair. Separate chaining converts a single element into a linked list, treating key-value pairs as list nodes, storing all colliding key-value pairs in the same linked list. The figure below shows an example of a hash table with separate chaining.</p> <p></p> <p>The operations of a hash table implemented with separate chaining have changed as follows:</p> <ul> <li>Querying Elements: Input <code>key</code>, obtain the bucket index through the hash function, then access the head node of the linked list. Traverse the linked list and compare key to find the target key-value pair.</li> <li>Adding Elements: Access the head node of the linked list via the hash function, then append the node (key-value pair) to the list.</li> <li>Deleting Elements: Access the head of the linked list based on the result of the hash function, then traverse the linked list to find the target node and delete it.</li> </ul> <p>Separate chaining has the following limitations:</p> <ul> <li>Increased Space Usage: The linked list contains node pointers, which consume more memory space than arrays.</li> <li>Reduced Query Efficiency: This is because linear traversal of the linked list is required to find the corresponding element.</li> </ul> <p>The code below provides a simple implementation of a separate chaining hash table, with two things to note:</p> <ul> <li>Lists (dynamic arrays) are used instead of linked lists for simplicity. In this setup, the hash table (array) contains multiple buckets, each of which is a list.</li> <li>This implementation includes a hash table resizing method. When the load factor exceeds \\(\\frac{2}{3}\\), we expand the hash table to twice its original size.</li> </ul> <pre><code>[file]{hash_map_chaining}-[class]{hash_map_chaining}-[func]{}\n</code></pre> <p>It's worth noting that when the linked list is very long, the query efficiency \\(O(n)\\) is poor. In this case, the list can be converted to an \"AVL tree\" or \"Red-Black tree\" to optimize the time complexity of the query operation to \\(O(\\log n)\\).</p>"},{"location":"chapter_hashing/hash_collision/#open-addressing","title":"Open addressing","text":"<p>Open addressing does not introduce additional data structures but instead handles hash collisions through \"multiple probing\". The probing methods mainly include linear probing, quadratic probing, and double hashing.</p> <p>Let's use linear probing as an example to introduce the mechanism of open addressing hash tables.</p>"},{"location":"chapter_hashing/hash_collision/#linear-probing","title":"Linear probing","text":"<p>Linear probing uses a fixed-step linear search for probing, differing from ordinary hash tables.</p> <ul> <li>Inserting Elements: Calculate the bucket index using the hash function. If the bucket already contains an element, linearly traverse forward from the conflict position (usually with a step size of \\(1\\)) until an empty bucket is found, then insert the element.</li> <li>Searching for Elements: If a hash collision is encountered, use the same step size to linearly traverse forward until the corresponding element is found and return <code>value</code>; if an empty bucket is encountered, it means the target element is not in the hash table, so return <code>None</code>.</li> </ul> <p>The figure below shows the distribution of key-value pairs in an open addressing (linear probing) hash table. According to this hash function, keys with the same last two digits will be mapped to the same bucket. Through linear probing, they are stored sequentially in that bucket and the buckets below it.</p> <p></p> <p>However, linear probing is prone to create \"clustering\". Specifically, the longer the continuously occupied positions in the array, the greater the probability of hash collisions occurring in these continuous positions, further promoting the growth of clustering at that position, forming a vicious cycle, and ultimately leading to degraded efficiency of insertion, deletion, query, and update operations.</p> <p>It's important to note that we cannot directly delete elements in an open addressing hash table. Deleting an element creates an empty bucket <code>None</code> in the array. When searching for elements, if linear probing encounters this empty bucket, it will return, making the elements below this bucket inaccessible. The program may incorrectly assume these elements do not exist, as shown in the figure below.</p> <p></p> <p>To solve this problem, we can adopt the lazy deletion mechanism: instead of directly removing elements from the hash table, use a constant <code>TOMBSTONE</code> to mark the bucket. In this mechanism, both <code>None</code> and <code>TOMBSTONE</code> represent empty buckets and can hold key-value pairs. However, when linear probing encounters <code>TOMBSTONE</code>, it should continue traversing since there may still be key-value pairs below it.</p> <p>However, lazy deletion may accelerate the performance degradation of the hash table. Every deletion operation produces a delete mark, and as <code>TOMBSTONE</code> increases, the search time will also increase because linear probing may need to skip multiple <code>TOMBSTONE</code> to find the target element.</p> <p>To address this, consider recording the index of the first encountered <code>TOMBSTONE</code> during linear probing and swapping the positions of the searched target element with that <code>TOMBSTONE</code>. The benefit of doing this is that each time an element is queried or added, the element will be moved to a bucket closer to its ideal position (the starting point of probing), thereby optimizing query efficiency.</p> <p>The code below implements an open addressing (linear probing) hash table with lazy deletion. To make better use of the hash table space, we treat the hash table as a \"circular array,\". When going beyond the end of the array, we return to the beginning and continue traversing.</p> <pre><code>[file]{hash_map_open_addressing}-[class]{hash_map_open_addressing}-[func]{}\n</code></pre>"},{"location":"chapter_hashing/hash_collision/#quadratic-probing","title":"Quadratic probing","text":"<p>Quadratic probing is similar to linear probing and is one of the common strategies of open addressing. When a collision occurs, quadratic probing does not simply skip a fixed number of steps but skips a number of steps equal to the \"square of the number of probes\", i.e., \\(1, 4, 9, \\dots\\) steps.</p> <p>Quadratic probing has the following advantages:</p> <ul> <li>Quadratic probing attempts to alleviate the clustering effect of linear probing by skipping the distance of the square of the number of probes.</li> <li>Quadratic probing skips larger distances to find empty positions, which helps to distribute data more evenly.</li> </ul> <p>However, quadratic probing is not perfect:</p> <ul> <li>Clustering still exists, i.e., some positions are more likely to be occupied than others.</li> <li>Due to the growth of squares, quadratic probing may not probe the entire hash table, meaning that even if there are empty buckets in the hash table, quadratic probing may not be able to access them.</li> </ul>"},{"location":"chapter_hashing/hash_collision/#double-hashing","title":"Double hashing","text":"<p>As the name suggests, the double hashing method uses multiple hash functions \\(f_1(x)\\), \\(f_2(x)\\), \\(f_3(x)\\), \\(\\dots\\) for probing.</p> <ul> <li>Inserting Elements: If hash function \\(f_1(x)\\) encounters a conflict, it tries \\(f_2(x)\\), and so on, until an empty position is found and the element is inserted.</li> <li>Searching for Elements: Search in the same order of hash functions until the target element is found and returned; if an empty position is encountered or all hash functions have been tried, it indicates the element is not in the hash table, then return <code>None</code>.</li> </ul> <p>Compared to linear probing, the double hashing method is less prone to clustering, but multiple hash functions introduce additional computational overhead.</p> <p>Tip</p> <p>Please note that open addressing (linear probing, quadratic probing, and double hashing) hash tables all have the problem of \"can not directly delete elements.\"</p>"},{"location":"chapter_hashing/hash_collision/#choice-of-programming-languages","title":"Choice of programming languages","text":"<p>Different programming languages adopt different hash table implementation strategies. Here are a few examples:</p> <ul> <li>Python uses open addressing. The <code>dict</code> dictionary uses pseudo-random numbers for probing.</li> <li>Java uses separate chaining. Since JDK 1.8, when the array length in <code>HashMap</code> reaches 64 and the length of a linked list reaches 8, the linked list is converted to a red-black tree to improve search performance.</li> <li>Go uses separate chaining. Go stipulates that each bucket can store up to 8 key-value pairs, and if the capacity is exceeded, an overflow bucket is linked; when there are too many overflow buckets, a special equal-capacity resizing operation is performed to ensure performance.</li> </ul>"},{"location":"chapter_hashing/hash_map/","title":"6.1 Hash table","text":""},{"location":"chapter_hashing/hash_map/#hash-table","title":"Hash table","text":"<p>A hash table, also known as a hash map, is a data structure that establishes a mapping between keys and values, enabling efficient element retrieval. Specifically, when we input a <code>key</code> into the hash table, we can retrieve the corresponding <code>value</code> in \\(O(1)\\) time complexity.</p> <p>As shown in the figure below, given \\(n\\) students, each student has two data fields: \"Name\" and \"Student ID\". If we want to implement a query function that takes a student ID as input and returns the corresponding name, we can use the hash table shown in the figure below.</p> <p></p> <p>In addition to hash tables, arrays and linked lists can also be used to implement query functionality, but the time complexity is different. Their efficiency is compared in the table below:</p> <ul> <li>Inserting an element: Simply append the element to the tail of the array (or linked list). The time complexity of this operation is \\(O(1)\\).</li> <li>Searching for an element: As the array (or linked list) is unsorted, searching for an element requires traversing through all of the elements. The time complexity of this operation is \\(O(n)\\).</li> <li>Deleting an element: To remove an element, we first need to locate it. Then, we delete it from the array (or linked list). The time complexity of this operation is \\(O(n)\\).</li> </ul> <p> Table  \u00a0 Comparison of time efficiency for common operations </p> Array Linked List Hash Table Search Elements \\(O(n)\\) \\(O(n)\\) \\(O(1)\\) Insert Elements \\(O(1)\\) \\(O(1)\\) \\(O(1)\\) Delete Elements \\(O(n)\\) \\(O(n)\\) \\(O(1)\\) <p>As observed, the time complexity for operations (insertion, deletion, searching, and modification) in a hash table is \\(O(1)\\), which is highly efficient.</p>"},{"location":"chapter_hashing/hash_map/#common-operations-of-hash-table","title":"Common operations of hash table","text":"<p>Common operations of a hash table include: initialization, querying, adding key-value pairs, and deleting key-value pairs. Here is an example code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig hash_map.py<pre><code># Initialize hash table\nhmap: dict = {}\n\n# Add operation\n# Add key-value pair (key, value) to the hash table\nhmap[12836] = \"Xiao Ha\"\nhmap[15937] = \"Xiao Luo\"\nhmap[16750] = \"Xiao Suan\"\nhmap[13276] = \"Xiao Fa\"\nhmap[10583] = \"Xiao Ya\"\n\n# Query operation\n# Input key into hash table, get value\nname: str = hmap[15937]\n\n# Delete operation\n# Delete key-value pair (key, value) from hash table\nhmap.pop(10583)\n</code></pre> hash_map.cpp<pre><code>/* Initialize hash table */\nunordered_map&lt;int, string&gt; map;\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap[12836] = \"Xiao Ha\";\nmap[15937] = \"Xiao Luo\";\nmap[16750] = \"Xiao Suan\";\nmap[13276] = \"Xiao Fa\";\nmap[10583] = \"Xiao Ya\";\n\n/* Query operation */\n// Input key into hash table, get value\nstring name = map[15937];\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.erase(10583);\n</code></pre> hash_map.java<pre><code>/* Initialize hash table */\nMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap.put(12836, \"Xiao Ha\");   \nmap.put(15937, \"Xiao Luo\");   \nmap.put(16750, \"Xiao Suan\");   \nmap.put(13276, \"Xiao Fa\");\nmap.put(10583, \"Xiao Ya\");\n\n/* Query operation */\n// Input key into hash table, get value\nString name = map.get(15937);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.remove(10583);\n</code></pre> hash_map.cs<pre><code>/* Initialize hash table */\nDictionary&lt;int, string&gt; map = new() {\n    /* Add operation */\n    // Add key-value pair (key, value) to hash table\n    { 12836, \"Xiao Ha\" },\n    { 15937, \"Xiao Luo\" },\n    { 16750, \"Xiao Suan\" },\n    { 13276, \"Xiao Fa\" },\n    { 10583, \"Xiao Ya\" }\n};\n\n/* Query operation */\n// Input key into hash table, get value\nstring name = map[15937];\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.Remove(10583);\n</code></pre> hash_map_test.go<pre><code>/* Initialize hash table */\nhmap := make(map[int]string)\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nhmap[12836] = \"Xiao Ha\"\nhmap[15937] = \"Xiao Luo\"\nhmap[16750] = \"Xiao Suan\"\nhmap[13276] = \"Xiao Fa\"\nhmap[10583] = \"Xiao Ya\"\n\n/* Query operation */\n// Input key into hash table, get value\nname := hmap[15937]\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\ndelete(hmap, 10583)\n</code></pre> hash_map.swift<pre><code>/* Initialize hash table */\nvar map: [Int: String] = [:]\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap[12836] = \"Xiao Ha\"\nmap[15937] = \"Xiao Luo\"\nmap[16750] = \"Xiao Suan\"\nmap[13276] = \"Xiao Fa\"\nmap[10583] = \"Xiao Ya\"\n\n/* Query operation */\n// Input key into hash table, get value\nlet name = map[15937]!\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.removeValue(forKey: 10583)\n</code></pre> hash_map.js<pre><code>/* Initialize hash table */\nconst map = new Map();\n/* Add operation */\n// Add key-value pair (key, value) to the hash table\nmap.set(12836, 'Xiao Ha');\nmap.set(15937, 'Xiao Luo');\nmap.set(16750, 'Xiao Suan');\nmap.set(13276, 'Xiao Fa');\nmap.set(10583, 'Xiao Ya');\n\n/* Query operation */\n// Input key into hash table, get value\nlet name = map.get(15937);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.delete(10583);\n</code></pre> hash_map.ts<pre><code>/* Initialize hash table */\nconst map = new Map&lt;number, string&gt;();\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap.set(12836, 'Xiao Ha');\nmap.set(15937, 'Xiao Luo');\nmap.set(16750, 'Xiao Suan');\nmap.set(13276, 'Xiao Fa');\nmap.set(10583, 'Xiao Ya');\nconsole.info('\\nAfter adding, the hash table is\\nKey -&gt; Value');\nconsole.info(map);\n\n/* Query operation */\n// Input key into hash table, get value\nlet name = map.get(15937);\nconsole.info('\\nInput student number 15937, query name ' + name);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.delete(10583);\nconsole.info('\\nAfter deleting 10583, the hash table is\\nKey -&gt; Value');\nconsole.info(map);\n</code></pre> hash_map.dart<pre><code>/* Initialize hash table */\nMap&lt;int, String&gt; map = {};\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap[12836] = \"Xiao Ha\";\nmap[15937] = \"Xiao Luo\";\nmap[16750] = \"Xiao Suan\";\nmap[13276] = \"Xiao Fa\";\nmap[10583] = \"Xiao Ya\";\n\n/* Query operation */\n// Input key into hash table, get value\nString name = map[15937];\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nmap.remove(10583);\n</code></pre> hash_map.rs<pre><code>use std::collections::HashMap;\n\n/* Initialize hash table */\nlet mut map: HashMap&lt;i32, String&gt; = HashMap::new();\n\n/* Add operation */\n// Add key-value pair (key, value) to hash table\nmap.insert(12836, \"Xiao Ha\".to_string());\nmap.insert(15937, \"Xiao Luo\".to_string());\nmap.insert(16750, \"Xiao Suan\".to_string());\nmap.insert(13279, \"Xiao Fa\".to_string());\nmap.insert(10583, \"Xiao Ya\".to_string());\n\n/* Query operation */\n// Input key into hash table, get value\nlet _name: Option&lt;&amp;String&gt; = map.get(&amp;15937);\n\n/* Delete operation */\n// Delete key-value pair (key, value) from hash table\nlet _removed_value: Option&lt;String&gt; = map.remove(&amp;10583);\n</code></pre> hash_map.c<pre><code>// C does not provide a built-in hash table\n</code></pre> hash_map.kt<pre><code>\n</code></pre> hash_map.zig<pre><code>\n</code></pre> Code Visualization <p>https://pythontutor.com/render.html#code=%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%93%88%E5%B8%8C%E8%A1%A8%0A%20%20%20%20hmap%20%3D%20%7B%7D%0A%20%20%20%20%0A%20%20%20%20%23%20%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%0A%20%20%20%20%23%20%E5%9C%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9%20%28key,%20value%29%0A%20%20%20%20hmap%5B12836%5D%20%3D%20%22%E5%B0%8F%E5%93%88%22%0A%20%20%20%20hmap%5B15937%5D%20%3D%20%22%E5%B0%8F%E5%95%B0%22%0A%20%20%20%20hmap%5B16750%5D%20%3D%20%22%E5%B0%8F%E7%AE%97%22%0A%20%20%20%20hmap%5B13276%5D%20%3D%20%22%E5%B0%8F%E6%B3%95%22%0A%20%20%20%20hmap%5B10583%5D%20%3D%20%22%E5%B0%8F%E9%B8%AD%22%0A%20%20%20%20%0A%20%20%20%20%23%20%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%0A%20%20%20%20%23%20%E5%90%91%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E9%94%AE%20key%20%EF%BC%8C%E5%BE%97%E5%88%B0%E5%80%BC%20value%0A%20%20%20%20name%20%3D%20hmap%5B15937%5D%0A%20%20%20%20%0A%20%20%20%20%23%20%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%0A%20%20%20%20%23%20%E5%9C%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9%20%28key,%20value%29%0A%20%20%20%20hmap.pop%2810583%29&amp;cumulative=false&amp;curInstr=2&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p> <p>There are three common ways to traverse a hash table: traversing key-value pairs, traversing keys, and traversing values. Here is an example code:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig hash_map.py<pre><code># Traverse hash table\n# Traverse key-value pairs key-&gt;value\nfor key, value in hmap.items():\n    print(key, \"-&gt;\", value)\n# Traverse keys only\nfor key in hmap.keys():\n    print(key)\n# Traverse values only\nfor value in hmap.values():\n    print(value)\n</code></pre> hash_map.cpp<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor (auto kv: map) {\n    cout &lt;&lt; kv.first &lt;&lt; \" -&gt; \" &lt;&lt; kv.second &lt;&lt; endl;\n}\n// Traverse using iterator key-&gt;value\nfor (auto iter = map.begin(); iter != map.end(); iter++) {\n    cout &lt;&lt; iter-&gt;first &lt;&lt; \"-&gt;\" &lt;&lt; iter-&gt;second &lt;&lt; endl;\n}\n</code></pre> hash_map.java<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor (Map.Entry&lt;Integer, String&gt; kv: map.entrySet()) {\n    System.out.println(kv.getKey() + \" -&gt; \" + kv.getValue());\n}\n// Traverse keys only\nfor (int key: map.keySet()) {\n    System.out.println(key);\n}\n// Traverse values only\nfor (String val: map.values()) {\n    System.out.println(val);\n}\n</code></pre> hash_map.cs<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nforeach (var kv in map) {\n    Console.WriteLine(kv.Key + \" -&gt; \" + kv.Value);\n}\n// Traverse keys only\nforeach (int key in map.Keys) {\n    Console.WriteLine(key);\n}\n// Traverse values only\nforeach (string val in map.Values) {\n    Console.WriteLine(val);\n}\n</code></pre> hash_map_test.go<pre><code>/* Traverse hash table */\n// Traverse key-value pairs key-&gt;value\nfor key, value := range hmap {\n    fmt.Println(key, \"-&gt;\", value)\n}\n// Traverse keys only\nfor key := range hmap {\n    fmt.Println(key)\n}\n// Traverse values only\nfor _, value := range hmap {\n    fmt.Println(value)\n}\n</code></pre> hash_map.swift<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nfor (key, value) in map {\n    print(\"\\(key) -&gt; \\(value)\")\n}\n// Traverse keys only\nfor key in map.keys {\n    print(key)\n}\n// Traverse values only\nfor value in map.values {\n    print(value)\n}\n</code></pre> hash_map.js<pre><code>/* Traverse hash table */\nconsole.info('\\nTraverse key-value pairs Key-&gt;Value');\nfor (const [k, v] of map.entries()) {\n    console.info(k + ' -&gt; ' + v);\n}\nconsole.info('\\nTraverse keys only Key');\nfor (const k of map.keys()) {\n    console.info(k);\n}\nconsole.info('\\nTraverse values only Value');\nfor (const v of map.values()) {\n    console.info(v);\n}\n</code></pre> hash_map.ts<pre><code>/* Traverse hash table */\nconsole.info('\\nTraverse key-value pairs Key-&gt;Value');\nfor (const [k, v] of map.entries()) {\n    console.info(k + ' -&gt; ' + v);\n}\nconsole.info('\\nTraverse keys only Key');\nfor (const k of map.keys()) {\n    console.info(k);\n}\nconsole.info('\\nTraverse values only Value');\nfor (const v of map.values()) {\n    console.info(v);\n}\n</code></pre> hash_map.dart<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nmap.forEach((key, value) {\nprint('$key -&gt; $value');\n});\n\n// Traverse keys only Key\nmap.keys.forEach((key) {\nprint(key);\n});\n\n// Traverse values only Value\nmap.values.forEach((value) {\nprint(value);\n});\n</code></pre> hash_map.rs<pre><code>/* Traverse hash table */\n// Traverse key-value pairs Key-&gt;Value\nfor (key, value) in &amp;map {\n    println!(\"{key} -&gt; {value}\");\n}\n\n// Traverse keys only Key\nfor key in map.keys() {\n    println!(\"{key}\"); \n}\n\n// Traverse values only Value\nfor value in map.values() {\n    println!(\"{value}\");\n}\n</code></pre> hash_map.c<pre><code>// C does not provide a built-in hash table\n</code></pre> hash_map.kt<pre><code>\n</code></pre> hash_map.zig<pre><code>// Zig example is not provided\n</code></pre> Code Visualization <p>https://pythontutor.com/render.html#code=%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%93%88%E5%B8%8C%E8%A1%A8%0A%20%20%20%20hmap%20%3D%20%7B%7D%0A%20%20%20%20%0A%20%20%20%20%23%20%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%0A%20%20%20%20%23%20%E5%9C%A8%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9%20%28key,%20value%29%0A%20%20%20%20hmap%5B12836%5D%20%3D%20%22%E5%B0%8F%E5%93%88%22%0A%20%20%20%20hmap%5B15937%5D%20%3D%20%22%E5%B0%8F%E5%95%B0%22%0A%20%20%20%20hmap%5B16750%5D%20%3D%20%22%E5%B0%8F%E7%AE%97%22%0A%20%20%20%20hmap%5B13276%5D%20%3D%20%22%E5%B0%8F%E6%B3%95%22%0A%20%20%20%20hmap%5B10583%5D%20%3D%20%22%E5%B0%8F%E9%B8%AD%22%0A%20%20%20%20%0A%20%20%20%20%23%20%E9%81%8D%E5%8E%86%E5%93%88%E5%B8%8C%E8%A1%A8%0A%20%20%20%20%23%20%E9%81%8D%E5%8E%86%E9%94%AE%E5%80%BC%E5%AF%B9%20key-%3Evalue%0A%20%20%20%20for%20key,%20value%20in%20hmap.items%28%29%3A%0A%20%20%20%20%20%20%20%20print%28key,%20%22-%3E%22,%20value%29%0A%20%20%20%20%23%20%E5%8D%95%E7%8B%AC%E9%81%8D%E5%8E%86%E9%94%AE%20key%0A%20%20%20%20for%20key%20in%20hmap.keys%28%29%3A%0A%20%20%20%20%20%20%20%20print%28key%29%0A%20%20%20%20%23%20%E5%8D%95%E7%8B%AC%E9%81%8D%E5%8E%86%E5%80%BC%20value%0A%20%20%20%20for%20value%20in%20hmap.values%28%29%3A%0A%20%20%20%20%20%20%20%20print%28value%29&amp;cumulative=false&amp;curInstr=8&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_hashing/hash_map/#simple-implementation-of-a-hash-table","title":"Simple implementation of a hash table","text":"<p>First, let's consider the simplest case: implementing a hash table using only one array. In the hash table, each empty slot in the array is called a bucket, and each bucket can store a key-value pair. Therefore, the query operation involves finding the bucket corresponding to the <code>key</code> and retrieving the <code>value</code> from it.</p> <p>So, how do we locate the corresponding bucket based on the <code>key</code>? This is achieved through a hash function. The role of the hash function is to map a larger input space to a smaller output space. In a hash table, the input space consists of all the keys, and the output space consists of all the buckets (array indices). In other words, given a <code>key</code>, we can use the hash function to determine the storage location of the corresponding key-value pair in the array.</p> <p>With a given <code>key</code>, the calculation of the hash function consists of two steps:</p> <ol> <li>Calculate the hash value by using a certain hash algorithm <code>hash()</code>.</li> <li>Take the modulus of the hash value with the bucket count (array length) <code>capacity</code> to obtain the array <code>index</code> corresponding to the key.</li> </ol> <pre><code>index = hash(key) % capacity\n</code></pre> <p>Afterward, we can use the <code>index</code> to access the corresponding bucket in the hash table and thereby retrieve the <code>value</code>.</p> <p>Let's assume that the array length is <code>capacity = 100</code>, and the hash algorithm is defined as <code>hash(key) = key</code>. Therefore, the hash function can be expressed as <code>key % 100</code>. The following figure illustrates the working principle of the hash function using <code>key</code> as student ID and <code>value</code> as name.</p> <p></p> <p>The following code implements a simple hash table. Here, we encapsulate <code>key</code> and <code>value</code> into a class <code>Pair</code> to represent the key-value pair.</p> <pre><code>[file]{array_hash_map}-[class]{array_hash_map}-[func]{}\n</code></pre>"},{"location":"chapter_hashing/hash_map/#hash-collision-and-resizing","title":"Hash collision and resizing","text":"<p>Essentially, the role of the hash function is to map the entire input space of all keys to the output space of all array indices. However, the input space is often much larger than the output space. Therefore, theoretically, there will always be cases where \"multiple inputs correspond to the same output\".</p> <p>In the example above, with the given hash function, when the last two digits of the input <code>key</code> are the same, the hash function produces the same output. For instance, when querying two students with student IDs 12836 and 20336, we find:</p> <pre><code>12836 % 100 = 36\n20336 % 100 = 36\n</code></pre> <p>As shown in the figure below, both student IDs point to the same name, which is obviously incorrect. This situation where multiple inputs correspond to the same output is called hash collision.</p> <p></p> <p>It is easy to understand that as the capacity \\(n\\) of the hash table increases, the probability of multiple keys being assigned to the same bucket decreases, resulting in fewer collisions. Therefore, we can reduce hash collisions by resizing the hash table.</p> <p>As shown in the figure below, before resizing, the key-value pairs <code>(136, A)</code> and <code>(236, D)</code> collide. However, after resizing, the collision is resolved.</p> <p></p> <p>Similar to array expansion, resizing a hash table requires migrating all key-value pairs from the original hash table to the new one, which is time-consuming. Furthermore, since the <code>capacity</code> of the hash table changes, we need to recalculate the storage positions of all key-value pairs using the hash function, further increasing the computational overhead of the resizing process. Therefore, programming languages often allocate a sufficiently large capacity for the hash table to prevent frequent resizing.</p> <p>The load factor is an important concept in hash tables. It is defined as the ratio of the number of elements in the hash table to the number of buckets. It is used to measure the severity of hash collisions and often serves as a trigger for hash table resizing. For example, in Java, when the load factor exceeds \\(0.75\\), the system will resize the hash table to twice its original size.</p>"},{"location":"chapter_hashing/summary/","title":"6.4 Summary","text":""},{"location":"chapter_hashing/summary/#summary","title":"Summary","text":""},{"location":"chapter_hashing/summary/#key-review","title":"Key review","text":"<ul> <li>Given an input <code>key</code>, a hash table can retrieve the corresponding <code>value</code> in \\(O(1)\\) time, which is highly efficient.</li> <li>Common hash table operations include querying, adding key-value pairs, deleting key-value pairs, and traversing the hash table.</li> <li>The hash function maps a <code>key</code> to an array index, allowing access to the corresponding bucket and retrieval of the <code>value</code>.</li> <li>Two different keys may end up with the same array index after hashing, leading to erroneous query results. This phenomenon is known as hash collision.</li> <li>The larger the capacity of the hash table, the lower the probability of hash collisions. Therefore, hash table resizing can mitigate hash collisions. Similar to array resizing, hash table resizing is costly.</li> <li>The load factor, defined as the number of elements divided by the number of buckets, reflects the severity of hash collisions and is often used as a condition to trigger hash table resizing.</li> <li>Chaining addresses hash collisions by converting each element into a linked list, storing all colliding elements in the same list. However, excessively long lists can reduce query efficiency, which can be improved by converting the lists into red-black trees.</li> <li>Open addressing handles hash collisions through multiple probes. Linear probing uses a fixed step size but it cannot delete elements and is prone to clustering. Multiple hashing uses several hash functions for probing which reduces clustering compared to linear probing but increases computational overhead.</li> <li>Different programming languages adopt various hash table implementations. For example, Java's <code>HashMap</code> uses chaining, while Python's <code>dict</code> employs open addressing.</li> <li>In hash tables, we desire hash algorithms with determinism, high efficiency, and uniform distribution. In cryptography, hash algorithms should also possess collision resistance and the avalanche effect.</li> <li>Hash algorithms typically use large prime numbers as moduli to ensure uniform distribution of hash values and reduce hash collisions.</li> <li>Common hash algorithms include MD5, SHA-1, SHA-2, and SHA-3. MD5 is often used for file integrity checks, while SHA-2 is commonly used in secure applications and protocols.</li> <li>Programming languages usually provide built-in hash algorithms for data types to calculate bucket indices in hash tables. Generally, only immutable objects are hashable.</li> </ul>"},{"location":"chapter_hashing/summary/#q-a","title":"Q &amp; A","text":"<p>Q: When does the time complexity of a hash table degrade to \\(O(n)\\)?</p> <p>The time complexity of a hash table can degrade to \\(O(n)\\) when hash collisions are severe. When the hash function is well-designed, the capacity is set appropriately, and collisions are evenly distributed, the time complexity is \\(O(1)\\). We usually consider the time complexity to be \\(O(1)\\) when using built-in hash tables in programming languages.</p> <p>Q: Why not use the hash function \\(f(x) = x\\)? This would eliminate collisions.</p> <p>Under the hash function \\(f(x) = x\\), each element corresponds to a unique bucket index, which is equivalent to an array. However, the input space is usually much larger than the output space (array length), so the last step of a hash function is often to take the modulo of the array length. In other words, the goal of a hash table is to map a larger state space to a smaller one while providing \\(O(1)\\) query efficiency.</p> <p>Q: Why can hash tables be more efficient than arrays, linked lists, or binary trees, even though hash tables are implemented using these structures?</p> <p>Firstly, hash tables have higher time efficiency but lower space efficiency. A significant portion of memory in hash tables remains unused.</p> <p>Secondly, hash tables are only more time-efficient in specific use cases. If a feature can be implemented with the same time complexity using an array or a linked list, it's usually faster than using a hash table. This is because the computation of the hash function incurs overhead, making the constant factor in the time complexity larger.</p> <p>Lastly, the time complexity of hash tables can degrade. For example, in chaining, we perform search operations in a linked list or red-black tree, which still risks degrading to \\(O(n)\\) time.</p> <p>Q: Does multiple hashing also have the flaw of not being able to delete elements directly? Can space marked as deleted be reused?</p> <p>Multiple hashing is a form of open addressing, and all open addressing methods have the drawback of not being able to delete elements directly; they require marking elements as deleted. Marked spaces can be reused. When inserting new elements into the hash table, and the hash function points to a position marked as deleted, that position can be used by the new element. This maintains the probing sequence of the hash table while ensuring efficient use of space.</p> <p>Q: Why do hash collisions occur during the search process in linear probing?</p> <p>During the search process, the hash function points to the corresponding bucket and key-value pair. If the <code>key</code> doesn't match, it indicates a hash collision. Therefore, linear probing will search downwards at a predetermined step size until the correct key-value pair is found or the search fails.</p> <p>Q: Why can resizing a hash table alleviate hash collisions?</p> <p>The last step of a hash function often involves taking the modulo of the array length \\(n\\), to keep the output within the array index range. When resizing, the array length \\(n\\) changes, and the indices corresponding to the keys may also change. Keys that were previously mapped to the same bucket might be distributed across multiple buckets after resizing, thereby mitigating hash collisions.</p>"},{"location":"chapter_heap/","title":"Heap","text":""},{"location":"chapter_heap/#heap","title":"Heap","text":"<p>Abstract</p> <p>Heaps resemble mountains and their jagged peaks, layered and undulating, each with its unique form.</p> <p>Each mountain peak rises and falls in scattered heights, yet the tallest always captures attention first.</p>"},{"location":"chapter_heap/build_heap/","title":"8.2 Building a heap","text":""},{"location":"chapter_heap/build_heap/#heap-construction-operation","title":"Heap construction operation","text":"<p>In some cases, we want to build a heap using all elements of a list, and this process is known as \"heap construction operation.\"</p>"},{"location":"chapter_heap/build_heap/#implementing-with-heap-insertion-operation","title":"Implementing with heap insertion operation","text":"<p>First, we create an empty heap and then iterate through the list, performing the \"heap insertion operation\" on each element in turn. This means adding the element to the end of the heap and then \"heapifying\" it from bottom to top.</p> <p>Each time an element is added to the heap, the length of the heap increases by one. Since nodes are added to the binary tree from top to bottom, the heap is constructed \"from top to bottom.\"</p> <p>Let the number of elements be \\(n\\), and each element's insertion operation takes \\(O(\\log{n})\\) time, thus the time complexity of this heap construction method is \\(O(n \\log n)\\).</p>"},{"location":"chapter_heap/build_heap/#implementing-by-heapifying-through-traversal","title":"Implementing by heapifying through traversal","text":"<p>In fact, we can implement a more efficient method of heap construction in two steps.</p> <ol> <li>Add all elements of the list as they are into the heap, at this point the properties of the heap are not yet satisfied.</li> <li>Traverse the heap in reverse order (reverse of level-order traversal), and perform \"top to bottom heapify\" on each non-leaf node.</li> </ol> <p>After heapifying a node, the subtree with that node as the root becomes a valid sub-heap. Since the traversal is in reverse order, the heap is built \"from bottom to top.\"</p> <p>The reason for choosing reverse traversal is that it ensures the subtree below the current node is already a valid sub-heap, making the heapification of the current node effective.</p> <p>It's worth mentioning that since leaf nodes have no children, they naturally form valid sub-heaps and do not need to be heapified. As shown in the following code, the last non-leaf node is the parent of the last node; we start from it and traverse in reverse order to perform heapification:</p> <pre><code>[file]{my_heap}-[class]{max_heap}-[func]{__init__}\n</code></pre>"},{"location":"chapter_heap/build_heap/#complexity-analysis","title":"Complexity analysis","text":"<p>Next, let's attempt to calculate the time complexity of this second method of heap construction.</p> <ul> <li>Assuming the number of nodes in the complete binary tree is \\(n\\), then the number of leaf nodes is \\((n + 1) / 2\\), where \\(/\\) is integer division. Therefore, the number of nodes that need to be heapified is \\((n - 1) / 2\\).</li> <li>In the process of \"top to bottom heapification,\" each node is heapified to the leaf nodes at most, so the maximum number of iterations is the height of the binary tree \\(\\log n\\).</li> </ul> <p>Multiplying the two, we get the time complexity of the heap construction process as \\(O(n \\log n)\\). But this estimate is not accurate, because it does not take into account the nature of the binary tree having far more nodes at the lower levels than at the top.</p> <p>Let's perform a more accurate calculation. To simplify the calculation, assume a \"perfect binary tree\" with \\(n\\) nodes and height \\(h\\); this assumption does not affect the correctness of the result.</p> <p></p> <p>As shown in the figure above, the maximum number of iterations for a node \"to be heapified from top to bottom\" is equal to the distance from that node to the leaf nodes, which is precisely \"node height.\" Therefore, we can sum the \"number of nodes \\(\\times\\) node height\" at each level, to get the total number of heapification iterations for all nodes.</p> \\[ T(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \\dots + 2^{(h-1)}\\times1 \\] <p>To simplify the above equation, we need to use knowledge of sequences from high school, first multiply \\(T(h)\\) by \\(2\\), to get:</p> \\[ \\begin{aligned} T(h) &amp; = 2^0h + 2^1(h-1) + 2^2(h-2) + \\dots + 2^{h-1}\\times1 \\newline 2T(h) &amp; = 2^1h + 2^2(h-1) + 2^3(h-2) + \\dots + 2^h\\times1 \\newline \\end{aligned} \\] <p>By subtracting \\(T(h)\\) from \\(2T(h)\\) using the method of displacement, we get:</p> \\[ 2T(h) - T(h) = T(h) = -2^0h + 2^1 + 2^2 + \\dots + 2^{h-1} + 2^h \\] <p>Observing the equation, \\(T(h)\\) is an geometric series, which can be directly calculated using the sum formula, resulting in a time complexity of:</p> \\[ \\begin{aligned} T(h) &amp; = 2 \\frac{1 - 2^h}{1 - 2} - h \\newline &amp; = 2^{h+1} - h - 2 \\newline &amp; = O(2^h) \\end{aligned} \\] <p>Further, a perfect binary tree with height \\(h\\) has \\(n = 2^{h+1} - 1\\) nodes, thus the complexity is \\(O(2^h) = O(n)\\). This calculation shows that the time complexity of inputting a list and constructing a heap is \\(O(n)\\), which is very efficient.</p>"},{"location":"chapter_heap/heap/","title":"8.1 Heap","text":""},{"location":"chapter_heap/heap/#heap","title":"Heap","text":"<p>A heap is a complete binary tree that satisfies specific conditions and can be mainly categorized into two types, as shown in the figure below.</p> <ul> <li>min heap: The value of any node \\(\\leq\\) the values of its child nodes.</li> <li>max heap: The value of any node \\(\\geq\\) the values of its child nodes.</li> </ul> <p></p> <p>As a special case of a complete binary tree, a heap has the following characteristics:</p> <ul> <li>The bottom layer nodes are filled from left to right, and nodes in other layers are fully filled.</li> <li>The root node of the binary tree is called the \"top\" of the heap, and the bottom-rightmost node is called the \"bottom\" of the heap.</li> <li>For max heaps (min heaps), the value of the top element (root) is the largest (smallest) among all elements.</li> </ul>"},{"location":"chapter_heap/heap/#common-heap-operations","title":"Common heap operations","text":"<p>It should be noted that many programming languages provide a priority queue, which is an abstract data structure defined as a queue with priority sorting.</p> <p>In practice, heaps are often used to implement priority queues. A max heap corresponds to a priority queue where elements are dequeued in descending order. From a usage perspective, we can consider \"priority queue\" and \"heap\" as equivalent data structures. Therefore, this book does not make a special distinction between the two, uniformly referring to them as \"heap.\"</p> <p>Common operations on heaps are shown in the table below, and the method names may vary based on the programming language.</p> <p> Table  \u00a0 Efficiency of Heap Operations </p> Method name Description Time complexity <code>push()</code> Add an element to the heap \\(O(\\log n)\\) <code>pop()</code> Remove the top element from the heap \\(O(\\log n)\\) <code>peek()</code> Access the top element (for max/min heap, the max/min value) \\(O(1)\\) <code>size()</code> Get the number of elements in the heap \\(O(1)\\) <code>isEmpty()</code> Check if the heap is empty \\(O(1)\\) <p>In practice, we can directly use the heap class (or priority queue class) provided by programming languages.</p> <p>Similar to sorting algorithms where we have \"ascending order\" and \"descending order\", we can switch between \"min heap\" and \"max heap\" by setting a <code>flag</code> or modifying the <code>Comparator</code>. The code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig heap.py<pre><code># Initialize a min heap\nmin_heap, flag = [], 1\n# Initialize a max heap\nmax_heap, flag = [], -1\n\n# Python's heapq module implements a min heap by default\n# By negating the elements before pushing them to the heap, we invert the order and thus implement a max heap\n# In this example, flag = 1 corresponds to a min heap, while flag = -1 corresponds to a max heap\n\n# Push elements into the heap\nheapq.heappush(max_heap, flag * 1)\nheapq.heappush(max_heap, flag * 3)\nheapq.heappush(max_heap, flag * 2)\nheapq.heappush(max_heap, flag * 5)\nheapq.heappush(max_heap, flag * 4)\n\n# Retrieve the top element of the heap\npeek: int = flag * max_heap[0] # 5\n\n# Pop the top element of the heap\n# The popped elements will form a sequence in descending order\nval = flag * heapq.heappop(max_heap) # 5\nval = flag * heapq.heappop(max_heap) # 4\nval = flag * heapq.heappop(max_heap) # 3\nval = flag * heapq.heappop(max_heap) # 2\nval = flag * heapq.heappop(max_heap) # 1\n\n# Get the size of the heap\nsize: int = len(max_heap)\n\n# Check if the heap is empty\nis_empty: bool = not max_heap\n\n# Create a heap from a list\nmin_heap: list[int] = [1, 3, 2, 5, 4]\nheapq.heapify(min_heap)\n</code></pre> heap.cpp<pre><code>/* Initialize a heap */\n// Initialize a min heap\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;\n// Initialize a max heap\npriority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap;\n\n/* Push elements into the heap */\nmaxHeap.push(1);\nmaxHeap.push(3);\nmaxHeap.push(2);\nmaxHeap.push(5);\nmaxHeap.push(4);\n\n/* Retrieve the top element of the heap */\nint peek = maxHeap.top(); // 5\n\n/* Pop the top element of the heap */\n// The popped elements will form a sequence in descending order\nmaxHeap.pop(); // 5\nmaxHeap.pop(); // 4\nmaxHeap.pop(); // 3\nmaxHeap.pop(); // 2\nmaxHeap.pop(); // 1\n\n/* Get the size of the heap */\nint size = maxHeap.size();\n\n/* Check if the heap is empty */\nbool isEmpty = maxHeap.empty();\n\n/* Create a heap from a list */\nvector&lt;int&gt; input{1, 3, 2, 5, 4};\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap(input.begin(), input.end());\n</code></pre> heap.java<pre><code>/* Initialize a heap */\n// Initialize a min heap\nQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();\n// Initialize a max heap (Simply modify the Comparator using a lambda expression\uff09\nQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);\n\n/* Push elements into the heap */\nmaxHeap.offer(1);\nmaxHeap.offer(3);\nmaxHeap.offer(2);\nmaxHeap.offer(5);\nmaxHeap.offer(4);\n\n/* Retrieve the top element of the heap */\nint peek = maxHeap.peek(); // 5\n\n/* Pop the top element of the heap */\n// The popped elements will form a sequence in descending order\npeek = maxHeap.poll(); // 5\npeek = maxHeap.poll(); // 4\npeek = maxHeap.poll(); // 3\npeek = maxHeap.poll(); // 2\npeek = maxHeap.poll(); // 1\n\n/* Get the size of the heap */\nint size = maxHeap.size();\n\n/* Check if the heap is empty */\nboolean isEmpty = maxHeap.isEmpty();\n\n/* Create a heap from a list */\nminHeap = new PriorityQueue&lt;&gt;(Arrays.asList(1, 3, 2, 5, 4));\n</code></pre> heap.cs<pre><code>/* Initialize a heap */\n// Initialize a min heap\nPriorityQueue&lt;int, int&gt; minHeap = new();\n// Initialize a max heap (Simply modify the Comparator using a lambda expression)\nPriorityQueue&lt;int, int&gt; maxHeap = new(Comparer&lt;int&gt;.Create((x, y) =&gt; y - x));\n\n/* Push elements into the heap */\nmaxHeap.Enqueue(1, 1);\nmaxHeap.Enqueue(3, 3);\nmaxHeap.Enqueue(2, 2);\nmaxHeap.Enqueue(5, 5);\nmaxHeap.Enqueue(4, 4);\n\n/* Retrieve the top element of the heap */\nint peek = maxHeap.Peek();//5\n\n/* Pop the top element of the heap */\n// The popped elements will form a sequence in descending order\npeek = maxHeap.Dequeue();  // 5\npeek = maxHeap.Dequeue();  // 4\npeek = maxHeap.Dequeue();  // 3\npeek = maxHeap.Dequeue();  // 2\npeek = maxHeap.Dequeue();  // 1\n\n/* Get the size of the heap */\nint size = maxHeap.Count;\n\n/* Check if the heap is empty */\nbool isEmpty = maxHeap.Count == 0;\n\n/* Create a heap from a list */\nminHeap = new PriorityQueue&lt;int, int&gt;([(1, 1), (3, 3), (2, 2), (5, 5), (4, 4)]);\n</code></pre> heap.go<pre><code>// In Go, we can construct a max heap of integers by implementing heap.Interface\n// Note that implementing heap.Interface requires also implementing sort.Interface\ntype intHeap []any\n\n// Push method of heap.Interface, which pushes an element into the heap\nfunc (h *intHeap) Push(x any) {\n    // Both Push and Pop use a pointer receiver\n    // because they not only adjust the elements of the slice but also change its length\n    *h = append(*h, x.(int))\n}\n\n// Pop method of heap.Interface, which removes the top element of the heap\nfunc (h *intHeap) Pop() any {\n    // The element to pop from the heap is stored at the end\n    last := (*h)[len(*h)-1]\n    *h = (*h)[:len(*h)-1]\n    return last\n}\n\n// Len method of sort.Interface\nfunc (h *intHeap) Len() int {\n    return len(*h)\n}\n\n// Less method of sort.Interface\nfunc (h *intHeap) Less(i, j int) bool {\n    // If you want to implement a min heap, you would change this to a less-than comparison\n    return (*h)[i].(int) &gt; (*h)[j].(int)\n}\n\n// Swap method of sort.Interface\nfunc (h *intHeap) Swap(i, j int) {\n    (*h)[i], (*h)[j] = (*h)[j], (*h)[i]\n}\n\n// Top Retrieve the top element of the heap\nfunc (h *intHeap) Top() any {\n    return (*h)[0]\n}\n\n/* Driver Code */\nfunc TestHeap(t *testing.T) {\n    /* Initialize a heap */\n    // Initialize a max heap\n    maxHeap := &amp;intHeap{}\n    heap.Init(maxHeap)\n    /* Push elements into the heap */\n    // Call the methods of heap.Interface to add elements\n    heap.Push(maxHeap, 1)\n    heap.Push(maxHeap, 3)\n    heap.Push(maxHeap, 2)\n    heap.Push(maxHeap, 4)\n    heap.Push(maxHeap, 5)\n\n    /* Retrieve the top element of the heap */\n    top := maxHeap.Top()\n    fmt.Printf(\"The top element of the heap is %d\\n\", top)\n\n    /* Pop the top element of the heap */\n    // Call the methods of heap.Interface to remove elements\n    heap.Pop(maxHeap) // 5\n    heap.Pop(maxHeap) // 4\n    heap.Pop(maxHeap) // 3\n    heap.Pop(maxHeap) // 2\n    heap.Pop(maxHeap) // 1\n\n    /* Get the size of the heap */\n    size := len(*maxHeap)\n    fmt.Printf(\"The number of elements in the heap is %d\\n\", size)\n\n    /* Check if the heap is empty */\n    isEmpty := len(*maxHeap) == 0\n    fmt.Printf(\"Is the heap empty? %t\\n\", isEmpty)\n}\n</code></pre> heap.swift<pre><code>/* Initialize a heap */\n// Swift\u2019s Heap type supports both max heaps and min heaps, and need the swift-collections library\nvar heap = Heap&lt;Int&gt;()\n\n/* Push elements into the heap */\nheap.insert(1)\nheap.insert(3)\nheap.insert(2)\nheap.insert(5)\nheap.insert(4)\n\n/* Retrieve the top element of the heap */\nvar peek = heap.max()!\n\n/* Pop the top element of the heap */\npeek = heap.removeMax() // 5\npeek = heap.removeMax() // 4\npeek = heap.removeMax() // 3\npeek = heap.removeMax() // 2\npeek = heap.removeMax() // 1\n\n/* Get the size of the heap */\nlet size = heap.count\n\n/* Check if the heap is empty */\nlet isEmpty = heap.isEmpty\n\n/* Create a heap from a list */\nlet heap2 = Heap([1, 3, 2, 5, 4])\n</code></pre> heap.js<pre><code>// JavaScript does not provide a built-in Heap class\n</code></pre> heap.ts<pre><code>// TypeScript does not provide a built-in Heap class\n</code></pre> heap.dart<pre><code>// Dart does not provide a built-in Heap class\n</code></pre> heap.rs<pre><code>use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n/* Initialize a heap */\n// Initialize a min heap\nlet mut min_heap = BinaryHeap::&lt;Reverse&lt;i32&gt;&gt;::new();\n// Initialize a max heap\nlet mut max_heap = BinaryHeap::new();\n\n/* Push elements into the heap */\nmax_heap.push(1);\nmax_heap.push(3);\nmax_heap.push(2);\nmax_heap.push(5);\nmax_heap.push(4);\n\n/* Retrieve the top element of the heap */\nlet peek = max_heap.peek().unwrap();  // 5\n\n/* Pop the top element of the heap */\n// The popped elements will form a sequence in descending order\nlet peek = max_heap.pop().unwrap();   // 5\nlet peek = max_heap.pop().unwrap();   // 4\nlet peek = max_heap.pop().unwrap();   // 3\nlet peek = max_heap.pop().unwrap();   // 2\nlet peek = max_heap.pop().unwrap();   // 1\n\n/* Get the size of the heap */\nlet size = max_heap.len();\n\n/* Check if the heap is empty */\nlet is_empty = max_heap.is_empty();\n\n/* Create a heap from a list */\nlet min_heap = BinaryHeap::from(vec![Reverse(1), Reverse(3), Reverse(2), Reverse(5), Reverse(4)]);\n</code></pre> heap.c<pre><code>// C does not provide a built-in Heap class\n</code></pre> heap.kt<pre><code>/* Initialize a heap */\n// Initialize a min heap\nvar minHeap = PriorityQueue&lt;Int&gt;()\n// Initialize a max heap (Simply modify the Comparator using a lambda expression\uff09\nval maxHeap = PriorityQueue { a: Int, b: Int -&gt; b - a }\n\n/* Push elements into the heap */\nmaxHeap.offer(1)\nmaxHeap.offer(3)\nmaxHeap.offer(2)\nmaxHeap.offer(5)\nmaxHeap.offer(4)\n\n/* Retrieve the top element of the heap */\nvar peek = maxHeap.peek() // 5\n\n/* Pop the top element of the heap */\n// The popped elements will form a sequence in descending order\npeek = maxHeap.poll() // 5\npeek = maxHeap.poll() // 4\npeek = maxHeap.poll() // 3\npeek = maxHeap.poll() // 2\npeek = maxHeap.poll() // 1\n\n/* Get the size of the heap */\nval size = maxHeap.size\n\n/* Check if the heap is empty */\nval isEmpty = maxHeap.isEmpty()\n\n/* Create a heap from a list */\nminHeap = PriorityQueue(mutableListOf(1, 3, 2, 5, 4))\n</code></pre> heap.rb<pre><code>\n</code></pre> heap.zig<pre><code>\n</code></pre> Code visualization <p>https://pythontutor.com/render.html#code=import%20heapq%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B0%8F%E9%A1%B6%E5%A0%86%0A%20%20%20%20min_heap,%20flag%20%3D%20%5B%5D,%201%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E9%A1%B6%E5%A0%86%0A%20%20%20%20max_heap,%20flag%20%3D%20%5B%5D,%20-1%0A%20%20%20%20%0A%20%20%20%20%23%20Python%20%E7%9A%84%20heapq%20%E6%A8%A1%E5%9D%97%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E5%B0%8F%E9%A1%B6%E5%A0%86%0A%20%20%20%20%23%20%E8%80%83%E8%99%91%E5%B0%86%E2%80%9C%E5%85%83%E7%B4%A0%E5%8F%96%E8%B4%9F%E2%80%9D%E5%90%8E%E5%86%8D%E5%85%A5%E5%A0%86%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB%E9%A2%A0%E5%80%92%EF%BC%8C%E4%BB%8E%E8%80%8C%E5%AE%9E%E7%8E%B0%E5%A4%A7%E9%A1%B6%E5%A0%86%0A%20%20%20%20%23%20%E5%9C%A8%E6%9C%AC%E7%A4%BA%E4%BE%8B%E4%B8%AD%EF%BC%8Cflag%20%3D%201%20%E6%97%B6%E5%AF%B9%E5%BA%94%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%8Cflag%20%3D%20-1%20%E6%97%B6%E5%AF%B9%E5%BA%94%E5%A4%A7%E9%A1%B6%E5%A0%86%0A%20%20%20%20%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%85%A5%E5%A0%86%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%201%29%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%203%29%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%202%29%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%205%29%0A%20%20%20%20heapq.heappush%28max_heap,%20flag%20*%204%29%0A%20%20%20%20%0A%20%20%20%20%23%20%E8%8E%B7%E5%8F%96%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%0A%20%20%20%20peek%20%3D%20flag%20*%20max_heap%5B0%5D%20%23%205%0A%20%20%20%20%0A%20%20%20%20%23%20%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%E5%87%BA%E5%A0%86%0A%20%20%20%20%23%20%E5%87%BA%E5%A0%86%E5%85%83%E7%B4%A0%E4%BC%9A%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E4%BB%8E%E5%A4%A7%E5%88%B0%E5%B0%8F%E7%9A%84%E5%BA%8F%E5%88%97%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%205%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%204%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%203%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%202%0A%20%20%20%20val%20%3D%20flag%20*%20heapq.heappop%28max_heap%29%20%23%201%0A%20%20%20%20%0A%20%20%20%20%23%20%E8%8E%B7%E5%8F%96%E5%A0%86%E5%A4%A7%E5%B0%8F%0A%20%20%20%20size%20%3D%20len%28max_heap%29%0A%20%20%20%20%0A%20%20%20%20%23%20%E5%88%A4%E6%96%AD%E5%A0%86%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%0A%20%20%20%20is_empty%20%3D%20not%20max_heap%0A%20%20%20%20%0A%20%20%20%20%23%20%E8%BE%93%E5%85%A5%E5%88%97%E8%A1%A8%E5%B9%B6%E5%BB%BA%E5%A0%86%0A%20%20%20%20min_heap%20%3D%20%5B1,%203,%202,%205,%204%5D%0A%20%20%20%20heapq.heapify%28min_heap%29&amp;cumulative=false&amp;curInstr=3&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_heap/heap/#implementation-of-the-heap","title":"Implementation of the heap","text":"<p>The following implementation is of a max heap. To convert it into a min heap, simply invert all size logic comparisons (for example, replace \\(\\geq\\) with \\(\\leq\\)). Interested readers are encouraged to implement it on their own.</p>"},{"location":"chapter_heap/heap/#heap-storage-and-representation","title":"Heap storage and representation","text":"<p>As mentioned in the \"Binary Trees\" section, complete binary trees are highly suitable for array representation. Since heaps are a type of complete binary tree, we will use arrays to store heaps.</p> <p>When using an array to represent a binary tree, elements represent node values, and indexes represent node positions in the binary tree. Node pointers are implemented through an index mapping formula.</p> <p>As shown in the figure below, given an index \\(i\\), the index of its left child is \\(2i + 1\\), the index of its right child is \\(2i + 2\\), and the index of its parent is \\((i - 1) / 2\\) (floor division). When the index is out of bounds, it signifies a null node or the node does not exist.</p> <p></p> <p>We can encapsulate the index mapping formula into functions for convenient later use:</p> <pre><code>[file]{my_heap}-[class]{max_heap}-[func]{parent}\n</code></pre>"},{"location":"chapter_heap/heap/#accessing-the-top-element-of-the-heap","title":"Accessing the top element of the heap","text":"<p>The top element of the heap is the root node of the binary tree, which is also the first element of the list:</p> <pre><code>[file]{my_heap}-[class]{max_heap}-[func]{peek}\n</code></pre>"},{"location":"chapter_heap/heap/#inserting-an-element-into-the-heap","title":"Inserting an element into the heap","text":"<p>Given an element <code>val</code>, we first add it to the bottom of the heap. After addition, since <code>val</code> may be larger than other elements in the heap, the heap's integrity might be compromised, thus it's necessary to repair the path from the inserted node to the root node. This operation is called heapify.</p> <p>Considering starting from the node inserted, perform heapify from bottom to top. As shown in the figure below, we compare the value of the inserted node with its parent node, and if the inserted node is larger, we swap them. Then continue this operation, repairing each node in the heap from bottom to top until reaching the root or a node that does not need swapping.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Given a total of \\(n\\) nodes, the height of the tree is \\(O(\\log n)\\). Hence, the loop iterations for the heapify operation are at most \\(O(\\log n)\\), making the time complexity of the element insertion operation \\(O(\\log n)\\). The code is as shown:</p> <pre><code>[file]{my_heap}-[class]{max_heap}-[func]{sift_up}\n</code></pre>"},{"location":"chapter_heap/heap/#removing-the-top-element-from-the-heap","title":"Removing the top element from the heap","text":"<p>The top element of the heap is the root node of the binary tree, that is, the first element of the list. If we directly remove the first element from the list, all node indexes in the binary tree will change, making it difficult to use heapify for subsequent repairs. To minimize changes in element indexes, we use the following steps.</p> <ol> <li>Swap the top element with the bottom element of the heap (swap the root node with the rightmost leaf node).</li> <li>After swapping, remove the bottom of the heap from the list (note that since it has been swapped, the original top element is actually being removed).</li> <li>Starting from the root node, perform heapify from top to bottom.</li> </ol> <p>As shown in the figure below, the direction of \"heapify from top to bottom\" is opposite to \"heapify from bottom to top\". We compare the value of the root node with its two children and swap it with the largest child. Then, repeat this operation until reaching the leaf node or encountering a node that does not need swapping.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Similar to the element insertion operation, the time complexity of the top element removal operation is also \\(O(\\log n)\\). The code is as follows:</p> <pre><code>[file]{my_heap}-[class]{max_heap}-[func]{sift_down}\n</code></pre>"},{"location":"chapter_heap/heap/#common-applications-of-heaps","title":"Common applications of heaps","text":"<ul> <li>Priority Queue: Heaps are often the preferred data structure for implementing priority queues, with both enqueue and dequeue operations having a time complexity of \\(O(\\log n)\\), and building a queue having a time complexity of \\(O(n)\\), all of which are very efficient.</li> <li>Heap Sort: Given a set of data, we can create a heap from them and then continually perform element removal operations to obtain ordered data. However, there is a more elegant way to implement heap sort, as explained in the \"Heap Sort\" chapter.</li> <li>Finding the Largest \\(k\\) Elements: This is a classic algorithm problem and also a common use case, such as selecting the top 10 hot news for Weibo hot search, picking the top 10 selling products, etc.</li> </ul>"},{"location":"chapter_heap/summary/","title":"8.4 Summary","text":""},{"location":"chapter_heap/summary/#summary","title":"Summary","text":""},{"location":"chapter_heap/summary/#key-review","title":"Key review","text":"<ul> <li>A heap is a complete binary tree that can be categorized as either a max heap or a min heap based on its building property, where the top element of a max heap is the largest and the top element of a min heap is the smallest.</li> <li>A priority queue is defined as a queue with dequeue priority, usually implemented using a heap.</li> <li>Common operations of a heap and their corresponding time complexities include: element insertion into the heap \\(O(\\log n)\\), removing the top element from the heap \\(O(\\log n)\\), and accessing the top element of the heap \\(O(1)\\).</li> <li>A complete binary tree is well-suited to be represented by an array, thus heaps are commonly stored using arrays.</li> <li>Heapify operations are used to maintain the properties of the heap and are used in both heap insertion and removal operations.</li> <li>The time complexity of building a heap given an input of \\(n\\) elements can be optimized to \\(O(n)\\), which is highly efficient.</li> <li>Top-k is a classic algorithm problem that can be efficiently solved using the heap data structure, with a time complexity of \\(O(n \\log k)\\).</li> </ul>"},{"location":"chapter_heap/summary/#q-a","title":"Q &amp; A","text":"<p>Q: Is the \"heap\" in data structures the same concept as the \"heap\" in memory management?</p> <p>The two are not the same concept, even though they are both referred to as \"heap\". The heap in computer system memory is part of dynamic memory allocation, where the program can use it to store data during execution. The program can request a certain amount of heap memory to store complex structures like objects and arrays. When the allocated data is no longer needed, the program needs to release this memory to prevent memory leaks. Compared to stack memory, the management and usage of heap memory demands more caution, as improper use may lead to memory leaks and dangling pointers.</p>"},{"location":"chapter_heap/top_k/","title":"8.3 Top-k problem","text":""},{"location":"chapter_heap/top_k/#top-k-problem","title":"Top-k problem","text":"<p>Question</p> <p>Given an unordered array <code>nums</code> of length \\(n\\), return the largest \\(k\\) elements in the array.</p> <p>For this problem, we will first introduce two straightforward solutions, then explain a more efficient heap-based method.</p>"},{"location":"chapter_heap/top_k/#method-1-iterative-selection","title":"Method 1: Iterative selection","text":"<p>We can perform \\(k\\) rounds of iterations as shown in the figure below, extracting the \\(1^{st}\\), \\(2^{nd}\\), \\(\\dots\\), \\(k^{th}\\) largest elements in each round, with a time complexity of \\(O(nk)\\).</p> <p>This method is only suitable when \\(k \\ll n\\), as the time complexity approaches \\(O(n^2)\\) when \\(k\\) is close to \\(n\\), which is very time-consuming.</p> <p></p> <p>Tip</p> <p>When \\(k = n\\), we can obtain a complete ordered sequence, which is equivalent to the \"selection sort\" algorithm.</p>"},{"location":"chapter_heap/top_k/#method-2-sorting","title":"Method 2: Sorting","text":"<p>As shown in the figure below, we can first sort the array <code>nums</code> and then return the last \\(k\\) elements, with a time complexity of \\(O(n \\log n)\\).</p> <p>Clearly, this method \"overachieves\" the task, as we only need to find the largest \\(k\\) elements, without the need to sort the other elements.</p> <p></p>"},{"location":"chapter_heap/top_k/#method-3-heap","title":"Method 3: Heap","text":"<p>We can solve the Top-k problem more efficiently based on heaps, as shown in the following process.</p> <ol> <li>Initialize a min heap, where the top element is the smallest.</li> <li>First, insert the first \\(k\\) elements of the array into the heap.</li> <li>Starting from the \\(k + 1^{th}\\) element, if the current element is greater than the top element of the heap, remove the top element of the heap and insert the current element into the heap.</li> <li>After completing the traversal, the heap contains the largest \\(k\\) elements.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Example code is as follows:</p> <pre><code>[file]{top_k}-[class]{}-[func]{top_k_heap}\n</code></pre> <p>A total of \\(n\\) rounds of heap insertions and deletions are performed, with the maximum heap size being \\(k\\), hence the time complexity is \\(O(n \\log k)\\). This method is very efficient; when \\(k\\) is small, the time complexity tends towards \\(O(n)\\); when \\(k\\) is large, the time complexity will not exceed \\(O(n \\log n)\\).</p> <p>Additionally, this method is suitable for scenarios with dynamic data streams. By continuously adding data, we can maintain the elements within the heap, thereby achieving dynamic updates of the largest \\(k\\) elements.</p>"},{"location":"chapter_hello_algo/","title":"Tr\u01b0\u1edbc khi b\u1eaft \u0111\u1ea7u","text":""},{"location":"chapter_hello_algo/#truoc-khi-bat-au","title":"Tr\u01b0\u1edbc khi b\u1eaft \u0111\u1ea7u","text":"<p>V\u00e0i n\u0103m tr\u01b0\u1edbc, m\u00ecnh \u0111\u00e3 chia s\u1ebb c\u00e1c l\u1eddi gi\u1ea3i cho b\u1ed9 \u0111\u1ec1 \"Sword for Offer\" tr\u00ean LeetCode v\u00e0 nh\u1eadn \u0111\u01b0\u1ee3c nhi\u1ec1u s\u1ef1 \u0111\u1ed9ng vi\u00ean, \u1ee7ng h\u1ed9 t\u1eeb c\u00e1c b\u1ea1n \u0111\u1ecdc. Trong qu\u00e1 tr\u00ecnh trao \u0111\u1ed5i v\u1edbi m\u1ecdi ng\u01b0\u1eddi, c\u00e2u h\u1ecfi m\u00ecnh g\u1eb7p nhi\u1ec1u nh\u1ea5t l\u00e0 \"l\u00e0m sao \u0111\u1ec3 b\u1eaft \u0111\u1ea7u h\u1ecdc thu\u1eadt to\u00e1n\". D\u1ea7n d\u1ea7n, m\u00ecnh tr\u1edf n\u00ean r\u1ea5t quan t\u00e2m \u0111\u1ebfn c\u00e2u h\u1ecfi n\u00e0y.</p> <p>Gi\u1ea3i b\u00e0i t\u1eadp tr\u1ef1c ti\u1ebfp c\u00f3 l\u1ebd l\u00e0 c\u00e1ch ph\u1ed5 bi\u1ebfn nh\u1ea5t \u2014 \u0111\u01a1n gi\u1ea3n, tr\u1ef1c ti\u1ebfp v\u00e0 hi\u1ec7u qu\u1ea3. Tuy nhi\u00ean, vi\u1ec7c gi\u1ea3i b\u00e0i gi\u1ed1ng nh\u01b0 ch\u01a1i tr\u00f2 d\u00f2 m\u00ecn: ai c\u00f3 kh\u1ea3 n\u0103ng t\u1ef1 h\u1ecdc t\u1ed1t s\u1ebd v\u01b0\u1ee3t qua t\u1eebng \"b\u00e3i m\u00ecn\", c\u00f2n nh\u1eefng b\u1ea1n ch\u01b0a c\u00f3 n\u1ec1n t\u1ea3ng v\u1eefng ch\u1eafc s\u1ebd d\u1ec5 v\u1ea5p ng\u00e3 v\u00e0 n\u1ea3n l\u00f2ng. \u0110\u1ecdc s\u00e1ch gi\u00e1o khoa c\u0169ng l\u00e0 m\u1ed9t c\u00e1ch th\u01b0\u1eddng g\u1eb7p, nh\u01b0ng v\u1edbi c\u00e1c b\u1ea1n \u0111ang t\u00ecm vi\u1ec7c, l\u00e0m lu\u1eadn v\u0103n, n\u1ed9p CV, chu\u1ea9n b\u1ecb thi tuy\u1ec3n hay ph\u1ecfng v\u1ea5n th\u00ec \u0111\u00e3 t\u1ed1n r\u1ea5t nhi\u1ec1u th\u1eddi gian, n\u00ean vi\u1ec7c \u0111\u1ecdc nh\u1eefng cu\u1ed1n s\u00e1ch d\u00e0y c\u1ed9p tr\u1edf th\u00e0nh th\u1eed th\u00e1ch l\u1edbn.</p> <p>N\u1ebfu b\u1ea1n c\u0169ng \u0111ang g\u1eb7p kh\u00f3 kh\u0103n nh\u01b0 v\u1eady, th\u00ec cu\u1ed1n s\u00e1ch n\u00e0y th\u1eadt may m\u1eafn khi \u0111\u01b0\u1ee3c b\u1ea1n t\u00ecm th\u1ea5y. \u0110\u00e2y l\u00e0 c\u00e2u tr\u1ea3 l\u1eddi c\u1ee7a m\u00ecnh cho c\u00e2u h\u1ecfi tr\u00ean. D\u00f9 ch\u01b0a ch\u1eafc l\u00e0 gi\u1ea3i ph\u00e1p t\u1ed1t nh\u1ea5t, nh\u01b0ng \u00edt nh\u1ea5t n\u00f3 l\u00e0 m\u1ed9t n\u1ed7 l\u1ef1c t\u00edch c\u1ef1c. Cu\u1ed1n s\u00e1ch n\u00e0y kh\u00f4ng gi\u00fap b\u1ea1n nh\u1eadn \u0111\u01b0\u1ee3c offer ngay l\u1eadp t\u1ee9c, nh\u01b0ng s\u1ebd d\u1eabn d\u1eaft b\u1ea1n kh\u00e1m ph\u00e1 \"b\u1ea3n \u0111\u1ed3 tri th\u1ee9c\" v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n, gi\u00fap b\u1ea1n hi\u1ec3u \u0111\u01b0\u1ee3c h\u00ecnh d\u1ea1ng, v\u1ecb tr\u00ed c\u1ee7a c\u00e1c \"b\u00e3i m\u00ecn\" kh\u00e1c nhau, v\u00e0 n\u1eafm \u0111\u01b0\u1ee3c nhi\u1ec1u \"c\u00e1ch d\u00f2 m\u00ecn\". V\u1edbi nh\u1eefng k\u1ef9 n\u0103ng n\u00e0y, m\u00ecnh tin b\u1ea1n s\u1ebd gi\u1ea3i b\u00e0i v\u00e0 \u0111\u1ecdc t\u00e0i li\u1ec7u d\u1ec5 d\u00e0ng h\u01a1n, d\u1ea7n x\u00e2y d\u1ef1ng \u0111\u01b0\u1ee3c h\u1ec7 th\u1ed1ng ki\u1ebfn th\u1ee9c cho ri\u00eang m\u00ecnh.</p> <p>M\u00ecnh r\u1ea5t \u0111\u1ed3ng t\u00ecnh v\u1edbi c\u00e2u n\u00f3i c\u1ee7a gi\u00e1o s\u01b0 Feynman: \"Ki\u1ebfn th\u1ee9c kh\u00f4ng mi\u1ec5n ph\u00ed. B\u1ea1n ph\u1ea3i ch\u00fa \u00fd \u0111\u1ec3 c\u00f3 \u0111\u01b0\u1ee3c n\u00f3.\" Theo ngh\u0129a n\u00e0y, cu\u1ed1n s\u00e1ch n\u00e0y c\u0169ng kh\u00f4ng ho\u00e0n to\u00e0n \"mi\u1ec5n ph\u00ed\". \u0110\u1ec3 x\u1ee9ng \u0111\u00e1ng v\u1edbi s\u1ef1 \"ch\u00fa \u00fd\" qu\u00fd gi\u00e1 c\u1ee7a b\u1ea1n d\u00e0nh cho cu\u1ed1n s\u00e1ch, m\u00ecnh s\u1ebd c\u1ed1 g\u1eafng h\u1ebft s\u1ee9c v\u00e0 d\u00e0nh tr\u1ecdn s\u1ef1 \"ch\u00fa \u00fd\" c\u1ee7a m\u00ecnh \u0111\u1ec3 vi\u1ebft s\u00e1ch.</p> <p>M\u00ecnh hi\u1ec3u r\u1eb1ng b\u1ea3n th\u00e2n c\u00f2n nhi\u1ec1u h\u1ea1n ch\u1ebf, d\u00f9 n\u1ed9i dung s\u00e1ch \u0111\u00e3 \u0111\u01b0\u1ee3c ch\u1ec9nh s\u1eeda nhi\u1ec1u l\u1ea7n nh\u01b0ng ch\u1eafc ch\u1eafn v\u1eabn c\u00f2n sai s\u00f3t. M\u00ecnh r\u1ea5t mong nh\u1eadn \u0111\u01b0\u1ee3c g\u00f3p \u00fd, ch\u1ec9nh s\u1eeda t\u1eeb c\u00e1c th\u1ea7y c\u00f4 v\u00e0 c\u00e1c b\u1ea1n.</p> <p></p> Hello, Algo! <p>S\u1ef1 ra \u0111\u1eddi c\u1ee7a m\u00e1y t\u00ednh \u0111\u00e3 l\u00e0m thay \u0111\u1ed5i th\u1ebf gi\u1edbi. Nh\u1edd kh\u1ea3 n\u0103ng t\u00ednh to\u00e1n nhanh v\u00e0 d\u1ec5 l\u1eadp tr\u00ecnh, m\u00e1y t\u00ednh tr\u1edf th\u00e0nh c\u00f4ng c\u1ee5 l\u00fd t\u01b0\u1edfng \u0111\u1ec3 th\u1ef1c hi\u1ec7n thu\u1eadt to\u00e1n v\u00e0 x\u1eed l\u00fd d\u1eef li\u1ec7u. T\u1eeb \u0111\u1ed3 h\u1ecda s\u1ed1ng \u0111\u1ed9ng trong game, quy\u1ebft \u0111\u1ecbnh th\u00f4ng minh c\u1ee7a xe t\u1ef1 l\u00e1i, nh\u1eefng v\u00e1n c\u1edd xu\u1ea5t s\u1eafc c\u1ee7a AlphaGo, \u0111\u1ebfn s\u1ef1 t\u01b0\u01a1ng t\u00e1c t\u1ef1 nhi\u00ean c\u1ee7a ChatGPT \u2014 t\u1ea5t c\u1ea3 \u0111\u1ec1u l\u00e0 v\u00ed d\u1ee5 tuy\u1ec7t v\u1eddi v\u1ec1 thu\u1eadt to\u00e1n ho\u1ea1t \u0111\u1ed9ng tr\u00ean m\u00e1y t\u00ednh.</p> <p>Th\u1ef1c ra, tr\u01b0\u1edbc khi c\u00f3 m\u00e1y t\u00ednh, thu\u1eadt to\u00e1n v\u00e0 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u \u0111\u00e3 xu\u1ea5t hi\u1ec7n \u1edf kh\u1eafp n\u01a1i trong cu\u1ed9c s\u1ed1ng. Nh\u1eefng thu\u1eadt to\u00e1n \u0111\u1ea7u ti\u00ean kh\u00e1 \u0111\u01a1n gi\u1ea3n, nh\u01b0 c\u00e1ch \u0111\u1ebfm s\u1ed1 c\u1ed5 x\u01b0a hay quy tr\u00ecnh l\u00e0m c\u00f4ng c\u1ee5. Khi x\u00e3 h\u1ed9i ph\u00e1t tri\u1ec3n, thu\u1eadt to\u00e1n ng\u00e0y c\u00e0ng tinh vi v\u00e0 ph\u1ee9c t\u1ea1p h\u01a1n. T\u1eeb tay ngh\u1ec1 th\u1ee7 c\u00f4ng tinh x\u1ea3o, s\u1ea3n ph\u1ea9m c\u00f4ng nghi\u1ec7p gi\u00fap t\u0103ng n\u0103ng su\u1ea5t, \u0111\u1ebfn c\u00e1c quy lu\u1eadt khoa h\u1ecdc gi\u1ea3i th\u00edch v\u0169 tr\u1ee5 \u2014 h\u1ea7u nh\u01b0 m\u1ecdi \u0111i\u1ec1u b\u00ecnh th\u01b0\u1eddng hay k\u1ef3 di\u1ec7u \u0111\u1ec1u c\u00f3 s\u1ef1 s\u00e1ng t\u1ea1o c\u1ee7a thu\u1eadt to\u00e1n ph\u00eda sau.</p> <p>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u c\u0169ng hi\u1ec7n di\u1ec7n kh\u1eafp n\u01a1i: t\u1eeb m\u1ea1ng x\u00e3 h\u1ed9i \u0111\u1ebfn tuy\u1ebfn t\u00e0u \u0111i\u1ec7n ng\u1ea7m, nhi\u1ec1u h\u1ec7 th\u1ed1ng c\u00f3 th\u1ec3 m\u00f4 ph\u1ecfng b\u1eb1ng \"\u0111\u1ed3 th\u1ecb\"; t\u1eeb qu\u1ed1c gia \u0111\u1ebfn gia \u0111\u00ecnh, c\u00e1c t\u1ed5 ch\u1ee9c x\u00e3 h\u1ed9i th\u01b0\u1eddng c\u00f3 d\u1ea1ng \"c\u00e2y\"; qu\u1ea7n \u00e1o m\u00f9a \u0111\u00f4ng gi\u1ed1ng nh\u01b0 m\u1ed9t \"ng\u0103n x\u1ebfp\", m\u00f3n m\u1eb7c v\u00e0o tr\u01b0\u1edbc s\u1ebd c\u1edfi ra sau; \u1ed1ng c\u1ea7u l\u00f4ng gi\u1ed1ng nh\u01b0 m\u1ed9t \"h\u00e0ng \u0111\u1ee3i\", m\u1ed9t \u0111\u1ea7u \u0111\u1ec3 cho v\u00e0o, \u0111\u1ea7u kia \u0111\u1ec3 l\u1ea5y ra; t\u1eeb \u0111i\u1ec3n gi\u1ed1ng nh\u01b0 \"b\u1ea3ng b\u0103m\", gi\u00fap tra c\u1ee9u nhanh m\u1ee5c ti\u00eau.</p> <p>Cu\u1ed1n s\u00e1ch n\u00e0y gi\u00fap b\u1ea1n hi\u1ec3u c\u00e1c kh\u00e1i ni\u1ec7m c\u1ed1t l\u00f5i v\u1ec1 thu\u1eadt to\u00e1n v\u00e0 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u qua h\u00ecnh minh h\u1ecda sinh \u0111\u1ed9ng, d\u1ec5 hi\u1ec3u v\u00e0 c\u00e1c v\u00ed d\u1ee5 m\u00e3 ngu\u1ed3n c\u00f3 th\u1ec3 ch\u1ea1y \u0111\u01b0\u1ee3c, \u0111\u1ed3ng th\u1eddi h\u01b0\u1edbng d\u1eabn b\u1ea1n t\u1ef1 l\u1eadp tr\u00ecnh \u0111\u1ec3 th\u1ef1c hi\u1ec7n ch\u00fang. Tr\u00ean c\u01a1 s\u1edf \u0111\u00f3, s\u00e1ch c\u00f2n c\u1ed1 g\u1eafng ch\u1ec9 ra nh\u1eefng bi\u1ec3u hi\u1ec7n s\u1ed1ng \u0111\u1ed9ng c\u1ee7a thu\u1eadt to\u00e1n trong th\u1ebf gi\u1edbi ph\u1ee9c t\u1ea1p, \u0111\u1ec3 b\u1ea1n c\u1ea3m nh\u1eadn \u0111\u01b0\u1ee3c v\u1ebb \u0111\u1eb9p c\u1ee7a thu\u1eadt to\u00e1n. M\u00ecnh hy v\u1ecdng cu\u1ed1n s\u00e1ch n\u00e0y s\u1ebd gi\u00fap \u00edch cho b\u1ea1n!</p>"},{"location":"chapter_introduction/","title":"G\u1eb7p g\u1ee1 thu\u1eadt to\u00e1n","text":""},{"location":"chapter_introduction/#gap-go-thuat-toan","title":"G\u1eb7p g\u1ee1 thu\u1eadt to\u00e1n","text":"<p>Abstract</p> <p>M\u1ed9t thi\u1ebfu n\u1eef duy\u00ean d\u00e1ng nh\u1ea3y m\u00faa, \u0111an xen v\u1edbi d\u1eef li\u1ec7u, v\u00e1y c\u1ee7a c\u00f4 \u1ea5y lay \u0111\u1ed9ng theo giai \u0111i\u1ec7u c\u1ee7a thu\u1eadt to\u00e1n.</p> <p>C\u00f4 \u1ea5y m\u1eddi b\u1ea1n nh\u1ea3y m\u00faa, h\u00e3y theo b\u01b0\u1edbc ch\u00e2n c\u1ee7a c\u00f4 \u1ea5y, v\u00e0 b\u01b0\u1edbc v\u00e0o th\u1ebf gi\u1edbi thu\u1eadt to\u00e1n \u0111\u1ea7y logic v\u00e0 v\u1ebb \u0111\u1eb9p.</p>"},{"location":"chapter_introduction/algorithms_are_everywhere/","title":"1.1 Algorithms are everywhere","text":""},{"location":"chapter_introduction/algorithms_are_everywhere/#thuat-toan-o-khap-moi-noi","title":"Thu\u1eadt to\u00e1n \u1edf kh\u1eafp m\u1ecdi n\u01a1i","text":"<p>Khi nghe \u0111\u1ebfn thu\u1eadt ng\u1eef \"thu\u1eadt to\u00e1n\", ch\u00fang ta th\u01b0\u1eddng ngh\u0129 ngay \u0111\u1ebfn to\u00e1n h\u1ecdc. Tuy nhi\u00ean, nhi\u1ec1u thu\u1eadt to\u00e1n kh\u00f4ng li\u00ean quan \u0111\u1ebfn to\u00e1n h\u1ecdc ph\u1ee9c t\u1ea1p m\u00e0 d\u1ef1a nhi\u1ec1u h\u01a1n v\u00e0o logic c\u01a1 b\u1ea3n, \u0111i\u1ec1u n\u00e0y c\u00f3 th\u1ec3 th\u1ea5y \u1edf kh\u1eafp n\u01a1i trong cu\u1ed9c s\u1ed1ng h\u00e0ng ng\u00e0y c\u1ee7a ch\u00fang ta.</p> <p>Tr\u01b0\u1edbc khi b\u1eaft \u0111\u1ea7u th\u1ea3o lu\u1eadn ch\u00ednh th\u1ee9c v\u1ec1 thu\u1eadt to\u00e1n, c\u00f3 m\u1ed9t s\u1ef1 th\u1eadt th\u00fa v\u1ecb \u0111\u00e1ng chia s\u1ebb: b\u1ea1n \u0111\u00e3 v\u00f4 th\u1ee9c h\u1ecdc \u0111\u01b0\u1ee3c nhi\u1ec1u thu\u1eadt to\u00e1n v\u00e0 quen v\u1edbi vi\u1ec7c \u00e1p d\u1ee5ng ch\u00fang trong cu\u1ed9c s\u1ed1ng h\u00e0ng ng\u00e0y. \u1ede \u0111\u00e2y, t\u00f4i s\u1ebd \u0111\u01b0a ra m\u1ed9t v\u00e0i v\u00ed d\u1ee5 c\u1ee5 th\u1ec3 \u0111\u1ec3 ch\u1ee9ng minh \u0111i\u1ec1u n\u00e0y.</p> <p>V\u00ed d\u1ee5 1: Tra t\u1eeb \u0111i\u1ec3n. Trong m\u1ed9t cu\u1ed1n t\u1eeb \u0111i\u1ec3n ti\u1ebfng Anh, c\u00e1c t\u1eeb \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp theo th\u1ee9 t\u1ef1 b\u1ea3ng ch\u1eef c\u00e1i. Gi\u1ea3 s\u1eed ch\u00fang ta \u0111ang t\u00ecm m\u1ed9t t\u1eeb b\u1eaft \u0111\u1ea7u b\u1eb1ng ch\u1eef \\(r\\), th\u00f4ng th\u01b0\u1eddng s\u1ebd l\u00e0m nh\u01b0 sau:</p> <ol> <li>M\u1edf t\u1eeb \u0111i\u1ec3n \u1edf kho\u1ea3ng gi\u1eefa v\u00e0 ki\u1ec3m tra t\u1eeb \u0111\u1ea7u ti\u00ean c\u1ee7a trang, gi\u1ea3 s\u1eed t\u1eeb \u0111\u00f3 b\u1eaft \u0111\u1ea7u b\u1eb1ng ch\u1eef \\(m\\).</li> <li>V\u00ec \\(r\\) \u0111\u1ee9ng sau \\(m\\) trong b\u1ea3ng ch\u1eef c\u00e1i, n\u00ean c\u00f3 th\u1ec3 b\u1ecf qua n\u1eeda \u0111\u1ea7u v\u00e0 thu h\u1eb9p ph\u1ea1m vi t\u00ecm ki\u1ebfm xu\u1ed1ng n\u1eeda sau.</li> <li>L\u1eb7p l\u1ea1i b\u01b0\u1edbc <code>1.</code> v\u00e0 <code>2.</code> cho \u0111\u1ebfn khi t\u00ecm \u0111\u01b0\u1ee3c trang c\u00f3 t\u1eeb b\u1eaft \u0111\u1ea7u b\u1eb1ng \\(r\\).</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p>Vi\u1ec7c tra t\u1eeb \u0111i\u1ec3n, m\u1ed9t k\u1ef9 n\u0103ng thi\u1ebft y\u1ebfu cho h\u1ecdc sinh ti\u1ec3u h\u1ecdc, th\u1ef1c ch\u1ea5t ch\u00ednh l\u00e0 thu\u1eadt to\u00e1n n\u1ed5i ti\u1ebfng \"T\u00ecm ki\u1ebfm nh\u1ecb ph\u00e2n\". X\u00e9t v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u, ch\u00fang ta c\u00f3 th\u1ec3 coi t\u1eeb \u0111i\u1ec3n nh\u01b0 m\u1ed9t \"m\u1ea3ng\" \u0111\u00e3 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp; x\u00e9t v\u1ec1 thu\u1eadt to\u00e1n, chu\u1ed7i h\u00e0nh \u0111\u1ed9ng \u0111\u1ec3 t\u00ecm m\u1ed9t t\u1eeb trong t\u1eeb \u0111i\u1ec3n ch\u00ednh l\u00e0 thu\u1eadt to\u00e1n \"T\u00ecm ki\u1ebfm nh\u1ecb ph\u00e2n\".</p> <p>V\u00ed d\u1ee5 2: S\u1eafp x\u1ebfp b\u1ed9 b\u00e0i. Khi ch\u01a1i b\u00e0i, ch\u00fang ta c\u1ea7n s\u1eafp x\u1ebfp c\u00e1c l\u00e1 b\u00e0i tr\u00ean tay theo th\u1ee9 t\u1ef1 t\u0103ng d\u1ea7n, qu\u00e1 tr\u00ecnh n\u00e0y nh\u01b0 sau:</p> <ol> <li>Chia b\u1ed9 b\u00e0i th\u00e0nh hai ph\u1ea7n \"\u0111\u00e3 s\u1eafp x\u1ebfp\" v\u00e0 \"ch\u01b0a s\u1eafp x\u1ebfp\", gi\u1ea3 s\u1eed ban \u0111\u1ea7u l\u00e1 b\u00e0i ngo\u00e0i c\u00f9ng b\u00ean tr\u00e1i \u0111\u00e3 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp.</li> <li>L\u1ea5y m\u1ed9t l\u00e1 b\u00e0i t\u1eeb ph\u1ea7n ch\u01b0a s\u1eafp x\u1ebfp v\u00e0 ch\u00e8n v\u00e0o v\u1ecb tr\u00ed th\u00edch h\u1ee3p trong ph\u1ea7n \u0111\u00e3 s\u1eafp x\u1ebfp; sau \u0111\u00f3, hai l\u00e1 ngo\u00e0i c\u00f9ng b\u00ean tr\u00e1i \u0111\u00e3 \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp.</li> <li>L\u1eb7p l\u1ea1i b\u01b0\u1edbc <code>2</code> cho \u0111\u1ebfn khi t\u1ea5t c\u1ea3 c\u00e1c l\u00e1 b\u00e0i \u0111\u1ec1u \u0111\u01b0\u1ee3c s\u1eafp x\u1ebfp.</li> </ol> <p></p> <p>C\u00e1ch s\u1eafp x\u1ebfp b\u00e0i \u1edf tr\u00ean th\u1ef1c ch\u1ea5t l\u00e0 thu\u1eadt to\u00e1n \"S\u1eafp x\u1ebfp ch\u00e8n\" (Insertion Sort), r\u1ea5t hi\u1ec7u qu\u1ea3 v\u1edbi c\u00e1c b\u1ed9 d\u1eef li\u1ec7u nh\u1ecf. Nhi\u1ec1u h\u00e0m s\u1eafp x\u1ebfp trong c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh c\u0169ng s\u1eed d\u1ee5ng thu\u1eadt to\u00e1n s\u1eafp x\u1ebfp ch\u00e8n.</p> <p>V\u00ed d\u1ee5 3: Tr\u1ea3 ti\u1ec1n th\u1eeba. Gi\u1ea3 s\u1eed b\u1ea1n mua h\u00e0ng h\u1ebft \\(69\\) t\u1ea1i si\u00eau th\u1ecb. N\u1ebfu b\u1ea1n \u0111\u01b0a cho thu ng\u00e2n \\(100\\), h\u1ecd s\u1ebd ph\u1ea3i tr\u1ea3 l\u1ea1i b\u1ea1n \\(31\\). Qu\u00e1 tr\u00ecnh n\u00e0y c\u00f3 th\u1ec3 hi\u1ec3u r\u00f5 qua h\u00ecnh minh h\u1ecda d\u01b0\u1edbi \u0111\u00e2y.</p> <ol> <li>C\u00e1c l\u1ef1a ch\u1ecdn l\u00e0 c\u00e1c m\u1ec7nh gi\u00e1 nh\u1ecf h\u01a1n \\(31\\), g\u1ed3m \\(1\\), \\(5\\), \\(10\\), v\u00e0 \\(20\\).</li> <li>L\u1ea5y t\u1edd \\(20\\) l\u1edbn nh\u1ea5t trong c\u00e1c l\u1ef1a ch\u1ecdn, c\u00f2n l\u1ea1i \\(31 - 20 = 11\\).</li> <li>L\u1ea5y t\u1edd \\(10\\) l\u1edbn nh\u1ea5t trong c\u00e1c l\u1ef1a ch\u1ecdn c\u00f2n l\u1ea1i, c\u00f2n l\u1ea1i \\(11 - 10 = 1\\).</li> <li>L\u1ea5y t\u1edd \\(1\\) l\u1edbn nh\u1ea5t trong c\u00e1c l\u1ef1a ch\u1ecdn c\u00f2n l\u1ea1i, c\u00f2n l\u1ea1i \\(1 - 1 = 0\\).</li> <li>Ho\u00e0n th\u00e0nh vi\u1ec7c tr\u1ea3 ti\u1ec1n th\u1eeba, k\u1ebft qu\u1ea3 l\u00e0 \\(20 + 10 + 1 = 31\\).</li> </ol> <p></p> <p>Trong c\u00e1c b\u01b0\u1edbc tr\u00ean, ch\u00fang ta lu\u00f4n ch\u1ecdn ph\u01b0\u01a1ng \u00e1n t\u1ed1t nh\u1ea5t \u1edf m\u1ed7i b\u01b0\u1edbc b\u1eb1ng c\u00e1ch l\u1ea5y m\u1ec7nh gi\u00e1 l\u1edbn nh\u1ea5t c\u00f2n l\u1ea1i, gi\u00fap vi\u1ec7c tr\u1ea3 ti\u1ec1n th\u1eeba hi\u1ec7u qu\u1ea3. X\u00e9t v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n, c\u00e1ch l\u00e0m n\u00e0y \u0111\u01b0\u1ee3c g\u1ecdi l\u00e0 thu\u1eadt to\u00e1n \"Tham lam\" (Greedy).</p> <p>T\u1eeb n\u1ea5u \u0103n cho \u0111\u1ebfn du h\u00e0nh v\u0169 tr\u1ee5, h\u1ea7u nh\u01b0 m\u1ecdi v\u1ea5n \u0111\u1ec1 c\u1ea7n gi\u1ea3i quy\u1ebft \u0111\u1ec1u li\u00ean quan \u0111\u1ebfn thu\u1eadt to\u00e1n. S\u1ef1 ra \u0111\u1eddi c\u1ee7a m\u00e1y t\u00ednh cho ph\u00e9p ch\u00fang ta l\u01b0u tr\u1eef c\u1ea5u tr\u00fac d\u1eef li\u1ec7u trong b\u1ed9 nh\u1edb v\u00e0 vi\u1ebft m\u00e3 \u0111\u1ec3 g\u1ecdi CPU, GPU th\u1ef1c thi c\u00e1c thu\u1eadt to\u00e1n. Nh\u1edd v\u1eady, ch\u00fang ta c\u00f3 th\u1ec3 chuy\u1ec3n c\u00e1c v\u1ea5n \u0111\u1ec1 th\u1ef1c t\u1ebf v\u00e0o m\u00e1y t\u00ednh v\u00e0 gi\u1ea3i quy\u1ebft nhi\u1ec1u v\u1ea5n \u0111\u1ec1 ph\u1ee9c t\u1ea1p m\u1ed9t c\u00e1ch hi\u1ec7u qu\u1ea3 h\u01a1n.</p> <p>Tip</p> <p>N\u1ebfu b\u1ea1n v\u1eabn c\u00f2n b\u1ed1i r\u1ed1i v\u1ec1 c\u00e1c kh\u00e1i ni\u1ec7m nh\u01b0 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u, thu\u1eadt to\u00e1n, m\u1ea3ng, hay t\u00ecm ki\u1ebfm nh\u1ecb ph\u00e2n, h\u00e3y ti\u1ebfp t\u1ee5c \u0111\u1ecdc. Cu\u1ed1n s\u00e1ch n\u00e0y s\u1ebd nh\u1eb9 nh\u00e0ng d\u1eabn d\u1eaft b\u1ea1n v\u00e0o th\u1ebf gi\u1edbi c\u1ee7a c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n.</p>"},{"location":"chapter_introduction/summary/","title":"1.3 Summary","text":""},{"location":"chapter_introduction/summary/#tom-tat","title":"T\u00f3m t\u1eaft","text":"<ul> <li>Thu\u1eadt to\u00e1n xu\u1ea5t hi\u1ec7n \u1edf kh\u1eafp n\u01a1i trong cu\u1ed9c s\u1ed1ng h\u00e0ng ng\u00e0y v\u00e0 kh\u00f4ng h\u1ec1 kh\u00f3 ti\u1ebfp c\u1eadn hay ph\u1ee9c t\u1ea1p nh\u01b0 ch\u00fang ta ngh\u0129. Th\u1ef1c t\u1ebf, ch\u00fang ta \u0111\u00e3 v\u00f4 th\u1ee9c h\u1ecdc \u0111\u01b0\u1ee3c nhi\u1ec1u thu\u1eadt to\u00e1n \u0111\u1ec3 gi\u1ea3i quy\u1ebft c\u00e1c v\u1ea5n \u0111\u1ec1 kh\u00e1c nhau trong cu\u1ed9c s\u1ed1ng.</li> <li>Nguy\u00ean t\u1eafc tra c\u1ee9u m\u1ed9t t\u1eeb trong t\u1eeb \u0111i\u1ec3n gi\u1ed1ng v\u1edbi thu\u1eadt to\u00e1n t\u00ecm ki\u1ebfm nh\u1ecb ph\u00e2n. Thu\u1eadt to\u00e1n t\u00ecm ki\u1ebfm nh\u1ecb ph\u00e2n th\u1ec3 hi\u1ec7n \u00fd t\u01b0\u1edfng quan tr\u1ecdng c\u1ee7a thu\u1eadt to\u00e1n l\u00e0 chia \u0111\u1ec3 tr\u1ecb.</li> <li>Qu\u00e1 tr\u00ecnh s\u1eafp x\u1ebfp c\u00e1c l\u00e1 b\u00e0i gi\u1ed1ng v\u1edbi thu\u1eadt to\u00e1n s\u1eafp x\u1ebfp ch\u00e8n. Thu\u1eadt to\u00e1n s\u1eafp x\u1ebfp ch\u00e8n ph\u00f9 h\u1ee3p \u0111\u1ec3 s\u1eafp x\u1ebfp c\u00e1c b\u1ed9 d\u1eef li\u1ec7u nh\u1ecf.</li> <li>C\u00e1c b\u01b0\u1edbc \u0111\u1ed5i ti\u1ec1n l\u1ebb th\u1ef1c ch\u1ea5t tu\u00e2n theo thu\u1eadt to\u00e1n tham lam, m\u1ed7i b\u01b0\u1edbc \u0111\u1ec1u ch\u1ecdn ph\u01b0\u01a1ng \u00e1n t\u1ed1t nh\u1ea5t t\u1ea1i th\u1eddi \u0111i\u1ec3m \u0111\u00f3.</li> <li>Thu\u1eadt to\u00e1n l\u00e0 t\u1eadp h\u1ee3p c\u00e1c b\u01b0\u1edbc h\u01b0\u1edbng d\u1eabn c\u1ee5 th\u1ec3 \u0111\u1ec3 gi\u1ea3i quy\u1ebft m\u1ed9t v\u1ea5n \u0111\u1ec1 trong th\u1eddi gian h\u1eefu h\u1ea1n, c\u00f2n c\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u00e0 c\u00e1ch t\u1ed5 ch\u1ee9c v\u00e0 l\u01b0u tr\u1eef d\u1eef li\u1ec7u trong m\u00e1y t\u00ednh.</li> <li>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n c\u00f3 m\u1ed1i li\u00ean h\u1ec7 ch\u1eb7t ch\u1ebd. C\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u00e0 n\u1ec1n t\u1ea3ng c\u1ee7a thu\u1eadt to\u00e1n, c\u00f2n thu\u1eadt to\u00e1n l\u00e0 n\u01a1i ph\u00e1t huy ch\u1ee9c n\u0103ng c\u1ee7a c\u1ea5u tr\u00fac d\u1eef li\u1ec7u.</li> <li>Ch\u00fang ta c\u00f3 th\u1ec3 so s\u00e1nh c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n v\u1edbi vi\u1ec7c l\u1eafp r\u00e1p c\u00e1c kh\u1ed1i x\u00e2y d\u1ef1ng. C\u00e1c kh\u1ed1i l\u00e0 d\u1eef li\u1ec7u, h\u00ecnh d\u1ea1ng v\u00e0 c\u00e1ch k\u1ebft n\u1ed1i c\u00e1c kh\u1ed1i l\u00e0 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u, c\u00f2n c\u00e1c b\u01b0\u1edbc l\u1eafp r\u00e1p ch\u00ednh l\u00e0 thu\u1eadt to\u00e1n.</li> </ul>"},{"location":"chapter_introduction/summary/#hoi-ap","title":"H\u1ecfi &amp; \u0110\u00e1p","text":"<p>H\u1ecfi: L\u00e0 m\u1ed9t l\u1eadp tr\u00ecnh vi\u00ean, t\u00f4i hi\u1ebfm khi ph\u1ea3i t\u1ef1 c\u00e0i \u0111\u1eb7t thu\u1eadt to\u00e1n trong c\u00f4ng vi\u1ec7c h\u00e0ng ng\u00e0y. H\u1ea7u h\u1ebft c\u00e1c thu\u1eadt to\u00e1n th\u01b0\u1eddng d\u00f9ng \u0111\u1ec1u \u0111\u00e3 c\u00f3 s\u1eb5n trong ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh v\u00e0 th\u01b0 vi\u1ec7n, ch\u1ec9 c\u1ea7n d\u00f9ng l\u00e0 \u0111\u01b0\u1ee3c. \u0110i\u1ec1u n\u00e0y c\u00f3 ngh\u0129a l\u00e0 c\u00e1c v\u1ea5n \u0111\u1ec1 trong c\u00f4ng vi\u1ec7c ch\u01b0a \u0111\u1ee7 ph\u1ee9c t\u1ea1p \u0111\u1ec3 c\u1ea7n t\u1ef1 thi\u1ebft k\u1ebf thu\u1eadt to\u00e1n ri\u00eang?</p> <p>N\u1ebfu c\u00e1c k\u1ef9 n\u0103ng l\u00e0m vi\u1ec7c c\u1ee5 th\u1ec3 gi\u1ed1ng nh\u01b0 \"chi\u00eau th\u1ee9c\" trong v\u00f5 thu\u1eadt, th\u00ec c\u00e1c m\u00f4n h\u1ecdc n\u1ec1n t\u1ea3ng gi\u1ed1ng nh\u01b0 \"n\u1ed9i c\u00f4ng\".</p> <p>T\u00f4i cho r\u1eb1ng \u00fd ngh\u0129a c\u1ee7a vi\u1ec7c h\u1ecdc thu\u1eadt to\u00e1n (v\u00e0 c\u00e1c m\u00f4n n\u1ec1n t\u1ea3ng kh\u00e1c) kh\u00f4ng nh\u1ea5t thi\u1ebft l\u00e0 \u0111\u1ec3 t\u1ef1 c\u00e0i \u0111\u1eb7t l\u1ea1i t\u1eeb \u0111\u1ea7u khi l\u00e0m vi\u1ec7c, m\u00e0 l\u00e0 gi\u00fap ch\u00fang ta \u0111\u01b0a ra quy\u1ebft \u0111\u1ecbnh v\u00e0 gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 chuy\u00ean nghi\u1ec7p h\u01a1n d\u1ef1a tr\u00ean hi\u1ec3u bi\u1ebft v\u1eefng ch\u1eafc v\u1ec1 c\u00e1c kh\u00e1i ni\u1ec7m. Nh\u1edd \u0111\u00f3, ch\u1ea5t l\u01b0\u1ee3ng c\u00f4ng vi\u1ec7c c\u0169ng \u0111\u01b0\u1ee3c n\u00e2ng cao. V\u00ed d\u1ee5, m\u1ecdi ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh \u0111\u1ec1u cung c\u1ea5p h\u00e0m s\u1eafp x\u1ebfp c\u00f3 s\u1eb5n:</p> <ul> <li>N\u1ebfu ch\u01b0a h\u1ecdc v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n, khi c\u00f3 d\u1eef li\u1ec7u c\u1ea7n s\u1eafp x\u1ebfp, ch\u00fang ta ch\u1ec9 \u0111\u01a1n gi\u1ea3n \u0111\u01b0a v\u00e0o h\u00e0m s\u1eafp x\u1ebfp c\u00f3 s\u1eb5n. H\u00e0m n\u00e0y ch\u1ea1y m\u01b0\u1ee3t, hi\u1ec7u n\u0103ng t\u1ed1t, t\u01b0\u1edfng nh\u01b0 kh\u00f4ng c\u00f3 v\u1ea5n \u0111\u1ec1 g\u00ec.</li> <li>Tuy nhi\u00ean, n\u1ebfu \u0111\u00e3 h\u1ecdc thu\u1eadt to\u00e1n, ch\u00fang ta bi\u1ebft r\u1eb1ng \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian c\u1ee7a h\u00e0m s\u1eafp x\u1ebfp c\u00f3 s\u1eb5n th\u01b0\u1eddng l\u00e0 \\(O(n \\log n)\\). H\u01a1n n\u1eefa, n\u1ebfu d\u1eef li\u1ec7u l\u00e0 c\u00e1c s\u1ed1 nguy\u00ean c\u00f3 s\u1ed1 ch\u1eef s\u1ed1 c\u1ed1 \u0111\u1ecbnh (nh\u01b0 m\u00e3 s\u1ed1 sinh vi\u00ean), ta c\u00f3 th\u1ec3 d\u00f9ng c\u00e1ch hi\u1ec7u qu\u1ea3 h\u01a1n nh\u01b0 s\u1eafp x\u1ebfp theo c\u01a1 s\u1ed1 (radix sort), gi\u1ea3m \u0111\u1ed9 ph\u1ee9c t\u1ea1p xu\u1ed1ng O(nk), v\u1edbi k l\u00e0 s\u1ed1 ch\u1eef s\u1ed1. Khi x\u1eed l\u00fd l\u01b0\u1ee3ng d\u1eef li\u1ec7u l\u1edbn, th\u1eddi gian ti\u1ebft ki\u1ec7m \u0111\u01b0\u1ee3c s\u1ebd mang l\u1ea1i gi\u00e1 tr\u1ecb l\u1edbn \u2014 gi\u1ea3m chi ph\u00ed, n\u00e2ng cao tr\u1ea3i nghi\u1ec7m ng\u01b0\u1eddi d\u00f9ng v\u00e0 hi\u1ec7u su\u1ea5t h\u1ec7 th\u1ed1ng.</li> </ul> <p>Trong k\u1ef9 thu\u1eadt, nhi\u1ec1u v\u1ea5n \u0111\u1ec1 r\u1ea5t kh\u00f3 gi\u1ea3i quy\u1ebft t\u1ed1i \u01b0u; \u0111a s\u1ed1 \u0111\u01b0\u1ee3c x\u1eed l\u00fd b\u1eb1ng gi\u1ea3i ph\u00e1p \"g\u1ea7n t\u1ed1i \u01b0u\". \u0110\u1ed9 kh\u00f3 c\u1ee7a m\u1ed9t v\u1ea5n \u0111\u1ec1 kh\u00f4ng ch\u1ec9 ph\u1ee5 thu\u1ed9c v\u00e0o b\u1ea3n ch\u1ea5t c\u1ee7a n\u00f3 m\u00e0 c\u00f2n v\u00e0o ki\u1ebfn th\u1ee9c v\u00e0 kinh nghi\u1ec7m c\u1ee7a ng\u01b0\u1eddi gi\u1ea3i quy\u1ebft. C\u00e0ng hi\u1ec3u s\u00e2u v\u00e0 c\u00f3 nhi\u1ec1u kinh nghi\u1ec7m, ch\u00fang ta c\u00e0ng ph\u00e2n t\u00edch k\u1ef9 v\u00e0 gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1 m\u1ed9t c\u00e1ch hi\u1ec7u qu\u1ea3, s\u00e1ng t\u1ea1o h\u01a1n.</p>"},{"location":"chapter_introduction/what_is_dsa/","title":"1.2 What is an algorithm","text":""},{"location":"chapter_introduction/what_is_dsa/#thuat-toan-la-gi","title":"Thu\u1eadt to\u00e1n l\u00e0 g\u00ec","text":""},{"location":"chapter_introduction/what_is_dsa/#inh-nghia-ve-thuat-toan","title":"\u0110\u1ecbnh ngh\u0129a v\u1ec1 thu\u1eadt to\u00e1n","text":"<p>Thu\u1eadt to\u00e1n l\u00e0 m\u1ed9t t\u1eadp h\u1ee3p c\u00e1c h\u01b0\u1edbng d\u1eabn ho\u1eb7c b\u01b0\u1edbc \u0111\u1ec3 gi\u1ea3i quy\u1ebft m\u1ed9t v\u1ea5n \u0111\u1ec1 c\u1ee5 th\u1ec3 trong m\u1ed9t kho\u1ea3ng th\u1eddi gian h\u1eefu h\u1ea1n. Thu\u1eadt to\u00e1n c\u00f3 c\u00e1c \u0111\u1eb7c \u0111i\u1ec3m sau:</p> <ul> <li>V\u1ea5n \u0111\u1ec1 \u0111\u01b0\u1ee3c x\u00e1c \u0111\u1ecbnh r\u00f5 r\u00e0ng, bao g\u1ed3m \u0111\u1ecbnh ngh\u0129a r\u00f5 r\u00e0ng v\u1ec1 \u0111\u1ea7u v\u00e0o v\u00e0 \u0111\u1ea7u ra.</li> <li>Thu\u1eadt to\u00e1n kh\u1ea3 thi, ngh\u0129a l\u00e0 c\u00f3 th\u1ec3 ho\u00e0n th\u00e0nh trong m\u1ed9t s\u1ed1 b\u01b0\u1edbc, th\u1eddi gian v\u00e0 b\u1ed9 nh\u1edb h\u1eefu h\u1ea1n.</li> <li>M\u1ed7i b\u01b0\u1edbc \u0111\u1ec1u c\u00f3 \u00fd ngh\u0129a r\u00f5 r\u00e0ng. K\u1ebft qu\u1ea3 \u0111\u1ea7u ra lu\u00f4n gi\u1ed1ng nhau n\u1ebfu \u0111\u1ea7u v\u00e0o v\u00e0 \u0111i\u1ec1u ki\u1ec7n gi\u1ed1ng nhau.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/#inh-nghia-ve-cau-truc-du-lieu","title":"\u0110\u1ecbnh ngh\u0129a v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u","text":"<p>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u00e0 c\u00e1ch t\u1ed5 ch\u1ee9c v\u00e0 l\u01b0u tr\u1eef d\u1eef li\u1ec7u trong m\u00e1y t\u00ednh, v\u1edbi c\u00e1c m\u1ee5c ti\u00eau thi\u1ebft k\u1ebf sau:</p> <ul> <li>Gi\u1ea3m thi\u1ec3u dung l\u01b0\u1ee3ng b\u1ed9 nh\u1edb \u0111\u1ec3 ti\u1ebft ki\u1ec7m t\u00e0i nguy\u00ean m\u00e1y t\u00ednh.</li> <li>L\u00e0m cho c\u00e1c thao t\u00e1c v\u1edbi d\u1eef li\u1ec7u nhanh nh\u1ea5t c\u00f3 th\u1ec3, bao g\u1ed3m truy c\u1eadp, th\u00eam, x\u00f3a, c\u1eadp nh\u1eadt d\u1eef li\u1ec7u, v.v.</li> <li>Cung c\u1ea5p c\u00e1ch bi\u1ec3u di\u1ec5n d\u1eef li\u1ec7u ng\u1eafn g\u1ecdn v\u00e0 th\u00f4ng tin logic \u0111\u1ec3 thu\u1eadt to\u00e1n ho\u1ea1t \u0111\u1ed9ng hi\u1ec7u qu\u1ea3.</li> </ul> <p>Thi\u1ebft k\u1ebf c\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u00e0 m\u1ed9t qu\u00e1 tr\u00ecnh c\u00e2n b\u1eb1ng, th\u01b0\u1eddng ph\u1ea3i \u0111\u00e1nh \u0111\u1ed5i. N\u1ebfu mu\u1ed1n c\u1ea3i thi\u1ec7n m\u1ed9t m\u1eb7t n\u00e0o \u0111\u00f3, th\u01b0\u1eddng ph\u1ea3i ch\u1ea5p nh\u1eadn hy sinh m\u1eb7t kh\u00e1c. V\u00ed d\u1ee5:</p> <ul> <li>So v\u1edbi m\u1ea3ng, danh s\u00e1ch li\u00ean k\u1ebft thu\u1eadn ti\u1ec7n h\u01a1n khi th\u00eam ho\u1eb7c x\u00f3a d\u1eef li\u1ec7u nh\u01b0ng l\u1ea1i ch\u1eadm h\u01a1n khi truy c\u1eadp d\u1eef li\u1ec7u.</li> <li>So v\u1edbi danh s\u00e1ch li\u00ean k\u1ebft, \u0111\u1ed3 th\u1ecb cung c\u1ea5p th\u00f4ng tin logic phong ph\u00fa h\u01a1n nh\u01b0ng l\u1ea1i t\u1ed1n nhi\u1ec1u b\u1ed9 nh\u1edb h\u01a1n.</li> </ul>"},{"location":"chapter_introduction/what_is_dsa/#moi-quan-he-giua-cau-truc-du-lieu-va-thuat-toan","title":"M\u1ed1i quan h\u1ec7 gi\u1eefa c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n","text":"<p>Nh\u01b0 h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y, c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n c\u00f3 m\u1ed1i li\u00ean h\u1ec7 ch\u1eb7t ch\u1ebd, c\u1ee5 th\u1ec3 \u1edf ba \u0111i\u1ec3m sau:</p> <ul> <li>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u00e0 n\u1ec1n t\u1ea3ng c\u1ee7a thu\u1eadt to\u00e1n. Ch\u00fang cung c\u1ea5p c\u00e1ch l\u01b0u tr\u1eef d\u1eef li\u1ec7u c\u00f3 t\u1ed5 ch\u1ee9c v\u00e0 c\u00e1c ph\u01b0\u01a1ng th\u1ee9c thao t\u00e1c d\u1eef li\u1ec7u cho thu\u1eadt to\u00e1n.</li> <li>Thu\u1eadt to\u00e1n mang l\u1ea1i s\u1ee9c s\u1ed1ng cho c\u1ea5u tr\u00fac d\u1eef li\u1ec7u. N\u1ebfu ch\u1ec9 c\u00f3 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u th\u00ec ch\u1ec9 l\u01b0u tr\u1eef th\u00f4ng tin, nh\u1edd c\u00f3 thu\u1eadt to\u00e1n m\u1edbi gi\u1ea3i quy\u1ebft \u0111\u01b0\u1ee3c c\u00e1c v\u1ea5n \u0111\u1ec1 c\u1ee5 th\u1ec3.</li> <li>M\u1ed9t thu\u1eadt to\u00e1n c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c c\u00e0i \u0111\u1eb7t d\u1ef1a tr\u00ean nhi\u1ec1u c\u1ea5u tr\u00fac d\u1eef li\u1ec7u kh\u00e1c nhau, nh\u01b0ng hi\u1ec7u su\u1ea5t th\u1ef1c thi c\u00f3 th\u1ec3 kh\u00e1c bi\u1ec7t r\u1ea5t l\u1edbn. Vi\u1ec7c ch\u1ecdn \u0111\u00fang c\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u00e0 ch\u00eca kh\u00f3a.</li> </ul> <p></p> <p>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c v\u00ed nh\u01b0 m\u1ed9t b\u1ed9 x\u1ebfp h\u00ecnh, nh\u01b0 h\u00ecnh minh h\u1ecda d\u01b0\u1edbi \u0111\u00e2y. M\u1ed9t b\u1ed9 x\u1ebfp h\u00ecnh g\u1ed3m nhi\u1ec1u m\u1ea3nh gh\u00e9p, k\u00e8m theo h\u01b0\u1edbng d\u1eabn l\u1eafp r\u00e1p chi ti\u1ebft. L\u00e0m theo t\u1eebng b\u01b0\u1edbc h\u01b0\u1edbng d\u1eabn, ch\u00fang ta c\u00f3 th\u1ec3 l\u1eafp th\u00e0nh m\u1ed9t m\u00f4 h\u00ecnh ph\u1ee9c t\u1ea1p.</p> <p></p> <p>B\u1ea3ng d\u01b0\u1edbi \u0111\u00e2y cho th\u1ea5y s\u1ef1 t\u01b0\u01a1ng \u1ee9ng chi ti\u1ebft gi\u1eefa hai kh\u00e1i ni\u1ec7m n\u00e0y.</p> <p> B\u1ea3ng  \u00a0 So s\u00e1nh c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n v\u1edbi b\u1ed9 x\u1ebfp h\u00ecnh </p> C\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n B\u1ed9 x\u1ebfp h\u00ecnh D\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o C\u00e1c m\u1ea3nh gh\u00e9p ch\u01b0a l\u1eafp r\u00e1p C\u1ea5u tr\u00fac d\u1eef li\u1ec7u C\u00e1ch t\u1ed5 ch\u1ee9c c\u00e1c m\u1ea3nh gh\u00e9p, g\u1ed3m h\u00ecnh d\u1ea1ng, k\u00edch th\u01b0\u1edbc, k\u1ebft n\u1ed1i... Thu\u1eadt to\u00e1n Chu\u1ed7i c\u00e1c b\u01b0\u1edbc l\u1eafp r\u00e1p c\u00e1c m\u1ea3nh th\u00e0nh h\u00ecnh mong mu\u1ed1n D\u1eef li\u1ec7u \u0111\u1ea7u ra M\u00f4 h\u00ecnh x\u1ebfp h\u00ecnh ho\u00e0n ch\u1ec9nh <p>L\u01b0u \u00fd r\u1eb1ng c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n kh\u00f4ng ph\u1ee5 thu\u1ed9c v\u00e0o ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh. V\u00ec v\u1eady, cu\u1ed1n s\u00e1ch n\u00e0y c\u00f3 th\u1ec3 cung c\u1ea5p c\u00e1c v\u00ed d\u1ee5 c\u00e0i \u0111\u1eb7t b\u1eb1ng nhi\u1ec1u ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh kh\u00e1c nhau.</p> <p>Vi\u1ebft t\u1eaft th\u00f4ng d\u1ee5ng</p> <p>Trong th\u1ef1c t\u1ebf, ch\u00fang ta th\u01b0\u1eddng g\u1ecdi \"C\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 Thu\u1eadt to\u00e1n\" \u0111\u01a1n gi\u1ea3n l\u00e0 \"Thu\u1eadt to\u00e1n\". V\u00ed d\u1ee5, c\u00e1c b\u00e0i to\u00e1n thu\u1eadt to\u00e1n n\u1ed5i ti\u1ebfng tr\u00ean LeetCode th\u1ef1c ch\u1ea5t ki\u1ec3m tra c\u1ea3 ki\u1ebfn th\u1ee9c v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u l\u1eabn thu\u1eadt to\u00e1n.</p>"},{"location":"chapter_preface/","title":"L\u1eddi M\u1edf \u0110\u1ea7u","text":""},{"location":"chapter_preface/#loi-mo-au","title":"L\u1eddi M\u1edf \u0110\u1ea7u","text":"<p>Abstract</p> <p>Thu\u1eadt to\u00e1n gi\u1ed1ng nh\u01b0 m\u1ed9t b\u1ea3n giao h\u01b0\u1edfng \u0111\u1eb9p \u0111\u1ebd, v\u1edbi m\u1ed7i d\u00f2ng m\u00e3 ch\u1ea3y nh\u01b0 m\u1ed9t nh\u1ecbp \u0111i\u1ec7u.</p> <p>Mong r\u1eb1ng cu\u1ed1n s\u00e1ch n\u00e0y s\u1ebd vang v\u1ecdng nh\u1eb9 nh\u00e0ng trong t\u00e2m tr\u00ed b\u1ea1n, \u0111\u1ec3 l\u1ea1i m\u1ed9t giai \u0111i\u1ec7u \u0111\u1ed9c \u0111\u00e1o v\u00e0 s\u00e2u s\u1eafc.</p>"},{"location":"chapter_preface/about_the_book/","title":"0.1 About this book","text":""},{"location":"chapter_preface/about_the_book/#ve-cuon-sach-nay","title":"V\u1ec1 cu\u1ed1n s\u00e1ch n\u00e0y","text":"<p>D\u1ef1 \u00e1n m\u00e3 ngu\u1ed3n m\u1edf n\u00e0y nh\u1eb1m t\u1ea1o ra m\u1ed9t kh\u00f3a h\u1ecdc c\u1ea5p t\u1ed1c mi\u1ec5n ph\u00ed, th\u00e2n thi\u1ec7n v\u1edbi ng\u01b0\u1eddi m\u1edbi b\u1eaft \u0111\u1ea7u v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n.</p> <ul> <li>Minh h\u1ecda \u0111\u1ed9ng, n\u1ed9i dung d\u1ec5 hi\u1ec3u v\u00e0 l\u1ed9 tr\u00ecnh h\u1ecdc m\u01b0\u1ee3t m\u00e0 gi\u00fap ng\u01b0\u1eddi m\u1edbi kh\u00e1m ph\u00e1 \"b\u1ea3n \u0111\u1ed3 tri th\u1ee9c\" v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n.</li> <li>Ch\u1ea1y m\u00e3 ch\u1ec9 v\u1edbi m\u1ed9t c\u00fa nh\u1ea5p chu\u1ed9t, gi\u00fap ng\u01b0\u1eddi \u0111\u1ecdc n\u00e2ng cao k\u1ef9 n\u0103ng l\u1eadp tr\u00ecnh v\u00e0 hi\u1ec3u nguy\u00ean l\u00fd ho\u1ea1t \u0111\u1ed9ng c\u1ee7a thu\u1eadt to\u00e1n c\u0169ng nh\u01b0 c\u00e1ch tri\u1ec3n khai c\u1ea5u tr\u00fac d\u1eef li\u1ec7u b\u00ean d\u01b0\u1edbi.</li> <li>Khuy\u1ebfn kh\u00edch h\u1ecdc t\u1eadp qua vi\u1ec7c gi\u1ea3ng d\u1ea1y, h\u00e3y tho\u1ea3i m\u00e1i \u0111\u1eb7t c\u00e2u h\u1ecfi v\u00e0 chia s\u1ebb \u00fd ki\u1ebfn. C\u00f9ng nhau ph\u00e1t tri\u1ec3n th\u00f4ng qua th\u1ea3o lu\u1eadn.</li> </ul>"},{"location":"chapter_preface/about_the_book/#oi-tuong-oc-gia","title":"\u0110\u1ed1i t\u01b0\u1ee3ng \u0111\u1ed9c gi\u1ea3","text":"<p>N\u1ebfu b\u1ea1n l\u00e0 ng\u01b0\u1eddi m\u1edbi l\u00e0m quen v\u1edbi thu\u1eadt to\u00e1n, ho\u1eb7c \u0111\u00e3 c\u00f3 ch\u00fat kinh nghi\u1ec7m nh\u01b0ng ch\u1ec9 hi\u1ec3u m\u01a1 h\u1ed3 v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n, th\u01b0\u1eddng xuy\u00ean dao \u0111\u1ed9ng gi\u1eefa \"hi\u1ec3u r\u1ed3i\" v\u00e0 \"ch\u01b0a r\u00f5 l\u1eafm\", th\u00ec cu\u1ed1n s\u00e1ch n\u00e0y d\u00e0nh cho b\u1ea1n!</p> <p>N\u1ebfu b\u1ea1n \u0111\u00e3 c\u00f3 kinh nghi\u1ec7m gi\u1ea3i b\u00e0i t\u1eadp, quen thu\u1ed9c v\u1edbi h\u1ea7u h\u1ebft c\u00e1c d\u1ea1ng b\u00e0i, cu\u1ed1n s\u00e1ch n\u00e0y s\u1ebd gi\u00fap b\u1ea1n \u00f4n t\u1eadp v\u00e0 h\u1ec7 th\u1ed1ng l\u1ea1i ki\u1ebfn th\u1ee9c thu\u1eadt to\u00e1n. M\u00e3 ngu\u1ed3n trong kho l\u01b0u tr\u1eef c\u00f3 th\u1ec3 d\u00f9ng nh\u01b0 \"b\u1ed9 c\u00f4ng c\u1ee5 gi\u1ea3i b\u00e0i\" ho\u1eb7c \"b\u1ea3ng gian l\u1eadn thu\u1eadt to\u00e1n\".</p> <p>N\u1ebfu b\u1ea1n l\u00e0 chuy\u00ean gia thu\u1eadt to\u00e1n, ch\u00fang t\u00f4i r\u1ea5t mong nh\u1eadn \u0111\u01b0\u1ee3c g\u00f3p \u00fd qu\u00fd b\u00e1u t\u1eeb b\u1ea1n, ho\u1eb7c tham gia c\u00f9ng ch\u00fang t\u00f4i.</p> <p>Y\u00eau c\u1ea7u n\u1ec1n t\u1ea3ng</p> <p>B\u1ea1n n\u00ean bi\u1ebft c\u00e1ch \u0111\u1ecdc v\u00e0 vi\u1ebft m\u00e3 \u0111\u01a1n gi\u1ea3n b\u1eb1ng \u00edt nh\u1ea5t m\u1ed9t ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh.</p>"},{"location":"chapter_preface/about_the_book/#cau-truc-noi-dung","title":"C\u1ea5u tr\u00fac n\u1ed9i dung","text":"<p>N\u1ed9i dung ch\u00ednh c\u1ee7a s\u00e1ch \u0111\u01b0\u1ee3c th\u1ec3 hi\u1ec7n trong h\u00ecnh d\u01b0\u1edbi \u0111\u00e2y.</p> <ul> <li>Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p: t\u00ecm hi\u1ec3u c\u00e1c kh\u00eda c\u1ea1nh v\u00e0 ph\u01b0\u01a1ng ph\u00e1p \u0111\u00e1nh gi\u00e1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n. Bao g\u1ed3m c\u00e1ch x\u00e1c \u0111\u1ecbnh \u0111\u1ed9 ph\u1ee9c t\u1ea1p th\u1eddi gian v\u00e0 kh\u00f4ng gian, c\u00e1c lo\u1ea1i ph\u1ed5 bi\u1ebfn v\u00e0 v\u00ed d\u1ee5 minh h\u1ecda.</li> <li>C\u1ea5u tr\u00fac d\u1eef li\u1ec7u: t\u1eadp trung v\u00e0o c\u00e1c ki\u1ec3u d\u1eef li\u1ec7u c\u01a1 b\u1ea3n, ph\u01b0\u01a1ng ph\u00e1p ph\u00e2n lo\u1ea1i, \u0111\u1ecbnh ngh\u0129a, \u01b0u nh\u01b0\u1ee3c \u0111i\u1ec3m, thao t\u00e1c th\u01b0\u1eddng g\u1eb7p, c\u00e1c lo\u1ea1i, \u1ee9ng d\u1ee5ng v\u00e0 c\u00e1ch tri\u1ec3n khai c\u00e1c c\u1ea5u tr\u00fac nh\u01b0 m\u1ea3ng, danh s\u00e1ch li\u00ean k\u1ebft, ng\u0103n x\u1ebfp, h\u00e0ng \u0111\u1ee3i, b\u1ea3ng b\u0103m, c\u00e2y, heap, \u0111\u1ed3 th\u1ecb, v.v.</li> <li>Thu\u1eadt to\u00e1n: \u0111\u1ecbnh ngh\u0129a thu\u1eadt to\u00e1n, b\u00e0n v\u1ec1 \u01b0u nh\u01b0\u1ee3c \u0111i\u1ec3m, hi\u1ec7u qu\u1ea3, t\u00ecnh hu\u1ed1ng \u00e1p d\u1ee5ng, c\u00e1c b\u01b0\u1edbc gi\u1ea3i quy\u1ebft v\u1ea5n \u0111\u1ec1, k\u00e8m v\u00ed d\u1ee5 v\u1ec1 c\u00e1c thu\u1eadt to\u00e1n nh\u01b0 t\u00ecm ki\u1ebfm, s\u1eafp x\u1ebfp, chia \u0111\u1ec3 tr\u1ecb, quay lui, l\u1eadp tr\u00ecnh \u0111\u1ed9ng, tham lam v\u00e0 nhi\u1ec1u h\u01a1n n\u1eefa.</li> </ul> <p></p>"},{"location":"chapter_preface/about_the_book/#loi-cam-on","title":"L\u1eddi c\u1ea3m \u01a1n","text":"<p>Cu\u1ed1n s\u00e1ch n\u00e0y kh\u00f4ng ng\u1eebng \u0111\u01b0\u1ee3c ho\u00e0n thi\u1ec7n nh\u1edd s\u1ef1 \u0111\u00f3ng g\u00f3p chung c\u1ee7a nhi\u1ec1u th\u00e0nh vi\u00ean c\u1ed9ng \u0111\u1ed3ng m\u00e3 ngu\u1ed3n m\u1edf. Xin c\u1ea3m \u01a1n t\u1eebng t\u00e1c gi\u1ea3 \u0111\u00e3 d\u00e0nh th\u1eddi gian v\u00e0 t\u00e2m huy\u1ebft, \u0111\u01b0\u1ee3c li\u1ec7t k\u00ea theo th\u1ee9 t\u1ef1 tr\u00ean GitHub: krahets, coderonion, Gonglja, nuomi1, Reanon, justin-tse, hpstory, danielsss, curtishd, night-cruise, S-N-O-R-L-A-X, msk397, gvenusleo, khoaxuantu, RiverTwilight, rongyi, gyt95, zhuoqinyue, K3v123, Zuoxun, mingXta, hello-ikun, FangYuan33, GN-Yu, yuelinxin, longsizhuo, Cathay-Chen, guowei-gong, xBLACKICEx, IsChristina, JoseHung, qualifier1024, QiLOL, pengchzn, Guanngxu, L-Super, WSL0809, Slone123c, lhxsm, yuan0221, what-is-me, theNefelibatas, longranger2, cy-by-side, xiongsp, JeffersonHuang, Transmigration-zhou, magentaqin, Wonderdch, malone6, xiaomiusa87, gaofer, bluebean-cloud, a16su, Shyam-Chen, nanlei, hongyun-robot, Phoenix0415, MolDuM, Nigh, he-weilai, junminhong, mgisr, iron-irax, yd-j, XiaChuerwu, XC-Zero, seven1240, SamJin98, wodray, reeswell, NI-SW, Horbin-Magician, Enlightenus, xjr7670, YangXuanyi, DullSword, boloboloda, iStig, qq909244296, jiaxianhua, wenjianmin, keshida, kilikilikid, lclc6, lwbaptx, liuxjerry, lucaswangdev, lyl625760, hts0000, gledfish, fbigm, echo1937, szu17dmy, dshlstarr, Yucao-cy, coderlef, czruby, bongbongbakudan, beintentional, ZongYangL, ZhongYuuu, luluxia, xb534, bitsmi, ElaBosak233, baagod, zhouLion, yishangzhang, yi427, yabo083, weibk, wangwang105, th1nk3r-ing, tao363, 4yDX3906, syd168, steventimes, sslmj2020, smilelsb, siqyka, selear, sdshaoda, Xi-Row, popozhu, nuquist19, noobcodemaker, XiaoK29, chadyi, ZhongGuanbin, shanghai-Jerry, JackYang-hellobobo, Javesun99, lipusheng, BlindTerran, ShiMaRing, FreddieLi, FloranceYeh, iFleey, fanchenggang, gltianwen, goerll, Dr-XYZ, nedchu, curly210102, CuB3y0nd, KraHsu, CarrotDLaw, youshaoXG, bubble9um, fanenr, eagleanurag, LifeGoesOnionOnionOnion, 52coder, foursevenlove, KorsChen, hezhizhen, linzeyan, ZJKung, GaochaoZhu, hopkings2008, yang-le, Evilrabbit520, Turing-1024-Lee, thomasq0, Suremotoo, Allen-Scai, Risuntsy, Richard-Zhang1019, qingpeng9802, primexiao, nidhoggfgg, 1ch0, MwumLi, martinx, ZnYang2018, hugtyftg, logan-qiu, psychelzh, Keynman, KeiichiKasai v\u00e0 0130w.</p> <p>C\u00f4ng vi\u1ec7c ki\u1ec3m tra m\u00e3 ngu\u1ed3n cho cu\u1ed1n s\u00e1ch n\u00e0y \u0111\u01b0\u1ee3c th\u1ef1c hi\u1ec7n b\u1edfi coderonion, Gonglja, gvenusleo, hpstory, justin\u2010tse, khoaxuantu, krahets, night-cruise, nuomi1, Reanon v\u00e0 rongyi (li\u1ec7t k\u00ea theo th\u1ee9 t\u1ef1 b\u1ea3ng ch\u1eef c\u00e1i). Xin c\u1ea3m \u01a1n h\u1ecd \u0111\u00e3 d\u00e0nh th\u1eddi gian v\u00e0 c\u00f4ng s\u1ee9c, \u0111\u1ea3m b\u1ea3o m\u00e3 ngu\u1ed3n c\u00e1c ng\u00f4n ng\u1eef \u0111\u01b0\u1ee3c chu\u1ea9n h\u00f3a v\u00e0 \u0111\u1ed3ng nh\u1ea5t.</p> <p>Phi\u00ean b\u1ea3n ti\u1ebfng Trung Ph\u1ed3n th\u1ec3 \u0111\u01b0\u1ee3c ki\u1ec3m duy\u1ec7t b\u1edfi Shyam-Chen v\u00e0 Dr-XYZ, c\u00f2n b\u1ea3n ti\u1ebfng Anh do yuelinxin, K3v123, QiLOL, Phoenix0415, SamJin98, yanedie, RafaelCaso, pengchzn, thomasq0 v\u00e0 magentaqin th\u1ef1c hi\u1ec7n. Nh\u1edd s\u1ef1 \u0111\u00f3ng g\u00f3p li\u00ean t\u1ee5c c\u1ee7a h\u1ecd, cu\u1ed1n s\u00e1ch n\u00e0y m\u1edbi c\u00f3 th\u1ec3 ti\u1ebfp c\u1eadn v\u00e0 ph\u1ee5c v\u1ee5 nhi\u1ec1u \u0111\u1ed9c gi\u1ea3 h\u01a1n.</p> <p>Trong qu\u00e1 tr\u00ecnh bi\u00ean so\u1ea1n, r\u1ea5t nhi\u1ec1u c\u00e1 nh\u00e2n \u0111\u00e3 h\u1ed7 tr\u1ee3 v\u00f4 gi\u00e1, bao g\u1ed3m nh\u01b0ng kh\u00f4ng gi\u1edbi h\u1ea1n:</p> <ul> <li>C\u1ea3m \u01a1n ng\u01b0\u1eddi th\u1ea7y t\u1ea1i c\u00f4ng ty, Ti\u1ebfn s\u0129 Xi Li, \u0111\u00e3 \u0111\u1ed9ng vi\u00ean t\u00f4i trong m\u1ed9t cu\u1ed9c tr\u00f2 chuy\u1ec7n r\u1eb1ng \"h\u00e3y b\u1eaft \u0111\u1ea7u th\u1eadt nhanh\", gi\u00fap t\u00f4i quy\u1ebft t\u00e2m vi\u1ebft cu\u1ed1n s\u00e1ch n\u00e0y;</li> <li>C\u1ea3m \u01a1n b\u1ea1n g\u00e1i Bubble, \u0111\u1ed9c gi\u1ea3 \u0111\u1ea7u ti\u00ean c\u1ee7a s\u00e1ch, \u0111\u00e3 g\u00f3p \u00fd nhi\u1ec1u t\u1eeb g\u00f3c nh\u00ecn ng\u01b0\u1eddi m\u1edbi h\u1ecdc thu\u1eadt to\u00e1n, gi\u00fap s\u00e1ch ph\u00f9 h\u1ee3p h\u01a1n v\u1edbi ng\u01b0\u1eddi m\u1edbi;</li> <li>C\u1ea3m \u01a1n Tengbao, Qibao v\u00e0 Feibao \u0111\u00e3 ngh\u0129 ra t\u00ean s\u00e1ch s\u00e1ng t\u1ea1o, g\u1ee3i nh\u1edb k\u1ef7 ni\u1ec7m vi\u1ebft d\u00f2ng code \u0111\u1ea7u ti\u00ean \"Hello World!\";</li> <li>C\u1ea3m \u01a1n Xiaoquan \u0111\u00e3 h\u1ed7 tr\u1ee3 chuy\u00ean m\u00f4n v\u1ec1 s\u1edf h\u1eefu tr\u00ed tu\u1ec7, \u0111\u00f3ng vai tr\u00f2 quan tr\u1ecdng trong ph\u00e1t tri\u1ec3n s\u00e1ch m\u00e3 ngu\u1ed3n m\u1edf n\u00e0y;</li> <li>C\u1ea3m \u01a1n Sutong \u0111\u00e3 thi\u1ebft k\u1ebf b\u00eca v\u00e0 logo \u0111\u1eb9p m\u1eaft, ki\u00ean nh\u1eabn ch\u1ec9nh s\u1eeda nhi\u1ec1u l\u1ea7n theo y\u00eau c\u1ea7u c\u1ee7a t\u00f4i;</li> <li>C\u1ea3m \u01a1n @squidfunk \u0111\u00e3 g\u00f3p \u00fd v\u1ec1 c\u00e1ch vi\u1ebft, tr\u00ecnh b\u00e0y v\u00e0 ph\u00e1t tri\u1ec3n ch\u1ee7 \u0111\u1ec1 t\u00e0i li\u1ec7u m\u00e3 ngu\u1ed3n m\u1edf Material-for-MkDocs.</li> </ul> <p>Trong qu\u00e1 tr\u00ecnh vi\u1ebft, t\u00f4i \u0111\u00e3 tham kh\u1ea3o nhi\u1ec1u s\u00e1ch gi\u00e1o tr\u00ecnh v\u00e0 b\u00e0i vi\u1ebft v\u1ec1 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n. Nh\u1eefng t\u00e0i li\u1ec7u n\u00e0y l\u00e0 t\u1ea5m g\u01b0\u01a1ng m\u1eabu m\u1ef1c, gi\u00fap \u0111\u1ea3m b\u1ea3o \u0111\u1ed9 ch\u00ednh x\u00e1c v\u00e0 ch\u1ea5t l\u01b0\u1ee3ng n\u1ed9i dung s\u00e1ch. Xin c\u1ea3m \u01a1n t\u1ea5t c\u1ea3 nh\u1eefng ng\u01b0\u1eddi \u0111i tr\u01b0\u1edbc v\u00ec \u0111\u00f3ng g\u00f3p qu\u00fd b\u00e1u!</p> <p>Cu\u1ed1n s\u00e1ch n\u00e0y khuy\u1ebfn kh\u00edch k\u1ebft h\u1ee3p h\u1ecdc th\u1ef1c h\u00e0nh v\u00e0 t\u01b0 duy, l\u1ea5y c\u1ea3m h\u1ee9ng t\u1eeb \"Dive into Deep Learning\". T\u00f4i r\u1ea5t khuy\u1ebfn kh\u00edch c\u00e1c b\u1ea1n \u0111\u1ecdc cu\u1ed1n s\u00e1ch tuy\u1ec7t v\u1eddi n\u00e0y.</p> <p>Xin g\u1eedi l\u1eddi c\u1ea3m \u01a1n s\u00e2u s\u1eafc t\u1edbi cha m\u1eb9 t\u00f4i, nh\u1eefng ng\u01b0\u1eddi lu\u00f4n \u1ee7ng h\u1ed9 v\u00e0 \u0111\u1ed9ng vi\u00ean \u0111\u1ec3 t\u00f4i c\u00f3 th\u1ec3 l\u00e0m c\u00f4ng vi\u1ec7c th\u00fa v\u1ecb n\u00e0y.</p>"},{"location":"chapter_preface/suggestions/","title":"0.2 How to read","text":""},{"location":"chapter_preface/suggestions/#cach-oc-sach","title":"C\u00e1ch \u0111\u1ecdc s\u00e1ch","text":"<p>Tip</p> <p>\u0110\u1ec3 c\u00f3 tr\u1ea3i nghi\u1ec7m \u0111\u1ecdc t\u1ed1t nh\u1ea5t, b\u1ea1n n\u00ean \u0111\u1ecdc k\u1ef9 ph\u1ea7n n\u00e0y.</p>"},{"location":"chapter_preface/suggestions/#quy-uoc-viet","title":"Quy \u01b0\u1edbc vi\u1ebft","text":"<ul> <li>C\u00e1c ch\u01b0\u01a1ng c\u00f3 d\u1ea5u '*' sau ti\u00eau \u0111\u1ec1 l\u00e0 t\u00f9y ch\u1ecdn v\u00e0 ch\u1ee9a n\u1ed9i dung t\u01b0\u01a1ng \u0111\u1ed1i kh\u00f3. N\u1ebfu b\u1ea1n kh\u00f4ng c\u00f3 nhi\u1ec1u th\u1eddi gian, n\u00ean b\u1ecf qua c\u00e1c ch\u01b0\u01a1ng n\u00e0y.</li> <li>C\u00e1c thu\u1eadt ng\u1eef k\u1ef9 thu\u1eadt s\u1ebd \u0111\u01b0\u1ee3c in \u0111\u1eadm (trong b\u1ea3n in v\u00e0 PDF) ho\u1eb7c g\u1ea1ch ch\u00e2n (tr\u00ean b\u1ea3n web), v\u00ed d\u1ee5: m\u1ea3ng. B\u1ea1n n\u00ean l\u00e0m quen v\u1edbi c\u00e1c thu\u1eadt ng\u1eef n\u00e0y \u0111\u1ec3 hi\u1ec3u t\u1ed1t h\u01a1n c\u00e1c v\u0103n b\u1ea3n k\u1ef9 thu\u1eadt.</li> <li>Ch\u1eef in \u0111\u1eadm ch\u1ec9 ra n\u1ed9i dung ch\u00ednh ho\u1eb7c c\u00e1c c\u00e2u t\u00f3m t\u1eaft, c\u1ea7n ch\u00fa \u00fd \u0111\u1eb7c bi\u1ec7t.</li> <li>C\u00e1c t\u1eeb v\u00e0 c\u1ee5m t\u1eeb c\u00f3 \u00fd ngh\u0129a \u0111\u1eb7c bi\u1ec7t s\u1ebd \u0111\u01b0\u1ee3c \u0111\u1eb7t trong \u201cd\u1ea5u ngo\u1eb7c k\u00e9p\u201d \u0111\u1ec3 tr\u00e1nh nh\u1ea7m l\u1eabn.</li> <li>\u0110\u1ed1i v\u1edbi c\u00e1c thu\u1eadt ng\u1eef kh\u00f4ng nh\u1ea5t qu\u00e1n gi\u1eefa c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh, s\u00e1ch n\u00e0y s\u1ebd theo Python, v\u00ed d\u1ee5 d\u00f9ng <code>None</code> \u0111\u1ec3 ch\u1ec9 <code>null</code>.</li> <li>S\u00e1ch n\u00e0y ph\u1ea7n n\u00e0o b\u1ecf qua quy \u01b0\u1edbc ch\u00fa th\u00edch c\u1ee7a c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh \u0111\u1ec3 tr\u00ecnh b\u00e0y n\u1ed9i dung g\u1ecdn g\u00e0ng h\u01a1n. C\u00e1c ch\u00fa th\u00edch ch\u1ee7 y\u1ebfu g\u1ed3m ba lo\u1ea1i: ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1, ch\u00fa th\u00edch n\u1ed9i dung v\u00e0 ch\u00fa th\u00edch nhi\u1ec1u d\u00f2ng.</li> </ul> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig <pre><code>\"\"\"Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v.\"\"\"\n\n# Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft\n\n\"\"\"\nCh\u00fa th\u00edch\nnhi\u1ec1u d\u00f2ng\n\"\"\"\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>/* Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v. */\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n/**\n * Ch\u00fa th\u00edch\n * nhi\u1ec1u d\u00f2ng\n */\n</code></pre> <pre><code>// Ch\u00fa th\u00edch ti\u00eau \u0111\u1ec1 \u0111\u1ec3 ghi ch\u00fa h\u00e0m, l\u1edbp, v\u00ed d\u1ee5 ki\u1ec3m th\u1eed, v.v.\n\n// Ch\u00fa th\u00edch gi\u1ea3i th\u00edch chi ti\u1ebft.\n\n// Ch\u00fa th\u00edch\n// nhi\u1ec1u d\u00f2ng\n</code></pre>"},{"location":"chapter_preface/suggestions/#hoc-hieu-qua-qua-hinh-minh-hoa-ong","title":"H\u1ecdc hi\u1ec7u qu\u1ea3 qua h\u00ecnh minh h\u1ecda \u0111\u1ed9ng","text":"<p>So v\u1edbi v\u0103n b\u1ea3n, video v\u00e0 h\u00ecnh \u1ea3nh c\u00f3 m\u1eadt \u0111\u1ed9 th\u00f4ng tin cao h\u01a1n v\u00e0 c\u1ea5u tr\u00fac r\u00f5 r\u00e0ng h\u01a1n, gi\u00fap d\u1ec5 hi\u1ec3u h\u01a1n. Trong s\u00e1ch n\u00e0y, c\u00e1c kh\u00e1i ni\u1ec7m quan tr\u1ecdng v\u00e0 kh\u00f3 ch\u1ee7 y\u1ebfu \u0111\u01b0\u1ee3c tr\u00ecnh b\u00e0y qua ho\u1ea1t h\u00ecnh v\u00e0 h\u00ecnh minh h\u1ecda, c\u00f2n v\u0103n b\u1ea3n ch\u1ec9 \u0111\u1ec3 gi\u1ea3i th\u00edch v\u00e0 b\u1ed5 sung.</p> <p>Khi g\u1eb7p n\u1ed9i dung c\u00f3 ho\u1ea1t h\u00ecnh ho\u1eb7c h\u00ecnh minh h\u1ecda nh\u01b0 h\u00ecnh d\u01b0\u1edbi, h\u00e3y \u01b0u ti\u00ean hi\u1ec3u h\u00ecnh, v\u0103n b\u1ea3n ch\u1ec9 \u0111\u1ec3 b\u1ed5 sung, k\u1ebft h\u1ee3p c\u1ea3 hai \u0111\u1ec3 hi\u1ec3u to\u00e0n di\u1ec7n.</p> <p></p>"},{"location":"chapter_preface/suggestions/#hieu-sau-hon-qua-thuc-hanh-lap-trinh","title":"Hi\u1ec3u s\u00e2u h\u01a1n qua th\u1ef1c h\u00e0nh l\u1eadp tr\u00ecnh","text":"<p>M\u00e3 ngu\u1ed3n c\u1ee7a s\u00e1ch \u0111\u01b0\u1ee3c l\u01b0u tr\u1eef t\u1ea1i GitHub Repository. Nh\u01b0 h\u00ecnh d\u01b0\u1edbi, m\u00e3 ngu\u1ed3n c\u00f3 s\u1eb5n v\u00ed d\u1ee5 ki\u1ec3m th\u1eed v\u00e0 c\u00f3 th\u1ec3 ch\u1ea1y ch\u1ec9 v\u1edbi m\u1ed9t c\u00fa nh\u1ea5p chu\u1ed9t.</p> <p>N\u1ebfu c\u00f3 th\u1eddi gian, b\u1ea1n n\u00ean t\u1ef1 g\u00f5 l\u1ea1i m\u00e3 ngu\u1ed3n. N\u1ebfu kh\u00f4ng c\u00f3 nhi\u1ec1u th\u1eddi gian, \u00edt nh\u1ea5t h\u00e3y \u0111\u1ecdc v\u00e0 ch\u1ea1y t\u1ea5t c\u1ea3 c\u00e1c \u0111o\u1ea1n m\u00e3.</p> <p>So v\u1edbi ch\u1ec9 \u0111\u1ecdc m\u00e3, vi\u1ec7c t\u1ef1 vi\u1ebft m\u00e3 s\u1ebd gi\u00fap b\u1ea1n h\u1ecdc \u0111\u01b0\u1ee3c nhi\u1ec1u h\u01a1n. H\u1ecdc b\u1eb1ng c\u00e1ch l\u00e0m l\u00e0 c\u00e1ch h\u1ecdc th\u1ef1c s\u1ef1.</p> <p></p> <p>Thi\u1ebft l\u1eadp \u0111\u1ec3 ch\u1ea1y m\u00e3 ngu\u1ed3n g\u1ed3m ba b\u01b0\u1edbc ch\u00ednh.</p> <p>B\u01b0\u1edbc 1: C\u00e0i \u0111\u1eb7t m\u00f4i tr\u01b0\u1eddng l\u1eadp tr\u00ecnh tr\u00ean m\u00e1y. L\u00e0m theo h\u01b0\u1edbng d\u1eabn \u1edf ph\u1ea7n ph\u1ee5 l\u1ee5c \u0111\u1ec3 c\u00e0i \u0111\u1eb7t, ho\u1eb7c b\u1ecf qua n\u1ebfu \u0111\u00e3 c\u00e0i r\u1ed3i.</p> <p>B\u01b0\u1edbc 2: T\u1ea3i v\u1ec1 ho\u1eb7c sao ch\u00e9p kho m\u00e3 ngu\u1ed3n. Truy c\u1eadp GitHub Repository.</p> <p>N\u1ebfu \u0111\u00e3 c\u00e0i Git, d\u00f9ng l\u1ec7nh sau \u0111\u1ec3 sao ch\u00e9p kho m\u00e3:</p> <pre><code>git clone https://github.com/krahets/hello-algo.git\n</code></pre> <p>Ho\u1eb7c b\u1ea1n c\u0169ng c\u00f3 th\u1ec3 nh\u1ea5n n\u00fat \"Download ZIP\" nh\u01b0 h\u00ecnh d\u01b0\u1edbi \u0111\u1ec3 t\u1ea3i m\u00e3 ngu\u1ed3n v\u1ec1 d\u01b0\u1edbi d\u1ea1ng file ZIP n\u00e9n. Sau \u0111\u00f3 ch\u1ec9 c\u1ea7n gi\u1ea3i n\u00e9n ra m\u00e1y t\u00ednh.</p> <p></p> <p>B\u01b0\u1edbc 3: Ch\u1ea1y m\u00e3 ngu\u1ed3n. Nh\u01b0 h\u00ecnh d\u01b0\u1edbi, v\u1edbi kh\u1ed1i m\u00e3 c\u00f3 t\u00ean file \u1edf \u0111\u1ea7u, b\u1ea1n c\u00f3 th\u1ec3 t\u00ecm file m\u00e3 ngu\u1ed3n t\u01b0\u01a1ng \u1ee9ng trong th\u01b0 m\u1ee5c <code>codes</code> c\u1ee7a kho m\u00e3. C\u00e1c file n\u00e0y c\u00f3 th\u1ec3 ch\u1ea1y ch\u1ec9 v\u1edbi m\u1ed9t c\u00fa nh\u1ea5p chu\u1ed9t, gi\u00fap b\u1ea1n ti\u1ebft ki\u1ec7m th\u1eddi gian s\u1eeda l\u1ed7i v\u00e0 t\u1eadp trung v\u00e0o vi\u1ec7c h\u1ecdc.</p> <p></p>"},{"location":"chapter_preface/suggestions/#hoc-cung-nhau-qua-thao-luan","title":"H\u1ecdc c\u00f9ng nhau qua th\u1ea3o lu\u1eadn","text":"<p>Khi \u0111\u1ecdc s\u00e1ch, \u0111\u1eebng b\u1ecf qua nh\u1eefng \u0111i\u1ec3m b\u1ea1n ch\u01b0a hi\u1ec3u. H\u00e3y tho\u1ea3i m\u00e1i \u0111\u1eb7t c\u00e2u h\u1ecfi \u1edf ph\u1ea7n b\u00ecnh lu\u1eadn. Ch\u00fang t\u00f4i r\u1ea5t s\u1eb5n l\u00f2ng tr\u1ea3 l\u1eddi v\u00e0 th\u01b0\u1eddng ph\u1ea3n h\u1ed3i trong v\u00f2ng hai ng\u00e0y.</p> <p>Nh\u01b0 h\u00ecnh d\u01b0\u1edbi, m\u1ed7i ch\u01b0\u01a1ng \u0111\u1ec1u c\u00f3 ph\u1ea7n b\u00ecnh lu\u1eadn \u1edf cu\u1ed1i. H\u00e3y ch\u00fa \u00fd \u0111\u1ebfn c\u00e1c b\u00ecnh lu\u1eadn n\u00e0y. Ch\u00fang kh\u00f4ng ch\u1ec9 gi\u00fap b\u1ea1n bi\u1ebft th\u00eam c\u00e1c v\u1ea5n \u0111\u1ec1 m\u00e0 ng\u01b0\u1eddi kh\u00e1c g\u1eb7p ph\u1ea3i, gi\u00fap ph\u00e1t hi\u1ec7n l\u1ed7 h\u1ed5ng ki\u1ebfn th\u1ee9c v\u00e0 suy ngh\u0129 s\u00e2u h\u01a1n, m\u00e0 c\u00f2n l\u00e0 n\u01a1i b\u1ea1n c\u00f3 th\u1ec3 \u0111\u00f3ng g\u00f3p b\u1eb1ng c\u00e1ch tr\u1ea3 l\u1eddi c\u00e2u h\u1ecfi, chia s\u1ebb kinh nghi\u1ec7m v\u00e0 c\u00f9ng nhau ti\u1ebfn b\u1ed9.</p> <p></p>"},{"location":"chapter_preface/suggestions/#lo-trinh-hoc-thuat-toan","title":"L\u1ed9 tr\u00ecnh h\u1ecdc thu\u1eadt to\u00e1n","text":"<p>Nh\u00ecn chung, qu\u00e1 tr\u00ecnh l\u00e0m ch\u1ee7 c\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 thu\u1eadt to\u00e1n c\u00f3 th\u1ec3 chia th\u00e0nh ba giai \u0111o\u1ea1n:</p> <ol> <li>Giai \u0111o\u1ea1n 1: Nh\u1eadp m\u00f4n thu\u1eadt to\u00e1n. B\u1ea1n c\u1ea7n l\u00e0m quen v\u1edbi \u0111\u1eb7c \u0111i\u1ec3m v\u00e0 c\u00e1ch d\u00f9ng c\u00e1c c\u1ea5u tr\u00fac d\u1eef li\u1ec7u, t\u00ecm hi\u1ec3u nguy\u00ean l\u00fd, quy tr\u00ecnh, \u1ee9ng d\u1ee5ng v\u00e0 hi\u1ec7u qu\u1ea3 c\u1ee7a c\u00e1c thu\u1eadt to\u00e1n kh\u00e1c nhau.</li> <li>Giai \u0111o\u1ea1n 2: Luy\u1ec7n t\u1eadp gi\u1ea3i b\u00e0i thu\u1eadt to\u00e1n. N\u00ean b\u1eaft \u0111\u1ea7u t\u1eeb c\u00e1c b\u00e0i ph\u1ed5 bi\u1ebfn nh\u01b0 Sword for Offer v\u00e0 LeetCode Hot 100, t\u00edch l\u0169y \u00edt nh\u1ea5t 100 b\u00e0i \u0111\u1ec3 quen v\u1edbi c\u00e1c d\u1ea1ng b\u00e0i thu\u1eadt to\u00e1n ch\u00ednh. Khi m\u1edbi luy\u1ec7n t\u1eadp, b\u1ea1n c\u00f3 th\u1ec3 hay qu\u00ean, nh\u01b0ng \u0111\u00f3 l\u00e0 \u0111i\u1ec1u b\u00ecnh th\u01b0\u1eddng. H\u00e3y \u00f4n l\u1ea1i theo \"\u0110\u01b0\u1eddng cong qu\u00ean l\u00e3ng Ebbinghaus\", th\u01b0\u1eddng sau 3~5 l\u1ea7n l\u1eb7p l\u1ea1i s\u1ebd nh\u1edb \u0111\u01b0\u1ee3c.</li> <li>Giai \u0111o\u1ea1n 3: X\u00e2y d\u1ef1ng h\u1ec7 th\u1ed1ng ki\u1ebfn th\u1ee9c. V\u1ec1 h\u1ecdc l\u00fd thuy\u1ebft, b\u1ea1n c\u00f3 th\u1ec3 \u0111\u1ecdc c\u00e1c b\u00e0i vi\u1ebft chuy\u00ean \u0111\u1ec1, khung gi\u1ea3i ph\u00e1p, s\u00e1ch gi\u00e1o tr\u00ecnh \u0111\u1ec3 l\u00e0m gi\u00e0u h\u1ec7 th\u1ed1ng ki\u1ebfn th\u1ee9c. V\u1ec1 luy\u1ec7n t\u1eadp, b\u1ea1n c\u00f3 th\u1ec3 th\u1eed c\u00e1c chi\u1ebfn l\u01b0\u1ee3c n\u00e2ng cao nh\u01b0 ph\u00e2n lo\u1ea1i theo ch\u1ee7 \u0111\u1ec1, nhi\u1ec1u c\u00e1ch gi\u1ea3i cho m\u1ed9t b\u00e0i, ho\u1eb7c m\u1ed9t c\u00e1ch gi\u1ea3i cho nhi\u1ec1u b\u00e0i, v.v. C\u00f3 th\u1ec3 t\u00ecm hi\u1ec3u th\u00eam c\u00e1c chi\u1ebfn l\u01b0\u1ee3c n\u00e0y trong c\u00e1c c\u1ed9ng \u0111\u1ed3ng.</li> </ol> <p>Nh\u01b0 h\u00ecnh d\u01b0\u1edbi, s\u00e1ch n\u00e0y ch\u1ee7 y\u1ebfu bao qu\u00e1t \u201cGiai \u0111o\u1ea1n 1\u201d, gi\u00fap b\u1ea1n b\u1eaft \u0111\u1ea7u hi\u1ec7u qu\u1ea3 h\u01a1n cho Giai \u0111o\u1ea1n 2 v\u00e0 3.</p> <p></p>"},{"location":"chapter_preface/summary/","title":"0.3 Summary","text":""},{"location":"chapter_preface/summary/#tom-tat","title":"T\u00f3m t\u1eaft","text":"<ul> <li>\u0110\u1ed1i t\u01b0\u1ee3ng ch\u00ednh c\u1ee7a cu\u1ed1n s\u00e1ch n\u00e0y l\u00e0 nh\u1eefng ng\u01b0\u1eddi m\u1edbi b\u1eaft \u0111\u1ea7u h\u1ecdc thu\u1eadt to\u00e1n. N\u1ebfu b\u1ea1n \u0111\u00e3 c\u00f3 m\u1ed9t s\u1ed1 ki\u1ebfn th\u1ee9c c\u01a1 b\u1ea3n, cu\u1ed1n s\u00e1ch n\u00e0y c\u00f3 th\u1ec3 gi\u00fap b\u1ea1n xem l\u1ea1i h\u1ec7 th\u1ed1ng ki\u1ebfn th\u1ee9c thu\u1eadt to\u00e1n c\u1ee7a m\u00ecnh, v\u00e0 m\u00e3 ngu\u1ed3n trong cu\u1ed1n s\u00e1ch c\u0169ng c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng nh\u01b0 m\u1ed9t \"B\u1ed9 c\u00f4ng c\u1ee5 l\u1eadp tr\u00ecnh\".</li> <li>Cu\u1ed1n s\u00e1ch bao g\u1ed3m ba ph\u1ea7n ch\u00ednh: Ph\u00e2n t\u00edch \u0111\u1ed9 ph\u1ee9c t\u1ea1p, C\u1ea5u tr\u00fac d\u1eef li\u1ec7u v\u00e0 Thu\u1eadt to\u00e1n, bao g\u1ed3m h\u1ea7u h\u1ebft c\u00e1c ch\u1ee7 \u0111\u1ec1 trong l\u0129nh v\u1ef1c n\u00e0y.</li> <li>\u0110\u1ed1i v\u1edbi nh\u1eefng ng\u01b0\u1eddi m\u1edbi \u0111\u1ebfn v\u1edbi thu\u1eadt to\u00e1n, vi\u1ec7c \u0111\u1ecdc m\u1ed9t cu\u1ed1n s\u00e1ch gi\u1edbi thi\u1ec7u \u1edf giai \u0111o\u1ea1n \u0111\u1ea7u l\u00e0 r\u1ea5t quan tr\u1ecdng \u0111\u1ec3 tr\u00e1nh nhi\u1ec1u v\u00f2ng vo ho\u1eb7c nh\u1eefng sai l\u1ea7m ph\u1ed5 bi\u1ebfn.</li> <li>C\u00e1c h\u00ecnh \u1ea3nh \u0111\u1ed9ng v\u00e0 h\u00ecnh \u1ea3nh trong cu\u1ed1n s\u00e1ch th\u01b0\u1eddng \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng \u0111\u1ec3 gi\u1edbi thi\u1ec7u c\u00e1c \u0111i\u1ec3m ch\u00ednh v\u00e0 ki\u1ebfn th\u1ee9c kh\u00f3. Nh\u1eefng ph\u1ea7n n\u00e0y n\u00ean \u0111\u01b0\u1ee3c ch\u00fa \u00fd nhi\u1ec1u h\u01a1n khi \u0111\u1ecdc cu\u1ed1n s\u00e1ch.</li> <li>Th\u1ef1c h\u00e0nh l\u00e0 c\u00e1ch t\u1ed1t nh\u1ea5t \u0111\u1ec3 h\u1ecdc l\u1eadp tr\u00ecnh. B\u1ea1n n\u00ean ch\u1ea1y m\u00e3 ngu\u1ed3n v\u00e0 t\u1ef1 g\u00f5 m\u00e3.</li> <li>M\u1ed7i ch\u01b0\u01a1ng trong phi\u00ean b\u1ea3n web c\u1ee7a cu\u1ed1n s\u00e1ch c\u00f3 m\u1ed9t ph\u1ea7n th\u1ea3o lu\u1eadn, v\u00e0 b\u1ea1n \u0111\u01b0\u1ee3c ch\u00e0o \u0111\u00f3n chia s\u1ebb c\u00e2u h\u1ecfi v\u00e0 hi\u1ec3u bi\u1ebft c\u1ee7a m\u00ecnh b\u1ea5t c\u1ee9 l\u00fac n\u00e0o.</li> </ul>"},{"location":"chapter_reference/","title":"References","text":""},{"location":"chapter_reference/#references","title":"References","text":"<p>[1] Thomas H. Cormen, et al. Introduction to Algorithms (3<sup>rd</sup> Edition).</p> <p>[2] Aditya Bhargava. Grokking Algorithms: An Illustrated Guide for Programmers and Other Curious People (1<sup>st</sup> Edition).</p> <p>[3] Robert Sedgewick, et al. Algorithms (4<sup>th</sup> Edition).</p> <p>[4] Yan Weimin. Data Structures (C Language Version).</p> <p>[5] Deng Junhui. Data Structures (C++ Language Version, Third Edition).</p> <p>[6] Mark Allen Weiss, translated by Chen Yue. Data Structures and Algorithm Analysis in Java (Third Edition).</p> <p>[7] Cheng Jie. Speaking of Data Structures.</p> <p>[8] Wang Zheng. The Beauty of Data Structures and Algorithms.</p> <p>[9] Gayle Laakmann McDowell. Cracking the Coding Interview: 189 Programming Questions and Solutions (6<sup>th</sup> Edition).</p> <p>[10] Aston Zhang, et al. Dive into Deep Learning.</p>"},{"location":"chapter_searching/","title":"Searching","text":""},{"location":"chapter_searching/#searching","title":"Searching","text":"<p>Abstract</p> <p>Searching is an adventure into the unknown; where we may need to traverse every corner of a mysterious space, or perhaps we\u2019ll quickly locate our target.</p> <p>On this journey of discovery, each exploration may end up with an unexpected answer.</p>"},{"location":"chapter_searching/binary_search/","title":"10.1 Binary search","text":""},{"location":"chapter_searching/binary_search/#binary-search","title":"Binary search","text":"<p>Binary search is an efficient search algorithm that uses a divide-and-conquer strategy. It takes advantage of the sorted order of elements in an array by reducing the search interval by half in each iteration, continuing until either the target element is found or the search interval becomes empty.</p> <p>Question</p> <p>Given an array <code>nums</code> of length \\(n\\), where elements are arranged in ascending order without duplicates. Please find and return the index of element <code>target</code> in this array. If the array does not contain the element, return \\(-1\\). An example is shown in the figure below.</p> <p></p> <p>As shown in the figure below, we firstly initialize pointers with \\(i = 0\\) and \\(j = n - 1\\), pointing to the first and last element of the array respectively. They also represent the whole search interval \\([0, n - 1]\\). Please note that square brackets indicate a closed interval, which includes the boundary values themselves.</p> <p>And then the following two steps may be performed in a loop.</p> <ol> <li>Calculate the midpoint index \\(m = \\lfloor {(i + j) / 2} \\rfloor\\), where \\(\\lfloor \\: \\rfloor\\) denotes the floor operation.</li> <li>Based on the comparison between the value of <code>nums[m]</code> and <code>target</code>, one of the following three cases will be chosen to execute.<ol> <li>If <code>nums[m] &lt; target</code>, it indicates that <code>target</code> is in the interval \\([m + 1, j]\\), thus set \\(i = m + 1\\).</li> <li>If <code>nums[m] &gt; target</code>, it indicates that <code>target</code> is in the interval \\([i, m - 1]\\), thus set \\(j = m - 1\\).</li> <li>If <code>nums[m] = target</code>, it indicates that <code>target</code> is found, thus return index \\(m\\).</li> </ol> </li> </ol> <p>If the array does not contain the target element, the search interval will eventually reduce to empty, ending up returning \\(-1\\).</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>It's worth noting that as \\(i\\) and \\(j\\) are both of type <code>int</code>, \\(i + j\\) might exceed the range of <code>int</code> type. To avoid large number overflow, we usually use the formula \\(m = \\lfloor {i + (j - i) / 2} \\rfloor\\) to calculate the midpoint.</p> <p>The code is as follows:</p> <pre><code>[file]{binary_search}-[class]{}-[func]{binary_search}\n</code></pre> <p>Time complexity is \\(O(\\log n)\\) : In the binary loop, the interval decreases by half each round, hence the number of iterations is \\(\\log_2 n\\).</p> <p>Space complexity is \\(O(1)\\) : Pointers \\(i\\) and \\(j\\) occupies constant size of space.</p>"},{"location":"chapter_searching/binary_search/#interval-representation-methods","title":"Interval representation methods","text":"<p>Besides the above closed interval, another common interval representation is the \"left-closed right-open\" interval, defined as \\([0, n)\\), where the left boundary includes itself, and the right boundary does not. In this representation, the interval \\([i, j)\\) is empty when \\(i = j\\).</p> <p>We can implement a binary search algorithm with the same functionality based on this representation:</p> <pre><code>[file]{binary_search}-[class]{}-[func]{binary_search_lcro}\n</code></pre> <p>As shown in the figure below, under the two types of interval representations, the initialization, loop condition, and narrowing interval operation of the binary search algorithm differ.</p> <p>Since both boundaries in the \"closed interval\" representation are inclusive, the operations to narrow the interval through pointers \\(i\\) and \\(j\\) are also symmetrical. This makes it less prone to errors, therefore, it is generally recommended to use the \"closed interval\" approach.</p> <p></p>"},{"location":"chapter_searching/binary_search/#advantages-and-limitations","title":"Advantages and limitations","text":"<p>Binary search performs well in both time and space aspects.</p> <ul> <li>Binary search is time-efficient. With large dataset, the logarithmic time complexity offers a major advantage. For instance, given a dataset with size \\(n = 2^{20}\\), linear search requires \\(2^{20} = 1048576\\) iterations, while binary search only demands \\(\\log_2 2^{20} = 20\\) loops.</li> <li>Binary search does not need extra space. Compared to search algorithms that rely on additional space (like hash search), binary search is more space-efficient.</li> </ul> <p>However, binary search may not be suitable for all scenarios due to the following concerns.</p> <ul> <li>Binary search can only be applied to sorted data. Unsorted data must be sorted before applying binary search, which may not be worthwhile as sorting algorithm typically has a time complexity of \\(O(n \\log n)\\). Such cost is even higher than linear search, not to mention binary search itself. For scenarios with frequent insertion, the cost of remaining the array in order is pretty high as the time complexity of inserting new elements into specific positions is \\(O(n)\\).</li> <li>Binary search may use array only. Binary search requires non-continuous (jumping) element access, which is inefficient in linked list. As a result, linked list or data structures based on linked list may not be suitable for this algorithm.</li> <li>Linear search performs better on small dataset. In linear search, only 1 decision operation is required for each iteration; whereas in binary search, it involves 1 addition, 1 division, 1 to 3 decision operations, 1 addition (subtraction), totaling 4 to 6 operations. Therefore, if data size \\(n\\) is small, linear search is faster than binary search.</li> </ul>"},{"location":"chapter_searching/binary_search_edge/","title":"10.3 Binary search boundaries","text":""},{"location":"chapter_searching/binary_search_edge/#binary-search-boundaries","title":"Binary search boundaries","text":""},{"location":"chapter_searching/binary_search_edge/#find-the-left-boundary","title":"Find the left boundary","text":"<p>Question</p> <p>Given a sorted array <code>nums</code> of length \\(n\\), which may contain duplicate elements, return the index of the leftmost element <code>target</code>. If the element is not present in the array, return \\(-1\\).</p> <p>Recalling the method of binary search for an insertion point, after the search is completed, the index \\(i\\) will point to the leftmost occurrence of <code>target</code>. Therefore, searching for the insertion point is essentially the same as finding the index of the leftmost <code>target</code>.</p> <p>We can use the function for finding an insertion point to find the left boundary of <code>target</code>. Note that the array might not contain <code>target</code>, which could lead to the following two results:</p> <ul> <li>The index \\(i\\) of the insertion point is out of bounds.</li> <li>The element <code>nums[i]</code> is not equal to <code>target</code>.</li> </ul> <p>In these cases, simply return \\(-1\\). The code is as follows:</p> <pre><code>[file]{binary_search_edge}-[class]{}-[func]{binary_search_left_edge}\n</code></pre>"},{"location":"chapter_searching/binary_search_edge/#find-the-right-boundary","title":"Find the right boundary","text":"<p>How do we find the rightmost occurrence of <code>target</code>? The most straightforward way is to modify the traditional binary search logic by changing how we adjust the search boundaries in the case of <code>nums[m] == target</code>. The code is omitted here. If you are interested, try to implement the code on your own.</p> <p>Below we are going to introduce two more ingenious methods.</p>"},{"location":"chapter_searching/binary_search_edge/#reuse-the-left-boundary-search","title":"Reuse the left boundary search","text":"<p>To find the rightmost occurrence of <code>target</code>, we can reuse the function used for locating the leftmost <code>target</code>. Specifically, we transform the search for the rightmost target into a search for the leftmost target + 1.</p> <p>As shown in the figure below, after the search is complete, pointer \\(i\\) will point to the leftmost <code>target + 1</code> (if exists), while pointer \\(j\\) will point to the rightmost occurrence of <code>target</code>. Therefore, returning \\(j\\) will give us the right boundary.</p> <p></p> <p>Note that the insertion point returned is \\(i\\), therefore, it should be subtracted by \\(1\\) to obtain \\(j\\):</p> <pre><code>[file]{binary_search_edge}-[class]{}-[func]{binary_search_right_edge}\n</code></pre>"},{"location":"chapter_searching/binary_search_edge/#transform-into-an-element-search","title":"Transform into an element search","text":"<p>When the array does not contain <code>target</code>, \\(i\\) and \\(j\\) will eventually point to the first element greater and smaller than <code>target</code> respectively.</p> <p>Thus, as shown in the figure below, we can construct an element that does not exist in the array, to search for the left and right boundaries.</p> <ul> <li>To find the leftmost <code>target</code>: it can be transformed into searching for <code>target - 0.5</code>, and return the pointer \\(i\\).</li> <li>To find the rightmost <code>target</code>: it can be transformed into searching for <code>target + 0.5</code>, and return the pointer \\(j\\).</li> </ul> <p></p> <p>The code is omitted here, but here are two important points to note about this approach.</p> <ul> <li>The given array <code>nums</code> does not contain decimal, so handling equal cases is not a concern.</li> <li>However, introducing decimals in this approach requires modifying the <code>target</code> variable to a floating-point type (no change needed in Python).</li> </ul>"},{"location":"chapter_searching/binary_search_insertion/","title":"10.2 Binary search insertion","text":""},{"location":"chapter_searching/binary_search_insertion/#binary-search-insertion","title":"Binary search insertion","text":"<p>Binary search is not only used to search for target elements but also to solve many variant problems, such as searching for the insertion position of target elements.</p>"},{"location":"chapter_searching/binary_search_insertion/#case-with-no-duplicate-elements","title":"Case with no duplicate elements","text":"<p>Question</p> <p>Given a sorted array <code>nums</code> of length \\(n\\) with unique elements and an element <code>target</code>, insert <code>target</code> into <code>nums</code> while maintaining its sorted order. If <code>target</code> already exists in the array, insert it to the left of the existing element. Return the index of <code>target</code> in the array after insertion. See the example shown in the figure below.</p> <p></p> <p>If you want to reuse the binary search code from the previous section, you need to answer the following two questions.</p> <p>Question one: If the array already contains <code>target</code>, would the insertion point be the index of existing element?</p> <p>The requirement to insert <code>target</code> to the left of equal elements means that the newly inserted <code>target</code> will replace the original <code>target</code> position. In other words, when the array contains <code>target</code>, the insertion point is indeed the index of that <code>target</code>.</p> <p>Question two: When the array does not contain <code>target</code>, at which index would it be inserted?</p> <p>Let's further consider the binary search process: when <code>nums[m] &lt; target</code>, pointer \\(i\\) moves, meaning that pointer \\(i\\) is approaching an element greater than or equal to <code>target</code>. Similarly, pointer \\(j\\) is always approaching an element less than or equal to <code>target</code>.</p> <p>Therefore, at the end of the binary, it is certain that: \\(i\\) points to the first element greater than <code>target</code>, and \\(j\\) points to the first element less than <code>target</code>. It is easy to see that when the array does not contain <code>target</code>, the insertion point is \\(i\\). The code is as follows:</p> <pre><code>[file]{binary_search_insertion}-[class]{}-[func]{binary_search_insertion_simple}\n</code></pre>"},{"location":"chapter_searching/binary_search_insertion/#case-with-duplicate-elements","title":"Case with duplicate elements","text":"<p>Question</p> <p>Based on the previous question, assume the array may contain duplicate elements, all else remains the same.</p> <p>When there are multiple occurrences of <code>target</code> in the array, a regular binary search can only return the index of one occurrence of <code>target</code>, and it cannot determine how many occurrences of <code>target</code> are to the left and right of that position.</p> <p>The problem requires inserting the target element at the leftmost position, so we need to find the index of the leftmost <code>target</code> in the array. Initially consider implementing this through the steps shown in the figure below.</p> <ol> <li>Perform a binary search to find any index of <code>target</code>, say \\(k\\).</li> <li>Starting from index \\(k\\), conduct a linear search to the left until the leftmost occurrence of <code>target</code> is found, then return this index.</li> </ol> <p></p> <p>Although this method is feasible, it includes linear search, so its time complexity is \\(O(n)\\). This method is inefficient when the array contains many duplicate <code>target</code>s.</p> <p>Now consider extending the binary search code. As shown in the figure below, the overall process remains the same. In each round, we first calculate the middle index \\(m\\), then compare the value of <code>target</code> with <code>nums[m]</code>, leading to the following cases.</p> <ul> <li>When <code>nums[m] &lt; target</code> or <code>nums[m] &gt; target</code>, it means <code>target</code> has not been found yet, thus use the normal binary search to narrow the search range, bringing pointers \\(i\\) and \\(j\\) closer to <code>target</code>.</li> <li>When <code>nums[m] == target</code>, it indicates that the elements less than <code>target</code> are in the range \\([i, m - 1]\\), therefore use \\(j = m - 1\\) to narrow the range, thus bringing pointer \\(j\\) closer to the elements less than <code>target</code>.</li> </ul> <p>After the loop, \\(i\\) points to the leftmost <code>target</code>, and \\(j\\) points to the first element less than <code>target</code>, therefore index \\(i\\) is the insertion point.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>Observe the following code. The operations in the branches <code>nums[m] &gt; target</code> and <code>nums[m] == target</code> are the same, so these two branches can be merged.</p> <p>Even so, we can still keep the conditions expanded, as it makes the logic clearer and improves readability.</p> <pre><code>[file]{binary_search_insertion}-[class]{}-[func]{binary_search_insertion}\n</code></pre> <p>Tip</p> <p>The code in this section uses \"closed interval\". If you are interested in \"left-closed, right-open\", try to implement the code on your own.</p> <p>In summary, binary search essentially involves setting search targets for pointers \\(i\\) and \\(j\\). These targets could be a specific element (like <code>target</code>) or a range of elements (such as those smaller than <code>target</code>).</p> <p>In the continuous loop of binary search, pointers \\(i\\) and \\(j\\) gradually approach the predefined target. Ultimately, they either find the answer or stop after crossing the boundary.</p>"},{"location":"chapter_searching/replace_linear_by_hashing/","title":"10.4 Hashing optimization strategies","text":""},{"location":"chapter_searching/replace_linear_by_hashing/#hash-optimization-strategies","title":"Hash optimization strategies","text":"<p>In algorithm problems, we often reduce the time complexity of an algorithm by replacing a linear search with a hash-based search. Let's use an algorithm problem to deepen the understanding.</p> <p>Question</p> <p>Given an integer array <code>nums</code> and a target element <code>target</code>, please search for two elements in the array whose \"sum\" equals <code>target</code>, and return their array indices. Any solution is acceptable.</p>"},{"location":"chapter_searching/replace_linear_by_hashing/#linear-search-trading-time-for-space","title":"Linear search: trading time for space","text":"<p>Consider traversing through all possible combinations directly. As shown in the figure below, we initiate a nested loop, and in each iteration, we determine whether the sum of the two integers equals <code>target</code>. If so, we return their indices.</p> <p></p> <p>The code is shown below:</p> <pre><code>[file]{two_sum}-[class]{}-[func]{two_sum_brute_force}\n</code></pre> <p>This method has a time complexity of \\(O(n^2)\\) and a space complexity of \\(O(1)\\), which can be very time-consuming with large data volumes.</p>"},{"location":"chapter_searching/replace_linear_by_hashing/#hash-search-trading-space-for-time","title":"Hash search: trading space for time","text":"<p>Consider using a hash table, where the key-value pairs are the array elements and their indices, respectively. Loop through the array, performing the steps shown in the figure below during each iteration.</p> <ol> <li>Check if the number <code>target - nums[i]</code> is in the hash table. If so, directly return the indices of these two elements.</li> <li>Add the key-value pair <code>nums[i]</code> and index <code>i</code> to the hash table.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt; <p></p> <p></p> <p></p> <p>The implementation code is shown below, requiring only a single loop:</p> <pre><code>[file]{two_sum}-[class]{}-[func]{two_sum_hash_table}\n</code></pre> <p>This method reduces the time complexity from \\(O(n^2)\\) to \\(O(n)\\) by using hash search, significantly enhancing runtime efficiency.</p> <p>As it requires maintaining an additional hash table, the space complexity is \\(O(n)\\). Nevertheless, this method has a more balanced time-space efficiency overall, making it the optimal solution for this problem.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/","title":"10.5 Search algorithms revisited","text":""},{"location":"chapter_searching/searching_algorithm_revisited/#search-algorithms-revisited","title":"Search algorithms revisited","text":"<p>Searching algorithms (search algorithms) are used to retrieve one or more elements that meet specific criteria within data structures such as arrays, linked lists, trees, or graphs.</p> <p>Searching algorithms can be divided into the following two categories based on their approach.</p> <ul> <li>Locating the target element by traversing the data structure, such as traversals of arrays, linked lists, trees, and graphs, etc.</li> <li>Using the organizational structure of the data or existing data to achieve efficient element searches, such as binary search, hash search, binary search tree search, etc.</li> </ul> <p>These topics were introduced in previous chapters, so they are not unfamiliar to us. In this section, we will revisit searching algorithms from a more systematic perspective.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/#brute-force-search","title":"Brute-force search","text":"<p>A Brute-force search locates the target element by traversing every element of the data structure.</p> <ul> <li>\"Linear search\" is suitable for linear data structures such as arrays and linked lists. It starts from one end of the data structure and accesses each element one by one until the target element is found or the other end is reached without finding the target element.</li> <li>\"Breadth-first search\" and \"Depth-first search\" are two traversal strategies for graphs and trees. Breadth-first search starts from the initial node and searches layer by layer (left to right), accessing nodes from near to far. Depth-first search starts from the initial node, follows a path until the end (top to bottom), then backtracks and tries other paths until the entire data structure is traversed.</li> </ul> <p>The advantage of brute-force search is its simplicity and versatility, no need for data preprocessing or the help of additional data structures.</p> <p>However, the time complexity of this type of algorithm is \\(O(n)\\), where \\(n\\) is the number of elements, so the performance is poor with large data sets.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/#adaptive-search","title":"Adaptive search","text":"<p>An Adaptive search uses the unique properties of data (such as order) to optimize the search process, thereby locating the target element more efficiently.</p> <ul> <li>\"Binary search\" uses the orderliness of data to achieve efficient searching, only suitable for arrays.</li> <li>\"Hash search\" uses a hash table to establish a key-value mapping between search data and target data, thus implementing the query operation.</li> <li>\"Tree search\" in a specific tree structure (such as a binary search tree), quickly eliminates nodes based on node value comparisons, thus locating the target element.</li> </ul> <p>The advantage of these algorithms is high efficiency, with time complexities reaching \\(O(\\log n)\\) or even \\(O(1)\\).</p> <p>However, using these algorithms often requires data preprocessing. For example, binary search requires sorting the array in advance, and hash search and tree search both require the help of additional data structures. Maintaining these structures also requires more overhead in terms of time and space.</p> <p>Tip</p> <p>Adaptive search algorithms are often referred to as search algorithms, mainly used for quickly retrieving target elements in specific data structures.</p>"},{"location":"chapter_searching/searching_algorithm_revisited/#choosing-a-search-method","title":"Choosing a search method","text":"<p>Given a set of data of size \\(n\\), we can use a linear search, binary search, tree search, hash search, or other methods to retrieve the target element. The working principles of these methods are shown in the figure below.</p> <p></p> <p>The characteristics and operational efficiency of the aforementioned methods are shown in the following table.</p> <p> Table  \u00a0 Comparison of search algorithm efficiency </p> Linear search Binary search Tree search Hash search Search element \\(O(n)\\) \\(O(\\log n)\\) \\(O(\\log n)\\) \\(O(1)\\) Insert element \\(O(1)\\) \\(O(n)\\) \\(O(\\log n)\\) \\(O(1)\\) Delete element \\(O(n)\\) \\(O(n)\\) \\(O(\\log n)\\) \\(O(1)\\) Extra space \\(O(1)\\) \\(O(1)\\) \\(O(n)\\) \\(O(n)\\) Data preprocessing / Sorting \\(O(n \\log n)\\) Building tree \\(O(n \\log n)\\) Building hash table \\(O(n)\\) Data orderliness Unordered Ordered Ordered Unordered <p>The choice of search algorithm also depends on the volume of data, search performance requirements, frequency of data queries and updates, etc.</p> <p>Linear search</p> <ul> <li>Good versatility, no need for any data preprocessing operations. If we only need to query the data once, then the time for data preprocessing in the other three methods would be longer than the time for a linear search.</li> <li>Suitable for small volumes of data, where time complexity has a smaller impact on efficiency.</li> <li>Suitable for scenarios with very frequent data updates, because this method does not require any additional maintenance of the data.</li> </ul> <p>Binary search</p> <ul> <li>Suitable for larger data volumes, with stable performance and a worst-case time complexity of \\(O(\\log n)\\).</li> <li>However, the data volume cannot be too large, because storing arrays requires contiguous memory space.</li> <li>Not suitable for scenarios with frequent additions and deletions, because maintaining an ordered array incurs a lot of overhead.</li> </ul> <p>Hash search</p> <ul> <li>Suitable for scenarios where fast query performance is essential, with an average time complexity of \\(O(1)\\).</li> <li>Not suitable for scenarios needing ordered data or range searches, because hash tables cannot maintain data orderliness.</li> <li>High dependency on hash functions and hash collision handling strategies, with significant performance degradation risks.</li> <li>Not suitable for overly large data volumes, because hash tables need extra space to minimize collisions and provide good query performance.</li> </ul> <p>Tree search</p> <ul> <li>Suitable for massive data, because tree nodes are stored scattered in memory.</li> <li>Suitable for maintaining ordered data or range searches.</li> <li>With the continuous addition and deletion of nodes, the binary search tree may become skewed, degrading the time complexity to \\(O(n)\\).</li> <li>If using AVL trees or red-black trees, operations can run stably at \\(O(\\log n)\\) efficiency, but the operation to maintain tree balance adds extra overhead.</li> </ul>"},{"location":"chapter_searching/summary/","title":"10.6 Summary","text":""},{"location":"chapter_searching/summary/#summary","title":"Summary","text":"<ul> <li>Binary search depends on the order of data and performs the search by iteratively halving the search interval. It requires the input data to be sorted and is only applicable to arrays or array-based data structures.</li> <li>Brute force search may be required to locate an entry in an unordered dataset. Different search algorithms can be applied based on the data structure: Linear search is suitable for arrays and linked lists, while breadth-first search (BFS) and depth-first search (DFS) are suitable for graphs and trees. These algorithms are highly versatile, requiring no preprocessing of data, but they have a higher time complexity of \\(O(n)\\).</li> <li>Hash search, tree search, and binary search are efficient search methods that can quickly locate target elements within specific data structures. These algorithms are highly efficient, with time complexities reaching \\(O(\\log n)\\) or even \\(O(1)\\), but they usually require extra space to accommodate additional data structures.</li> <li>In practice, we need to analyze factors such as data volume, search performance requirements, data query and update frequencies, etc., to choose an appropriate search method.</li> <li>Linear search is ideal for small or frequently updated (volatile) data. Binary search works well for large and sorted data. Hash search is suitable for data that requires high query efficiency and does not need range queries. Tree search is best suited for large dynamic data that require maintaining order and need to support range queries.</li> <li>Replacing linear search with hash search is a common strategy to optimize runtime performance, reducing the time complexity from \\(O(n)\\) to \\(O(1)\\).</li> </ul>"},{"location":"chapter_sorting/","title":"Sorting","text":""},{"location":"chapter_sorting/#sorting","title":"Sorting","text":"<p>Abstract</p> <p>Sorting is like a magical key that turns chaos into order, enabling us to understand and handle data more efficiently.</p> <p>Whether it's simple ascending order or complex categorical arrangements, sorting reveals the harmonious beauty of data.</p>"},{"location":"chapter_sorting/bubble_sort/","title":"11.3 Bubble sort","text":""},{"location":"chapter_sorting/bubble_sort/#bubble-sort","title":"Bubble sort","text":"<p>Bubble sort works by continuously comparing and swapping adjacent elements. This process is like bubbles rising from the bottom to the top, hence the name \"bubble sort.\"</p> <p>As shown in the figure below, the bubbling process can be simulated using element swaps: start from the leftmost end of the array and move right, comparing each pair of adjacent elements. If the left element is greater than the right element, swap them. After the traversal, the largest element will have bubbled up to the rightmost end of the array.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"chapter_sorting/bubble_sort/#algorithm-process","title":"Algorithm process","text":"<p>Assume the array has length \\(n\\). The steps of bubble sort are shown in the figure below:</p> <ol> <li>First, perform one \"bubble\" pass on \\(n\\) elements, swapping the largest element to its correct position.</li> <li>Next, perform a \"bubble\" pass on the remaining \\(n - 1\\) elements, swapping the second largest element to its correct position.</li> <li>Continue in this manner; after \\(n - 1\\) such passes, the largest \\(n - 1\\) elements will have been moved to their correct positions.</li> <li>The only remaining element must be the smallest, so no further sorting is required. At this point, the array is sorted.</li> </ol> <p></p> <p>Example code is as follows:</p> <pre><code>[file]{bubble_sort}-[class]{}-[func]{bubble_sort}\n</code></pre>"},{"location":"chapter_sorting/bubble_sort/#efficiency-optimization","title":"Efficiency optimization","text":"<p>If no swaps occur during a round of \"bubbling,\" the array is already sorted, so we can return immediately. To detect this, we can add a <code>flag</code> variable; whenever no swaps are made in a pass, we set the flag and return early.</p> <p>Even with this optimization, the worst time complexity and average time complexity of bubble sort remains \\(O(n^2)\\). However, if the input array is already sorted, the best-case time complexity can be as low as \\(O(n)\\).</p> <pre><code>[file]{bubble_sort}-[class]{}-[func]{bubble_sort_with_flag}\n</code></pre>"},{"location":"chapter_sorting/bubble_sort/#algorithm-characteristics","title":"Algorithm characteristics","text":"<ul> <li>Time complexity of \\(O(n^2)\\), adaptive sorting. Each round of \"bubbling\" traverses array segments of length \\(n - 1\\), \\(n - 2\\), \\(\\dots\\), \\(2\\), \\(1\\), which sums to \\((n - 1) n / 2\\). With a <code>flag</code> optimization, the best-case time complexity can reach \\(O(n)\\) when the array is already sorted.</li> <li>Space complexity of \\(O(1)\\), in-place sorting. Only a constant amount of extra space is used by pointers \\(i\\) and \\(j\\).</li> <li>Stable sorting. Because equal elements are not swapped during \"bubbling,\" their original order is preserved, making this a stable sort.</li> </ul>"},{"location":"chapter_sorting/bucket_sort/","title":"11.8 Bucket sort","text":""},{"location":"chapter_sorting/bucket_sort/#bucket-sort","title":"Bucket sort","text":"<p>The previously mentioned sorting algorithms are all \"comparison-based sorting algorithms,\" which sort elements by comparing their values. Such sorting algorithms cannot have better time complexity of \\(O(n \\log n)\\). Next, we will discuss several \"non-comparison sorting algorithms\" that could achieve linear time complexity.</p> <p>Bucket sort is a typical application of the divide-and-conquer strategy. It works by setting up a series of ordered buckets, each containing a range of data, and distributing the input data evenly across these buckets. And then, the data in each bucket is sorted individually. Finally, the sorted data from all the buckets is merged in sequence to produce the final result.</p>"},{"location":"chapter_sorting/bucket_sort/#algorithm-process","title":"Algorithm process","text":"<p>Consider an array of length \\(n\\), with float numbers in the range \\([0, 1)\\). The bucket sort process is illustrated in the figure below.</p> <ol> <li>Initialize \\(k\\) buckets and distribute \\(n\\) elements into these \\(k\\) buckets.</li> <li>Sort each bucket individually (using the built-in sorting function of the programming language).</li> <li>Merge the results in the order from the smallest to the largest bucket.</li> </ol> <p></p> <p>The code is shown as follows:</p> <pre><code>[file]{bucket_sort}-[class]{}-[func]{bucket_sort}\n</code></pre>"},{"location":"chapter_sorting/bucket_sort/#algorithm-characteristics","title":"Algorithm characteristics","text":"<p>Bucket sort is suitable for handling very large data sets. For example, if the input data includes 1 million elements, and system memory limitations prevent loading all the data at the same time, you can divide the data into 1,000 buckets and sort each bucket separately before merging the results.</p> <ul> <li>Time complexity is \\(O(n + k)\\): Assuming the elements are evenly distributed across the buckets, the number of elements in each bucket is \\(n/k\\). Assuming sorting a single bucket takes \\(O(n/k \\log(n/k))\\) time, sorting all buckets takes \\(O(n \\log(n/k))\\) time. When the number of buckets \\(k\\) is relatively large, the time complexity approaches \\(O(n)\\). Merging the results requires traversing all buckets and elements, taking \\(O(n + k)\\) time. In the worst case, all data is distributed into a single bucket, and sorting that bucket takes \\(O(n^2)\\) time.</li> <li>Space complexity is \\(O(n + k)\\), non-in-place sorting: It requires additional space for \\(k\\) buckets and a total of \\(n\\) elements.</li> <li>Whether bucket sort is stable depends on whether the sorting algorithm used within each bucket is stable.</li> </ul>"},{"location":"chapter_sorting/bucket_sort/#how-to-achieve-even-distribution","title":"How to achieve even distribution","text":"<p>The theoretical time complexity of bucket sort can reach \\(O(n)\\). The key is to evenly distribute the elements across all buckets as real-world data is often not uniformly distributed. For example, we may want to evenly distribute all products on eBay by price range into 10 buckets. However, the distribution of product prices may not be even, with many under $100 and few over $500. If the price range is evenly divided into 10, the difference in the number of products in each bucket will be significant.</p> <p>To achieve even distribution, we can initially set an approximate boundary to roughly divide the data into 3 buckets. After the distribution is complete, the buckets with more items can be further divided into 3 buckets, until the number of elements in all buckets is roughly equal.</p> <p>As shown in the figure below, this method essentially constructs a recursive tree, aiming to ensure the element counts in leaf nodes are as even as possible. Of course, you don't have to divide the data into 3 buckets each round - the partitioning strategy can be adaptively tailored to the data's unique characteristics.</p> <p></p> <p>If we know the probability distribution of product prices in advance, we can set the price boundaries for each bucket based on the data probability distribution. It is worth noting that it is not necessarily required to specifically calculate the data distribution; instead, it can be approximated based on data characteristics using a probability model.</p> <p>As shown in the figure below, assuming that product prices follow a normal distribution, we can define reasonable price intervals to balance the distribution of items across the buckets.</p> <p></p>"},{"location":"chapter_sorting/counting_sort/","title":"11.9 Counting sort","text":""},{"location":"chapter_sorting/counting_sort/#counting-sort","title":"Counting sort","text":"<p>Counting sort achieves sorting by counting the number of elements, usually applied to integer arrays.</p>"},{"location":"chapter_sorting/counting_sort/#simple-implementation","title":"Simple implementation","text":"<p>Let's start with a simple example. Given an array <code>nums</code> of length \\(n\\), where all elements are \"non-negative integers\", the overall process of counting sort is shown in the figure below.</p> <ol> <li>Traverse the array to find the maximum number, denoted as \\(m\\), then create an auxiliary array <code>counter</code> of length \\(m + 1\\).</li> <li>Use <code>counter</code> to count the occurrence of each number in <code>nums</code>, where <code>counter[num]</code> corresponds to the occurrence of the number <code>num</code>. The counting method is simple, just traverse <code>nums</code> (suppose the current number is <code>num</code>), and increase <code>counter[num]</code> by \\(1\\) each round.</li> <li>Since the indices of <code>counter</code> are naturally ordered, all numbers are essentially sorted already. Next, we traverse <code>counter</code>, and fill in <code>nums</code> in ascending order of occurrence.</li> </ol> <p></p> <p>The code is shown below:</p> <pre><code>[file]{counting_sort}-[class]{}-[func]{counting_sort_naive}\n</code></pre> <p>Connection between counting sort and bucket sort</p> <p>From the perspective of bucket sort, we can consider each index of the counting array <code>counter</code> in counting sort as a bucket, and the process of counting as distributing elements into the corresponding buckets. Essentially, counting sort is a special case of bucket sort for integer data.</p>"},{"location":"chapter_sorting/counting_sort/#complete-implementation","title":"Complete implementation","text":"<p>Observant readers might notice, if the input data is an object, the above step <code>3.</code> is invalid. Suppose the input data is a product object, we want to sort the products by the price (a class member variable), but the above algorithm can only give the sorted price as the result.</p> <p>So how can we get the sorting result for the original data? First, we calculate the \"prefix sum\" of <code>counter</code>. As the name suggests, the prefix sum at index <code>i</code>, <code>prefix[i]</code>, equals the sum of the first <code>i</code> elements of the array:</p> \\[ \\text{prefix}[i] = \\sum_{j=0}^i \\text{counter[j]} \\] <p>The prefix sum has a clear meaning, <code>prefix[num] - 1</code> represents the index of the last occurrence of element <code>num</code> in the result array <code>res</code>. This information is crucial, as it tells us where each element should appear in the result array. Next, we traverse each element <code>num</code> of the original array <code>nums</code> in reverse order, performing the following two steps in each iteration.</p> <ol> <li>Fill <code>num</code> into the array <code>res</code> at the index <code>prefix[num] - 1</code>.</li> <li>Decrease the prefix sum <code>prefix[num]</code> by \\(1\\) to obtain the next index to place <code>num</code>.</li> </ol> <p>After the traversal, the array <code>res</code> contains the sorted result, and finally, <code>res</code> replaces the original array <code>nums</code>. The complete counting sort process is shown in the figure below.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>The implementation code of counting sort is shown below:</p> <pre><code>[file]{counting_sort}-[class]{}-[func]{counting_sort}\n</code></pre>"},{"location":"chapter_sorting/counting_sort/#algorithm-characteristics","title":"Algorithm characteristics","text":"<ul> <li>Time complexity is \\(O(n + m)\\), non-adaptive sort: It involves traversing <code>nums</code> and <code>counter</code>, both using linear time. Generally, \\(n \\gg m\\), and the time complexity tends towards \\(O(n)\\).</li> <li>Space complexity is \\(O(n + m)\\), non-in-place sort: It uses array <code>res</code> of lengths \\(n\\) and array <code>counter</code> of length \\(m\\) respectively.</li> <li>Stable sort: Since elements are filled into <code>res</code> in a \"right-to-left\" order, reversing the traversal of <code>nums</code> can prevent changing the relative position between equal elements, thereby achieving a stable sort. Actually, traversing <code>nums</code> in order can also produce the correct sorting result, but the outcome is unstable.</li> </ul>"},{"location":"chapter_sorting/counting_sort/#limitations","title":"Limitations","text":"<p>By now, you might find counting sort very clever, as it can achieve efficient sorting merely by counting quantities. However, the prerequisites for using counting sort are relatively strict.</p> <p>Counting sort is only suitable for non-negative integers. If you want to apply it to other types of data, you need to ensure that these data can be converted to non-negative integers without changing the original order of the elements. For example, for an array containing negative integers, you can first add a constant to all numbers, converting them all to positive numbers, and then convert them back after sorting is complete.</p> <p>Counting sort is suitable for large datasets with a small range of values. For example, in the above example, \\(m\\) should not be too large, otherwise, it will occupy too much space. And when \\(n \\ll m\\), counting sort uses \\(O(m)\\) time, which may be slower than \\(O(n \\log n)\\) sorting algorithms.</p>"},{"location":"chapter_sorting/heap_sort/","title":"11.7 Heap sort","text":""},{"location":"chapter_sorting/heap_sort/#heap-sort","title":"Heap sort","text":"<p>Tip</p> <p>Before reading this section, please ensure you have completed the \"Heap\" chapter.</p> <p>Heap sort is an efficient sorting algorithm based on the heap data structure. We can implement heap sort using the \"heap creation\" and \"element extraction\" operations we have already learned.</p> <ol> <li>Input the array and construct a min-heap, where the smallest element is at the top of the heap.</li> <li>Continuously perform the extraction operation, record the extracted elements sequentially to obtain a sorted list from smallest to largest.</li> </ol> <p>Although the above method is feasible, it requires an additional array to store the popped elements, which is somewhat space-consuming. In practice, we usually use a more elegant implementation.</p>"},{"location":"chapter_sorting/heap_sort/#algorithm-flow","title":"Algorithm flow","text":"<p>Suppose the array length is \\(n\\), the heap sort process is as follows.</p> <ol> <li>Input the array and establish a max-heap. After this step, the largest element is positioned at the top of the heap.</li> <li>Swap the top element of the heap (the first element) with the heap's bottom element (the last element). Following this swap, reduce the heap's length by \\(1\\) and increase the sorted elements count by \\(1\\).</li> <li>Starting from the heap top, perform the sift-down operation from top to bottom. After the sift-down, the heap's property is restored.</li> <li>Repeat steps <code>2.</code> and <code>3.</code> Loop for \\(n - 1\\) rounds to complete the sorting of the array.</li> </ol> <p>Tip</p> <p>In fact, the element extraction operation also includes steps <code>2.</code> and <code>3.</code>, with an additional step to pop (remove) the extracted element from the heap.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt;&lt;12&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>In the code implementation, we used the sift-down function <code>sift_down()</code> from the \"Heap\" chapter. It is important to note that since the heap's length decreases as the maximum element is extracted, we need to add a length parameter \\(n\\) to the <code>sift_down()</code> function to specify the current effective length of the heap. The code is shown below:</p> <pre><code>[file]{heap_sort}-[class]{}-[func]{heap_sort}\n</code></pre>"},{"location":"chapter_sorting/heap_sort/#algorithm-characteristics","title":"Algorithm characteristics","text":"<ul> <li>Time complexity is \\(O(n \\log n)\\), non-adaptive sort: The heap creation uses \\(O(n)\\) time. Extracting the largest element from the heap takes \\(O(\\log n)\\) time, looping for \\(n - 1\\) rounds.</li> <li>Space complexity is \\(O(1)\\), in-place sort: A few pointer variables use \\(O(1)\\) space. The element swapping and heapifying operations are performed on the original array.</li> <li>Non-stable sort: The relative positions of equal elements may change during the swapping of the heap's top and bottom elements.</li> </ul>"},{"location":"chapter_sorting/insertion_sort/","title":"11.4 Insertion sort","text":""},{"location":"chapter_sorting/insertion_sort/#insertion-sort","title":"Insertion sort","text":"<p>Insertion sort is a simple sorting algorithm that works very much like the process of manually sorting a deck of cards.</p> <p>Specifically, we select a base element from the unsorted interval, compare it with the elements in the sorted interval to its left, and insert the element into the correct position.</p> <p>The figure below illustrates how an element is inserted into the array. Assuming the base element is <code>base</code>, we need to shift all elements from the target index up to <code>base</code> one position to the right, then assign <code>base</code> to the target index.</p> <p></p>"},{"location":"chapter_sorting/insertion_sort/#algorithm-process","title":"Algorithm process","text":"<p>The overall process of insertion sort is shown in the figure below.</p> <ol> <li>Consider the first element of the array as sorted.</li> <li>Select the second element as <code>base</code>, insert it into its correct position, leaving the first two elements sorted.</li> <li>Select the third element as <code>base</code>, insert it into its correct position, leaving the first three elements sorted.</li> <li>Continuing in this manner, in the final iteration, the last element is taken as <code>base</code>, and after inserting it into the correct position, all elements are sorted.</li> </ol> <p></p> <p>Example code is as follows:</p> <pre><code>[file]{insertion_sort}-[class]{}-[func]{insertion_sort}\n</code></pre>"},{"location":"chapter_sorting/insertion_sort/#algorithm-characteristics","title":"Algorithm characteristics","text":"<ul> <li>Time complexity is \\(O(n^2)\\), adaptive sorting: In the worst case, each insertion operation requires \\(n - 1\\), \\(n-2\\), ..., \\(2\\), \\(1\\) loops, summing up to \\((n - 1) n / 2\\), thus the time complexity is \\(O(n^2)\\). In the case of ordered data, the insertion operation will terminate early. When the input array is completely ordered, insertion sort achieves the best time complexity of \\(O(n)\\).</li> <li>Space complexity is \\(O(1)\\), in-place sorting: Pointers \\(i\\) and \\(j\\) use a constant amount of extra space.</li> <li>Stable sorting: During the insertion operation, we insert elements to the right of equal elements, not changing their order.</li> </ul>"},{"location":"chapter_sorting/insertion_sort/#advantages-of-insertion-sort","title":"Advantages of insertion sort","text":"<p>The time complexity of insertion sort is \\(O(n^2)\\), while the time complexity of quicksort, which we will study next, is \\(O(n \\log n)\\). Although insertion sort has a higher time complexity, it is usually faster in small input sizes.</p> <p>This conclusion is similar to that for linear and binary search. Algorithms like quicksort that have a time complexity of \\(O(n \\log n)\\) and are based on the divide-and-conquer strategy often involve more unit operations. For small input sizes, the numerical values of \\(n^2\\) and \\(n \\log n\\) are close, and complexity does not dominate, with the number of unit operations per round playing a decisive role.</p> <p>In fact, many programming languages (such as Java) use insertion sort within their built-in sorting functions. The general approach is: for long arrays, use sorting algorithms based on divide-and-conquer strategies, such as quicksort; for short arrays, use insertion sort directly.</p> <p>Although bubble sort, selection sort, and insertion sort all have a time complexity of \\(O(n^2)\\), in practice, insertion sort is commonly used than bubble sort and selection sort, mainly for the following reasons.</p> <ul> <li>Bubble sort is based on element swapping, which requires the use of a temporary variable, involving 3 unit operations; insertion sort is based on element assignment, requiring only 1 unit operation. Therefore, the computational overhead of bubble sort is generally higher than that of insertion sort.</li> <li>The time complexity of selection sort is always \\(O(n^2)\\). Given a set of partially ordered data, insertion sort is usually more efficient than selection sort.</li> <li>Selection sort is unstable and cannot be applied to multi-level sorting.</li> </ul>"},{"location":"chapter_sorting/merge_sort/","title":"11.6 Merge sort","text":""},{"location":"chapter_sorting/merge_sort/#merge-sort","title":"Merge sort","text":"<p>Merge sort is a sorting algorithm based on the divide-and-conquer strategy, involving the \"divide\" and \"merge\" phases shown in the figure below.</p> <ol> <li>Divide phase: Recursively split the array from the midpoint, transforming the sorting problem of a long array into shorter arrays.</li> <li>Merge phase: Stop dividing when the length of the sub-array is 1, and then begin merging. The two shorter sorted arrays are continuously merged into a longer sorted array until the process is complete.</li> </ol> <p></p>"},{"location":"chapter_sorting/merge_sort/#algorithm-workflow","title":"Algorithm workflow","text":"<p>As shown in the figure below, the \"divide phase\" recursively splits the array from the midpoint into two sub-arrays from top to bottom.</p> <ol> <li>Calculate the midpoint <code>mid</code>, recursively divide the left sub-array (interval <code>[left, mid]</code>) and the right sub-array (interval <code>[mid + 1, right]</code>).</li> <li>Continue with step <code>1.</code> recursively until sub-array length becomes 1, then stops.</li> </ol> <p>The \"merge phase\" combines the left and right sub-arrays into a sorted array from bottom to top. It is important to note that, merging starts with sub-arrays of length 1, and each sub-array is sorted during the merge phase.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>It can be observed that the order of recursion in merge sort is consistent with the post-order traversal of a binary tree.</p> <ul> <li>Post-order traversal: First recursively traverse the left subtree, then the right subtree, and finally process the root node.</li> <li>Merge sort: First recursively process the left sub-array, then the right sub-array, and finally perform the merge.</li> </ul> <p>The implementation of merge sort is shown in the following code. Note that the interval to be merged in <code>nums</code> is <code>[left, right]</code>, while the corresponding interval in <code>tmp</code> is <code>[0, right - left]</code>.</p> <pre><code>[file]{merge_sort}-[class]{}-[func]{merge_sort}\n</code></pre>"},{"location":"chapter_sorting/merge_sort/#algorithm-characteristics","title":"Algorithm characteristics","text":"<ul> <li>Time complexity of \\(O(n \\log n)\\), non-adaptive sort: The division creates a recursion tree of height \\(\\log n\\), with each layer merging a total of \\(n\\) operations, resulting in an overall time complexity of \\(O(n \\log n)\\).</li> <li>Space complexity of \\(O(n)\\), non-in-place sort: The recursion depth is \\(\\log n\\), using \\(O(\\log n)\\) stack frame space. The merging operation requires auxiliary arrays, using an additional space of \\(O(n)\\).</li> <li>Stable sort: During the merging process, the order of equal elements remains unchanged.</li> </ul>"},{"location":"chapter_sorting/merge_sort/#linked-list-sorting","title":"Linked List sorting","text":"<p>For linked lists, merge sort has significant advantages over other sorting algorithms. It can optimize the space complexity of the linked list sorting task to \\(O(1)\\).</p> <ul> <li>Divide phase: \"Iteration\" can be used instead of \"recursion\" to perform the linked list division work, thus saving the stack frame space used by recursion.</li> <li>Merge phase: In linked lists, node insertion and deletion operations can be achieved by changing references (pointers), so no extra lists need to be created during the merge phase (combining two short ordered lists into one long ordered list).</li> </ul> <p>The implementation details are relatively complex, and interested readers can consult related materials for learning.</p>"},{"location":"chapter_sorting/quick_sort/","title":"11.5 Quick sort","text":""},{"location":"chapter_sorting/quick_sort/#quick-sort","title":"Quick sort","text":"<p>Quick sort is a sorting algorithm based on the divide-and-conquer strategy, known for its efficiency and wide application.</p> <p>The core operation of quick sort is \"pivot partitioning,\" which aims to select an element from the array as the \"pivot\" and move all elements less than the pivot to its left side, while moving all elements greater than the pivot to its right side. Specifically, the process of pivot partitioning is illustrated in the figure below.</p> <ol> <li>Select the leftmost element of the array as the pivot, and initialize two pointers <code>i</code> and <code>j</code> to point to the two ends of the array respectively.</li> <li>Set up a loop where each round uses <code>i</code> (<code>j</code>) to search for the first element larger (smaller) than the pivot, then swap these two elements.</li> <li>Repeat step <code>2.</code> until <code>i</code> and <code>j</code> meet, finally swap the pivot to the boundary between the two sub-arrays.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>After the pivot partitioning, the original array is divided into three parts: left sub-array, pivot, and right sub-array, satisfying \"any element in the left sub-array \\(\\leq\\) pivot \\(\\leq\\) any element in the right sub-array.\" Therefore, we then only need to sort these two sub-arrays.</p> <p>Divide-and-conquer strategy for quick sort</p> <p>The essence of pivot partitioning is to simplify the sorting problem of a longer array into two shorter arrays.</p> <pre><code>[file]{quick_sort}-[class]{quick_sort}-[func]{partition}\n</code></pre>"},{"location":"chapter_sorting/quick_sort/#algorithm-process","title":"Algorithm process","text":"<p>The overall process of quick sort is shown in the figure below.</p> <ol> <li>First, perform a \"pivot partitioning\" on the original array to obtain the unsorted left and right sub-arrays.</li> <li>Then, recursively perform \"pivot partitioning\" on the left and right sub-arrays separately.</li> <li>Continue recursively until the length of sub-array is 1, thus completing the sorting of the entire array.</li> </ol> <p></p> <pre><code>[file]{quick_sort}-[class]{quick_sort}-[func]{quick_sort}\n</code></pre>"},{"location":"chapter_sorting/quick_sort/#algorithm-features","title":"Algorithm features","text":"<ul> <li>Time complexity of \\(O(n \\log n)\\), non-adaptive sorting: In average cases, the recursive levels of pivot partitioning are \\(\\log n\\), and the total number of loops per level is \\(n\\), using \\(O(n \\log n)\\) time overall. In the worst case, each round of pivot partitioning divides an array of length \\(n\\) into two sub-arrays of lengths \\(0\\) and \\(n - 1\\), when the number of recursive levels reaches \\(n\\), the number of loops in each level is \\(n\\), and the total time used is \\(O(n^2)\\).</li> <li>Space complexity of \\(O(n)\\), in-place sorting: In the case where the input array is completely reversed, the worst recursive depth reaches \\(n\\), using \\(O(n)\\) stack frame space. The sorting operation is performed on the original array without the aid of additional arrays.</li> <li>Non-stable sorting: In the final step of pivot partitioning, the pivot may be swapped to the right of equal elements.</li> </ul>"},{"location":"chapter_sorting/quick_sort/#why-is-quick-sort-fast","title":"Why is quick sort fast","text":"<p>As the name suggests, quick sort should have certain advantages in terms of efficiency. Although the average time complexity of quick sort is the same as that of \"merge sort\" and \"heap sort,\" it is generally more efficient for the following reasons.</p> <ul> <li>Low probability of worst-case scenarios: Although the worst time complexity of quick sort is \\(O(n^2)\\), less stable than merge sort, in most cases, quick sort can operate under a time complexity of \\(O(n \\log n)\\).</li> <li>High cache utilization: During the pivot partitioning operation, the system can load the entire sub-array into the cache, thus accessing elements more efficiently. In contrast, algorithms like \"heap sort\" need to access elements in a jumping manner, lacking this feature.</li> <li>Small constant coefficient of complexity: Among the three algorithms mentioned above, quick sort has the least total number of operations such as comparisons, assignments, and swaps. This is similar to why \"insertion sort\" is faster than \"bubble sort.\"</li> </ul>"},{"location":"chapter_sorting/quick_sort/#pivot-optimization","title":"Pivot optimization","text":"<p>Quick sort's time efficiency may degrade under certain inputs. For example, if the input array is completely reversed, since we select the leftmost element as the pivot, after the pivot partitioning, the pivot is swapped to the array's right end, causing the left sub-array length to be \\(n - 1\\) and the right sub-array length to be \\(0\\). Continuing this way, each round of pivot partitioning will have a sub-array length of \\(0\\), and the divide-and-conquer strategy fails, degrading quick sort to a form similar to \"bubble sort.\"</p> <p>To avoid this situation, we can optimize the pivot selection strategy in the pivot partitioning. For instance, we can randomly select an element as the pivot. However, if luck is not on our side, and we consistently select suboptimal pivots, the efficiency is still not satisfactory.</p> <p>It's important to note that programming languages usually generate \"pseudo-random numbers\". If we construct a specific test case for a pseudo-random number sequence, the efficiency of quick sort may still degrade.</p> <p>For further improvement, we can select three candidate elements (usually the first, last, and midpoint elements of the array), and use the median of these three candidate elements as the pivot. This way, the probability that the pivot is \"neither too small nor too large\" will be greatly increased. Of course, we can also select more candidate elements to further enhance robustness of the algorithm. With this method, the probability of the time complexity degrading to \\(O(n^2)\\) is greatly reduced.</p> <p>Sample code is as follows:</p> <pre><code>[file]{quick_sort}-[class]{quick_sort_median}-[func]{partition}\n</code></pre>"},{"location":"chapter_sorting/quick_sort/#tail-recursion-optimization","title":"Tail recursion optimization","text":"<p>Under certain inputs, quick sort may occupy more space. For example, consider a completely ordered input array. Let the length of the sub-array in the recursion be \\(m\\). In each round of pivot partitioning, a left sub-array of length \\(0\\) and a right sub-array of length \\(m - 1\\) are produced. This means that the problem size is reduced by only one element per recursive call, resulting in a very small reduction at each level of recursion. As a result, the height of the recursion tree can reach \\(n \u2212 1\\) , which requires \\(O(n)\\) of stack frame space.</p> <p>To prevent the accumulation of stack frame space, we can compare the lengths of the two sub-arrays after each round of pivot sorting, and only recursively sort the shorter sub-array. Since the length of the shorter sub-array will not exceed \\(n / 2\\), this method ensures that the recursion depth does not exceed \\(\\log n\\), thus optimizing the worst space complexity to \\(O(\\log n)\\). The code is as follows:</p> <pre><code>[file]{quick_sort}-[class]{quick_sort_tail_call}-[func]{quick_sort}\n</code></pre>"},{"location":"chapter_sorting/radix_sort/","title":"11.10 Radix sort","text":""},{"location":"chapter_sorting/radix_sort/#radix-sort","title":"Radix sort","text":"<p>The previous section introduced counting sort, which is suitable for scenarios where the data size \\(n\\) is large but the data range \\(m\\) is small. Suppose we need to sort \\(n = 10^6\\) student IDs, where each ID is an \\(8\\)-digit number. This means the data range \\(m = 10^8\\) is very large. Using counting sort in this case would require significant memory space. Radix sort can avoid this situation.</p> <p>Radix sort shares the same core concept as counting sort, which also sorts by counting the frequency of elements. Meanwhile, radix sort builds upon this by utilizing the progressive relationship between the digits of numbers. It processes and sorts the digits one at a time, achieving the final sorted order.</p>"},{"location":"chapter_sorting/radix_sort/#algorithm-process","title":"Algorithm process","text":"<p>Taking the student ID data as an example, assume the least significant digit is the \\(1^{st}\\) and the most significant is the \\(8^{th}\\), the radix sort process is illustrated in the figure below.</p> <ol> <li>Initialize digit \\(k = 1\\).</li> <li>Perform \"counting sort\" on the \\(k^{th}\\) digit of the student IDs. After completion, the data will be sorted from smallest to largest based on the \\(k^{th}\\) digit.</li> <li>Increment \\(k\\) by \\(1\\), then return to step <code>2.</code> and continue iterating until all digits have been sorted, at which point the process ends.</li> </ol> <p></p> <p>Below we dissect the code implementation. For a number \\(x\\) in base \\(d\\), to obtain its \\(k^{th}\\) digit \\(x_k\\), the following calculation formula can be used:</p> \\[ x_k = \\lfloor\\frac{x}{d^{k-1}}\\rfloor \\bmod d \\] <p>Where \\(\\lfloor a \\rfloor\\) denotes rounding down the floating point number \\(a\\), and \\(\\bmod \\: d\\) denotes taking the modulus of \\(d\\). For student ID data, \\(d = 10\\) and \\(k \\in [1, 8]\\).</p> <p>Additionally, we need to slightly modify the counting sort code to allow sorting based on the \\(k^{th}\\) digit:</p> <pre><code>[file]{radix_sort}-[class]{}-[func]{radix_sort}\n</code></pre> <p>Why start sorting from the least significant digit?</p> <p>In consecutive sorting rounds, the result of a later round will override the result of an earlier round. For example, if the result of the first round is \\(a &lt; b\\) and the second round is \\(a &gt; b\\), the second round's result will replace the first round's result. Since higher-order digits take precedence over lower-order digits, it makes sense to sort the lower digits before the higher digits.</p>"},{"location":"chapter_sorting/radix_sort/#algorithm-characteristics","title":"Algorithm characteristics","text":"<p>Compared to counting sort, radix sort is suitable for larger numerical ranges, but it assumes that the data can be represented in a fixed number of digits, and the number of digits should not be too large. For example, floating-point numbers are unsuitable for radix sort, as their digit count \\(k\\) may be large, potentially leading to a time complexity \\(O(nk) \\gg O(n^2)\\).</p> <ul> <li>Time complexity is \\(O(nk)\\), non-adaptive sorting: Assuming the data size is \\(n\\), the data is in base \\(d\\), and the maximum number of digits is \\(k\\), then sorting a single digit takes \\(O(n + d)\\) time, and sorting all \\(k\\) digits takes \\(O((n + d)k)\\) time. Generally, both \\(d\\) and \\(k\\) are relatively small, leading to a time complexity approaching \\(O(n)\\).</li> <li>Space complexity is \\(O(n + d)\\), non-in-place sorting: Like counting sort, radix sort relies on arrays <code>res</code> and <code>counter</code> of lengths \\(n\\) and \\(d\\) respectively.</li> <li>Stable sorting: When counting sort is stable, radix sort is also stable; if counting sort is unstable, radix sort cannot ensure a correct sorting order.</li> </ul>"},{"location":"chapter_sorting/selection_sort/","title":"11.2 Selection sort","text":""},{"location":"chapter_sorting/selection_sort/#selection-sort","title":"Selection sort","text":"<p>Selection sort works on a very simple principle: it uses a loop where each iteration selects the smallest element from the unsorted interval and moves it to the end of the sorted section.</p> <p>Suppose the length of the array is \\(n\\), the steps of selection sort is shown in the figure below.</p> <ol> <li>Initially, all elements are unsorted, i.e., the unsorted (index) interval is \\([0, n-1]\\).</li> <li>Select the smallest element in the interval \\([0, n-1]\\) and swap it with the element at index \\(0\\). After this, the first element of the array is sorted.</li> <li>Select the smallest element in the interval \\([1, n-1]\\) and swap it with the element at index \\(1\\). After this, the first two elements of the array are sorted.</li> <li>Continue in this manner. After \\(n - 1\\) rounds of selection and swapping, the first \\(n - 1\\) elements are sorted.</li> <li>The only remaining element is subsequently the largest element and does not need sorting, thus the array is sorted.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p>In the code, we use \\(k\\) to record the smallest element within the unsorted interval:</p> <pre><code>[file]{selection_sort}-[class]{}-[func]{selection_sort}\n</code></pre>"},{"location":"chapter_sorting/selection_sort/#algorithm-characteristics","title":"Algorithm characteristics","text":"<ul> <li>Time complexity of \\(O(n^2)\\), non-adaptive sort: There are \\(n - 1\\) iterations in the outer loop, with the length of the unsorted section starting at \\(n\\) in the first iteration and decreasing to \\(2\\) in the last iteration, i.e., each outer loop iterations contain \\(n\\), \\(n - 1\\), \\(\\dots\\), \\(3\\), \\(2\\) inner loop iterations respectively, summing up to \\(\\frac{(n - 1)(n + 2)}{2}\\).</li> <li>Space complexity of \\(O(1)\\), in-place sort: Uses constant extra space with pointers \\(i\\) and \\(j\\).</li> <li>Non-stable sort: As shown in the figure below, an element <code>nums[i]</code> may be swapped to the right of an equal element, causing their relative order to change.</li> </ul>"},{"location":"chapter_sorting/sorting_algorithm/","title":"11.1 Sorting algorithms","text":""},{"location":"chapter_sorting/sorting_algorithm/#sorting-algorithms","title":"Sorting algorithms","text":"<p>Sorting algorithms are used to arrange a set of data in a specific order. Sorting algorithms have a wide range of applications because ordered data can usually be searched, analyzed, and processed more efficiently.</p> <p>As shown in the figure below, the data types in sorting algorithms can be integers, floating point numbers, characters, or strings, etc. Sorting criterion can be set according to needs, such as numerical size, character ASCII order, or custom criterion.</p> <p></p>"},{"location":"chapter_sorting/sorting_algorithm/#evaluation-dimensions","title":"Evaluation dimensions","text":"<p>Execution efficiency: We expect the time complexity of sorting algorithms to be as low as possible, as well as a lower number of overall operations (lowering the constant term of time complexity). For large data volumes, execution efficiency is particularly important.</p> <p>In-place property: As the name implies, in-place sorting is achieved by directly manipulating the original array, without the need for additional helper arrays, thus saving memory. Generally, in-place sorting involves fewer data moving operations and is faster.</p> <p>Stability: Stable sorting ensures that the relative order of equal elements in the array does not change after sorting.</p> <p>Stable sorting is a necessary condition for multi-key sorting scenarios. Suppose we have a table storing student information, with the first and second columns being name and age, respectively. In this case, unstable sorting might lead to a loss of order in the input data:</p> <pre><code># Input data is sorted by name\n# (name, age)\n  ('A', 19)\n  ('B', 18)\n  ('C', 21)\n  ('D', 19)\n  ('E', 23)\n\n# Assuming an unstable sorting algorithm is used to sort the list by age,\n# the result changes the relative position of ('D', 19) and ('A', 19),\n# and the property of the input data being sorted by name is lost\n  ('B', 18)\n  ('D', 19)\n  ('A', 19)\n  ('C', 21)\n  ('E', 23)\n</code></pre> <p>Adaptability: Adaptive sorting leverages existing order information within the input data to reduce computational effort, achieving more optimal time efficiency. The best-case time complexity of adaptive sorting algorithms is typically better than their average-case time complexity.</p> <p>Comparison or non-comparison-based: Comparison-based sorting relies on comparison operators (\\(&lt;\\), \\(=\\), \\(&gt;\\)) to determine the relative order of elements and thus sort the entire array, with the theoretical optimal time complexity being \\(O(n \\log n)\\). Meanwhile, non-comparison sorting does not use comparison operators and can achieve a time complexity of \\(O(n)\\), but its versatility is relatively poor.</p>"},{"location":"chapter_sorting/sorting_algorithm/#ideal-sorting-algorithm","title":"Ideal sorting algorithm","text":"<p>Fast execution, in-place, stable, adaptive, and versatile. Clearly, no sorting algorithm that combines all these features has been found to date. Therefore, when selecting a sorting algorithm, it is necessary to decide based on the specific characteristics of the data and the requirements of the problem.</p> <p>Next, we will learn about various sorting algorithms together and analyze the advantages and disadvantages of each based on the above evaluation dimensions.</p>"},{"location":"chapter_sorting/summary/","title":"11.11 Summary","text":""},{"location":"chapter_sorting/summary/#summary","title":"Summary","text":""},{"location":"chapter_sorting/summary/#key-review","title":"Key review","text":"<ul> <li>Bubble sort works by swapping adjacent elements. By adding a flag to enable early return, we can optimize the best-case time complexity of bubble sort to \\(O(n)\\).</li> <li>Insertion sort sorts each round by inserting elements from the unsorted interval into the correct position in the sorted interval. Although the time complexity of insertion sort is \\(O(n^2)\\), it is very popular in sorting small amounts of data due to relatively fewer operations per unit.</li> <li>Quick sort is based on sentinel partitioning operations. In sentinel partitioning, it's possible to always pick the worst pivot, leading to a time complexity degradation to \\(O(n^2)\\). Introducing median or random pivots can reduce the probability of such degradation. Tail recursion effectively reduce the recursion depth, optimizing the space complexity to \\(O(\\log n)\\).</li> <li>Merge sort includes dividing and merging two phases, typically embodying the divide-and-conquer strategy. In merge sort, sorting an array requires creating auxiliary arrays, resulting in a space complexity of \\(O(n)\\); however, the space complexity for sorting a list can be optimized to \\(O(1)\\).</li> <li>Bucket sort consists of three steps: distributing data into buckets, sorting within each bucket, and merging results in bucket order. It also embodies the divide-and-conquer strategy, suitable for very large datasets. The key to bucket sort is the even distribution of data.</li> <li>Counting sort is a variant of bucket sort, which sorts by counting the occurrences of each data point. Counting sort is suitable for large datasets with a limited range of data and requires data conversion to positive integers.</li> <li>Radix sort processes data by sorting it digit by digit, requiring data to be represented as fixed-length numbers.</li> <li>Overall, we seek sorting algorithm that has high efficiency, stability, in-place operation, and adaptability. However, like other data structures and algorithms, no sorting algorithm can meet all these conditions simultaneously. In practical applications, we need to choose the appropriate sorting algorithm based on the characteristics of the data.</li> <li>The figure below compares mainstream sorting algorithms in terms of efficiency, stability, in-place nature, and adaptability.</li> </ul>"},{"location":"chapter_sorting/summary/#q-a","title":"Q &amp; A","text":"<p>Q: When is the stability of sorting algorithms necessary?</p> <p>In reality, we might sort based on one attribute of an object. For example, students have names and heights as attributes, and we aim to implement multi-level sorting: first by name to get <code>(A, 180) (B, 185) (C, 170) (D, 170)</code>; then by height. Because the sorting algorithm is unstable, we might end up with <code>(D, 170) (C, 170) (A, 180) (B, 185)</code>.</p> <p>It can be seen that the positions of students D and C have been swapped, disrupting the orderliness of the names, which is undesirable.</p> <p>Q: Can the order of \"searching from right to left\" and \"searching from left to right\" in sentinel partitioning be swapped?</p> <p>No, when using the leftmost element as the pivot, we must first \"search from right to left\" then \"search from left to right\". This conclusion is somewhat counterintuitive, so let's analyze the reason.</p> <p>The last step of the sentinel partition <code>partition()</code> is to swap <code>nums[left]</code> and <code>nums[i]</code>. After the swap, the elements to the left of the pivot are all <code>&lt;=</code> the pivot, which requires that <code>nums[left] &gt;= nums[i]</code> must hold before the last swap. Suppose we \"search from left to right\" first, and if no element larger than the pivot is found, we will exit the loop when <code>i == j</code>, possibly with <code>nums[j] == nums[i] &gt; nums[left]</code>. In other words, the final swap operation will exchange an element larger than the pivot to the left end of the array, causing the sentinel partition to fail.</p> <p>For example, given the array <code>[0, 0, 0, 0, 1]</code>, if we first \"search from left to right\", the array after the sentinel partition is <code>[1, 0, 0, 0, 0]</code>, which is incorrect.</p> <p>Upon further consideration, if we choose <code>nums[right]</code> as the pivot, then exactly the opposite, we must first \"search from left to right\".</p> <p>Q: Regarding tail recursion optimization, why does choosing the shorter array ensure that the recursion depth does not exceed \\(\\log n\\)?</p> <p>The recursion depth is the number of currently unreturned recursive methods. Each round of sentinel partition divides the original array into two subarrays. With tail recursion optimization, the length of the subarray to be recursively followed is at most half of the original array length. Assuming the worst case always halves the length, the final recursion depth will be \\(\\log n\\).</p> <p>Reviewing the original quicksort, we might continuously recursively process larger arrays, in the worst case from \\(n\\), \\(n - 1\\), ..., \\(2\\), \\(1\\), with a recursion depth of \\(n\\). Tail recursion optimization can avoid this scenario.</p> <p>Q: When all elements in the array are equal, is the time complexity of quicksort \\(O(n^2)\\)? How should this degenerate case be handled?</p> <p>Yes. For this situation, consider using sentinel partitioning to divide the array into three parts: less than, equal to, and greater than the pivot. Only recursively proceed with the less than and greater than parts. In this method, an array where all input elements are equal can be sorted in just one round of sentinel partitioning.</p> <p>Q: Why is the worst-case time complexity of bucket sort \\(O(n^2)\\)?</p> <p>In the worst case, all elements are placed in the same bucket. If we use an \\(O(n^2)\\) algorithm to sort these elements, the time complexity will be \\(O(n^2)\\).</p>"},{"location":"chapter_stack_and_queue/","title":"Stack and queue","text":""},{"location":"chapter_stack_and_queue/#stack-and-queue","title":"Stack and queue","text":"<p>Abstract</p> <p>A stack is like cats placed on top of each other, while a queue is like cats lined up one by one.</p> <p>They represent the logical relationships of Last-In-First-Out (LIFO) and First-In-First-Out (FIFO), respectively.</p>"},{"location":"chapter_stack_and_queue/deque/","title":"5.3 Double-ended queue","text":""},{"location":"chapter_stack_and_queue/deque/#double-ended-queue","title":"Double-ended queue","text":"<p>In a queue, we can only delete elements from the head or add elements to the tail. As shown in the figure below, a double-ended queue (deque) offers more flexibility, allowing the addition or removal of elements at both the head and the tail.</p> <p></p>"},{"location":"chapter_stack_and_queue/deque/#common-operations-in-double-ended-queue","title":"Common operations in double-ended queue","text":"<p>The common operations in a double-ended queue are listed below, and the names of specific methods depend on the programming language used.</p> <p> Table  \u00a0 Efficiency of double-ended queue operations </p> Method Name Description Time Complexity <code>pushFirst()</code> Add an element to the head \\(O(1)\\) <code>pushLast()</code> Add an element to the tail \\(O(1)\\) <code>popFirst()</code> Remove the first element \\(O(1)\\) <code>popLast()</code> Remove the last element \\(O(1)\\) <code>peekFirst()</code> Access the first element \\(O(1)\\) <code>peekLast()</code> Access the last element \\(O(1)\\) <p>Similarly, we can directly use the double-ended queue classes implemented in programming languages:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig deque.py<pre><code>from collections import deque\n\n# Initialize the deque\ndeq: deque[int] = deque()\n\n# Enqueue elements\ndeq.append(2)      # Add to the tail\ndeq.append(5)\ndeq.append(4)\ndeq.appendleft(3)  # Add to the head\ndeq.appendleft(1)\n\n# Access elements\nfront: int = deq[0]  # The first element\nrear: int = deq[-1]  # The last element\n\n# Dequeue elements\npop_front: int = deq.popleft()  # The first element dequeued\npop_rear: int = deq.pop()       # The last element dequeued\n\n# Get the length of the deque\nsize: int = len(deq)\n\n# Check if the deque is empty\nis_empty: bool = len(deq) == 0\n</code></pre> deque.cpp<pre><code>/* Initialize the deque */\ndeque&lt;int&gt; deque;\n\n/* Enqueue elements */\ndeque.push_back(2);   // Add to the tail\ndeque.push_back(5);\ndeque.push_back(4);\ndeque.push_front(3);  // Add to the head\ndeque.push_front(1);\n\n/* Access elements */\nint front = deque.front(); // The first element\nint back = deque.back();   // The last element\n\n/* Dequeue elements */\ndeque.pop_front();  // The first element dequeued\ndeque.pop_back();   // The last element dequeued\n\n/* Get the length of the deque */\nint size = deque.size();\n\n/* Check if the deque is empty */\nbool empty = deque.empty();\n</code></pre> deque.java<pre><code>/* Initialize the deque */\nDeque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();\n\n/* Enqueue elements */\ndeque.offerLast(2);   // Add to the tail\ndeque.offerLast(5);\ndeque.offerLast(4);\ndeque.offerFirst(3);  // Add to the head\ndeque.offerFirst(1);\n\n/* Access elements */\nint peekFirst = deque.peekFirst();  // The first element\nint peekLast = deque.peekLast();    // The last element\n\n/* Dequeue elements */\nint popFirst = deque.pollFirst();  // The first element dequeued\nint popLast = deque.pollLast();    // The last element dequeued\n\n/* Get the length of the deque */\nint size = deque.size();\n\n/* Check if the deque is empty */\nboolean isEmpty = deque.isEmpty();\n</code></pre> deque.cs<pre><code>/* Initialize the deque */\n// In C#, LinkedList is used as a deque\nLinkedList&lt;int&gt; deque = new();\n\n/* Enqueue elements */\ndeque.AddLast(2);   // Add to the tail\ndeque.AddLast(5);\ndeque.AddLast(4);\ndeque.AddFirst(3);  // Add to the head\ndeque.AddFirst(1);\n\n/* Access elements */\nint peekFirst = deque.First.Value;  // The first element\nint peekLast = deque.Last.Value;    // The last element\n\n/* Dequeue elements */\ndeque.RemoveFirst();  // The first element dequeued\ndeque.RemoveLast();   // The last element dequeued\n\n/* Get the length of the deque */\nint size = deque.Count;\n\n/* Check if the deque is empty */\nbool isEmpty = deque.Count == 0;\n</code></pre> deque_test.go<pre><code>/* Initialize the deque */\n// In Go, use list as a deque\ndeque := list.New()\n\n/* Enqueue elements */\ndeque.PushBack(2)      // Add to the tail\ndeque.PushBack(5)\ndeque.PushBack(4)\ndeque.PushFront(3)     // Add to the head\ndeque.PushFront(1)\n\n/* Access elements */\nfront := deque.Front() // The first element\nrear := deque.Back()   // The last element\n\n/* Dequeue elements */\ndeque.Remove(front)    // The first element dequeued\ndeque.Remove(rear)     // The last element dequeued\n\n/* Get the length of the deque */\nsize := deque.Len()\n\n/* Check if the deque is empty */\nisEmpty := deque.Len() == 0\n</code></pre> deque.swift<pre><code>/* Initialize the deque */\n// Swift does not have a built-in deque class, so Array can be used as a deque\nvar deque: [Int] = []\n\n/* Enqueue elements */\ndeque.append(2) // Add to the tail\ndeque.append(5)\ndeque.append(4)\ndeque.insert(3, at: 0) // Add to the head\ndeque.insert(1, at: 0)\n\n/* Access elements */\nlet peekFirst = deque.first! // The first element\nlet peekLast = deque.last!   // The last element\n\n/* Dequeue elements */\n// Using Array, popFirst has a complexity of O(n)\nlet popFirst = deque.removeFirst() // The first element dequeued\nlet popLast = deque.removeLast()   // The last element dequeued\n\n/* Get the length of the deque */\nlet size = deque.count\n\n/* Check if the deque is empty */\nlet isEmpty = deque.isEmpty\n</code></pre> deque.js<pre><code>/* Initialize the deque */\n// JavaScript does not have a built-in deque, so Array is used as a deque\nconst deque = [];\n\n/* Enqueue elements */\ndeque.push(2);\ndeque.push(5);\ndeque.push(4);\n// Note that unshift() has a time complexity of O(n) as it's an array\ndeque.unshift(3);\ndeque.unshift(1);\n\n/* Access elements */\nconst peekFirst = deque[0]; // The first element\nconst peekLast = deque[deque.length - 1]; // The last element\n\n/* Dequeue elements */\n// Note that shift() has a time complexity of O(n) as it's an array\nconst popFront = deque.shift(); // The first element dequeued\nconst popBack = deque.pop();    // The last element dequeued\n\n/* Get the length of the deque */\nconst size = deque.length;\n\n/* Check if the deque is empty */\nconst isEmpty = size === 0;\n</code></pre> deque.ts<pre><code>/* Initialize the deque */\n// TypeScript does not have a built-in deque, so Array is used as a deque\nconst deque: number[] = [];\n\n/* Enqueue elements */\ndeque.push(2);\ndeque.push(5);\ndeque.push(4);\n// Note that unshift() has a time complexity of O(n) as it's an array\ndeque.unshift(3);\ndeque.unshift(1);\n\n/* Access elements */\nconst peekFirst: number = deque[0]; // The first element\nconst peekLast: number = deque[deque.length - 1]; // The last element\n\n/* Dequeue elements */\n// Note that shift() has a time complexity of O(n) as it's an array\nconst popFront: number = deque.shift() as number; // The first element dequeued\nconst popBack: number = deque.pop() as number;    // The last element dequeued\n\n/* Get the length of the deque */\nconst size: number = deque.length;\n\n/* Check if the deque is empty */\nconst isEmpty: boolean = size === 0;\n</code></pre> deque.dart<pre><code>/* Initialize the deque */\n// In Dart, Queue is defined as a deque\nQueue&lt;int&gt; deque = Queue&lt;int&gt;();\n\n/* Enqueue elements */\ndeque.addLast(2);  // Add to the tail\ndeque.addLast(5);\ndeque.addLast(4);\ndeque.addFirst(3); // Add to the head\ndeque.addFirst(1);\n\n/* Access elements */\nint peekFirst = deque.first; // The first element\nint peekLast = deque.last;   // The last element\n\n/* Dequeue elements */\nint popFirst = deque.removeFirst(); // The first element dequeued\nint popLast = deque.removeLast();   // The last element dequeued\n\n/* Get the length of the deque */\nint size = deque.length;\n\n/* Check if the deque is empty */\nbool isEmpty = deque.isEmpty;\n</code></pre> deque.rs<pre><code>/* Initialize the deque */\nlet mut deque: VecDeque&lt;u32&gt; = VecDeque::new();\n\n/* Enqueue elements */\ndeque.push_back(2);  // Add to the tail\ndeque.push_back(5);\ndeque.push_back(4);\ndeque.push_front(3); // Add to the head\ndeque.push_front(1);\n\n/* Access elements */\nif let Some(front) = deque.front() { // The first element\n}\nif let Some(rear) = deque.back() {   // The last element\n}\n\n/* Dequeue elements */\nif let Some(pop_front) = deque.pop_front() { // The first element dequeued\n}\nif let Some(pop_rear) = deque.pop_back() {   // The last element dequeued\n}\n\n/* Get the length of the deque */\nlet size = deque.len();\n\n/* Check if the deque is empty */\nlet is_empty = deque.is_empty();\n</code></pre> deque.c<pre><code>// C does not provide a built-in deque\n</code></pre> deque.kt<pre><code>\n</code></pre> deque.zig<pre><code>\n</code></pre> Visualizing Code <p>https://pythontutor.com/render.html#code=from%20collections%20import%20deque%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%0A%20%20%20%20deq%20%3D%20deque%28%29%0A%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%85%A5%E9%98%9F%0A%20%20%20%20deq.append%282%29%20%20%23%20%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%98%9F%E5%B0%BE%0A%20%20%20%20deq.append%285%29%0A%20%20%20%20deq.append%284%29%0A%20%20%20%20deq.appendleft%283%29%20%20%23%20%E6%B7%BB%E5%8A%A0%E8%87%B3%E9%98%9F%E9%A6%96%0A%20%20%20%20deq.appendleft%281%29%0A%20%20%20%20print%28%22%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%20deque%20%3D%22,%20deq%29%0A%0A%20%20%20%20%23%20%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%0A%20%20%20%20front%20%3D%20deq%5B0%5D%20%20%23%20%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0%0A%20%20%20%20print%28%22%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0%20front%20%3D%22,%20front%29%0A%20%20%20%20rear%20%3D%20deq%5B-1%5D%20%20%23%20%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%0A%20%20%20%20print%28%22%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%20rear%20%3D%22,%20rear%29%0A%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F%0A%20%20%20%20pop_front%20%3D%20deq.popleft%28%29%20%20%23%20%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F%0A%20%20%20%20print%28%22%E9%98%9F%E9%A6%96%E5%87%BA%E9%98%9F%E5%85%83%E7%B4%A0%20%20pop_front%20%3D%22,%20pop_front%29%0A%20%20%20%20print%28%22%E9%98%9F%E9%A6%96%E5%87%BA%E9%98%9F%E5%90%8E%20deque%20%3D%22,%20deq%29%0A%20%20%20%20pop_rear%20%3D%20deq.pop%28%29%20%20%23%20%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F%0A%20%20%20%20print%28%22%E9%98%9F%E5%B0%BE%E5%87%BA%E9%98%9F%E5%85%83%E7%B4%A0%20%20pop_rear%20%3D%22,%20pop_rear%29%0A%20%20%20%20print%28%22%E9%98%9F%E5%B0%BE%E5%87%BA%E9%98%9F%E5%90%8E%20deque%20%3D%22,%20deq%29%0A%0A%20%20%20%20%23%20%E8%8E%B7%E5%8F%96%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%0A%20%20%20%20size%20%3D%20len%28deq%29%0A%20%20%20%20print%28%22%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6%20size%20%3D%22,%20size%29%0A%0A%20%20%20%20%23%20%E5%88%A4%E6%96%AD%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%0A%20%20%20%20is_empty%20%3D%20len%28deq%29%20%3D%3D%200%0A%20%20%20%20print%28%22%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%20%3D%22,%20is_empty%29&amp;cumulative=false&amp;curInstr=3&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_stack_and_queue/deque/#implementing-a-double-ended-queue","title":"Implementing a double-ended queue *","text":"<p>The implementation of a double-ended queue is similar to that of a regular queue, it can be based on either a linked list or an array as the underlying data structure.</p>"},{"location":"chapter_stack_and_queue/deque/#implementation-based-on-doubly-linked-list","title":"Implementation based on doubly linked list","text":"<p>Recall from the previous section that we used a regular singly linked list to implement a queue, as it conveniently allows for deleting from the head (corresponding to the dequeue operation) and adding new elements after the tail (corresponding to the enqueue operation).</p> <p>For a double-ended queue, both the head and the tail can perform enqueue and dequeue operations. In other words, a double-ended queue needs to implement operations in the opposite direction as well. For this, we use a \"doubly linked list\" as the underlying data structure of the double-ended queue.</p> <p>As shown in the figure below, we treat the head and tail nodes of the doubly linked list as the front and rear of the double-ended queue, respectively, and implement the functionality to add and remove nodes at both ends.</p> LinkedListDequepushLast()pushFirst()popLast()popFirst() <p></p> <p></p> <p></p> <p></p> <p></p> <p>The implementation code is as follows:</p> <pre><code>[file]{linkedlist_deque}-[class]{linked_list_deque}-[func]{}\n</code></pre>"},{"location":"chapter_stack_and_queue/deque/#implementation-based-on-array","title":"Implementation based on array","text":"<p>As shown in the figure below, similar to implementing a queue with an array, we can also use a circular array to implement a double-ended queue.</p> ArrayDequepushLast()pushFirst()popLast()popFirst() <p></p> <p></p> <p></p> <p></p> <p></p> <p>The implementation only needs to add methods for \"front enqueue\" and \"rear dequeue\":</p> <pre><code>[file]{array_deque}-[class]{array_deque}-[func]{}\n</code></pre>"},{"location":"chapter_stack_and_queue/deque/#applications-of-double-ended-queue","title":"Applications of double-ended queue","text":"<p>The double-ended queue combines the logic of both stacks and queues, thus, it can implement all their respective use cases while offering greater flexibility.</p> <p>We know that software's \"undo\" feature is typically implemented using a stack: the system <code>pushes</code> each change operation onto the stack and then <code>pops</code> to implement undoing. However, considering the limitations of system resources, software often restricts the number of undo steps (for example, only allowing the last 50 steps). When the stack length exceeds 50, the software needs to perform a deletion operation at the bottom of the stack (the front of the queue). But a regular stack cannot perform this function, where a double-ended queue becomes necessary. Note that the core logic of \"undo\" still follows the Last-In-First-Out principle of a stack, but a double-ended queue can more flexibly implement some additional logic.</p>"},{"location":"chapter_stack_and_queue/queue/","title":"5.2 Queue","text":""},{"location":"chapter_stack_and_queue/queue/#queue","title":"Queue","text":"<p>A queue is a linear data structure that follows the First-In-First-Out (FIFO) rule. As the name suggests, a queue simulates the phenomenon of lining up, where newcomers join the queue at the rear, and the person at the front leaves the queue first.</p> <p>As shown in the figure below, we call the front of the queue the \"head\" and the back the \"tail.\" The operation of adding elements to the rear of the queue is termed \"enqueue,\" and the operation of removing elements from the front is termed \"dequeue.\"</p> <p></p>"},{"location":"chapter_stack_and_queue/queue/#common-operations-on-queue","title":"Common operations on queue","text":"<p>The common operations on a queue are shown in the table below. Note that method names may vary across different programming languages. Here, we use the same naming convention as that used for stacks.</p> <p> Table  \u00a0 Efficiency of queue operations </p> Method Name Description Time Complexity <code>push()</code> Enqueue an element, add it to the tail \\(O(1)\\) <code>pop()</code> Dequeue the head element \\(O(1)\\) <code>peek()</code> Access the head element \\(O(1)\\) <p>We can directly use the ready-made queue classes in programming languages:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig queue.py<pre><code>from collections import deque\n\n# Initialize the queue\n# In Python, we generally use the deque class as a queue\n# Although queue.Queue() is a pure queue class, it's not very user-friendly, so it's not recommended\nque: deque[int] = deque()\n\n# Enqueue elements\nque.append(1)\nque.append(3)\nque.append(2)\nque.append(5)\nque.append(4)\n\n# Access the first element\nfront: int = que[0]\n\n# Dequeue an element\npop: int = que.popleft()\n\n# Get the length of the queue\nsize: int = len(que)\n\n# Check if the queue is empty\nis_empty: bool = len(que) == 0\n</code></pre> queue.cpp<pre><code>/* Initialize the queue */\nqueue&lt;int&gt; queue;\n\n/* Enqueue elements */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* Access the first element*/\nint front = queue.front();\n\n/* Dequeue an element */\nqueue.pop();\n\n/* Get the length of the queue */\nint size = queue.size();\n\n/* Check if the queue is empty */\nbool empty = queue.empty();\n</code></pre> queue.java<pre><code>/* Initialize the queue */\nQueue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n\n/* Enqueue elements */\nqueue.offer(1);\nqueue.offer(3);\nqueue.offer(2);\nqueue.offer(5);\nqueue.offer(4);\n\n/* Access the first element */\nint peek = queue.peek();\n\n/* Dequeue an element */\nint pop = queue.poll();\n\n/* Get the length of the queue */\nint size = queue.size();\n\n/* Check if the queue is empty */\nboolean isEmpty = queue.isEmpty();\n</code></pre> queue.cs<pre><code>/* Initialize the queue */\nQueue&lt;int&gt; queue = new();\n\n/* Enqueue elements */\nqueue.Enqueue(1);\nqueue.Enqueue(3);\nqueue.Enqueue(2);\nqueue.Enqueue(5);\nqueue.Enqueue(4);\n\n/* Access the first element */\nint peek = queue.Peek();\n\n/* Dequeue an element */\nint pop = queue.Dequeue();\n\n/* Get the length of the queue */\nint size = queue.Count;\n\n/* Check if the queue is empty */\nbool isEmpty = queue.Count == 0;\n</code></pre> queue_test.go<pre><code>/* Initialize the queue */\n// In Go, use list as a queue\nqueue := list.New()\n\n/* Enqueue elements */\nqueue.PushBack(1)\nqueue.PushBack(3)\nqueue.PushBack(2)\nqueue.PushBack(5)\nqueue.PushBack(4)\n\n/* Access the first element */\npeek := queue.Front()\n\n/* Dequeue an element */\npop := queue.Front()\nqueue.Remove(pop)\n\n/* Get the length of the queue */\nsize := queue.Len()\n\n/* Check if the queue is empty */\nisEmpty := queue.Len() == 0\n</code></pre> queue.swift<pre><code>/* Initialize the queue */\n// Swift does not have a built-in queue class, so Array can be used as a queue\nvar queue: [Int] = []\n\n/* Enqueue elements */\nqueue.append(1)\nqueue.append(3)\nqueue.append(2)\nqueue.append(5)\nqueue.append(4)\n\n/* Access the first element */\nlet peek = queue.first!\n\n/* Dequeue an element */\n// Since it's an array, removeFirst has a complexity of O(n)\nlet pool = queue.removeFirst()\n\n/* Get the length of the queue */\nlet size = queue.count\n\n/* Check if the queue is empty */\nlet isEmpty = queue.isEmpty\n</code></pre> queue.js<pre><code>/* Initialize the queue */\n// JavaScript does not have a built-in queue, so Array can be used as a queue\nconst queue = [];\n\n/* Enqueue elements */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* Access the first element */\nconst peek = queue[0];\n\n/* Dequeue an element */\n// Since the underlying structure is an array, shift() method has a time complexity of O(n)\nconst pop = queue.shift();\n\n/* Get the length of the queue */\nconst size = queue.length;\n\n/* Check if the queue is empty */\nconst empty = queue.length === 0;\n</code></pre> queue.ts<pre><code>/* Initialize the queue */\n// TypeScript does not have a built-in queue, so Array can be used as a queue \nconst queue: number[] = [];\n\n/* Enqueue elements */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* Access the first element */\nconst peek = queue[0];\n\n/* Dequeue an element */\n// Since the underlying structure is an array, shift() method has a time complexity of O(n)\nconst pop = queue.shift();\n\n/* Get the length of the queue */\nconst size = queue.length;\n\n/* Check if the queue is empty */\nconst empty = queue.length === 0;\n</code></pre> queue.dart<pre><code>/* Initialize the queue */\n// In Dart, the Queue class is a double-ended queue but can be used as a queue\nQueue&lt;int&gt; queue = Queue();\n\n/* Enqueue elements */\nqueue.add(1);\nqueue.add(3);\nqueue.add(2);\nqueue.add(5);\nqueue.add(4);\n\n/* Access the first element */\nint peek = queue.first;\n\n/* Dequeue an element */\nint pop = queue.removeFirst();\n\n/* Get the length of the queue */\nint size = queue.length;\n\n/* Check if the queue is empty */\nbool isEmpty = queue.isEmpty;\n</code></pre> queue.rs<pre><code>/* Initialize the double-ended queue */\n// In Rust, use a double-ended queue as a regular queue\nlet mut deque: VecDeque&lt;u32&gt; = VecDeque::new();\n\n/* Enqueue elements */\ndeque.push_back(1);\ndeque.push_back(3);\ndeque.push_back(2);\ndeque.push_back(5);\ndeque.push_back(4);\n\n/* Access the first element */\nif let Some(front) = deque.front() {\n}\n\n/* Dequeue an element */\nif let Some(pop) = deque.pop_front() {\n}\n\n/* Get the length of the queue */\nlet size = deque.len();\n\n/* Check if the queue is empty */\nlet is_empty = deque.is_empty();\n</code></pre> queue.c<pre><code>// C does not provide a built-in queue\n</code></pre> queue.kt<pre><code>\n</code></pre> queue.zig<pre><code>\n</code></pre> Code Visualization <p>https://pythontutor.com/render.html#code=from%20collections%20import%20deque%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%9F%E5%88%97%0A%20%20%20%20%23%20%E5%9C%A8%20Python%20%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%88%AC%E5%B0%86%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E7%B1%BB%20deque%20%E7%9C%8B%E4%BD%9C%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%0A%20%20%20%20%23%20%E8%99%BD%E7%84%B6%20queue.Queue%28%29%20%E6%98%AF%E7%BA%AF%E6%AD%A3%E7%9A%84%E9%98%9F%E5%88%97%E7%B1%BB%EF%BC%8C%E4%BD%86%E4%B8%8D%E5%A4%AA%E5%A5%BD%E7%94%A8%0A%20%20%20%20que%20%3D%20deque%28%29%0A%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%85%A5%E9%98%9F%0A%20%20%20%20que.append%281%29%0A%20%20%20%20que.append%283%29%0A%20%20%20%20que.append%282%29%0A%20%20%20%20que.append%285%29%0A%20%20%20%20que.append%284%29%0A%20%20%20%20print%28%22%E9%98%9F%E5%88%97%20que%20%3D%22,%20que%29%0A%0A%20%20%20%20%23%20%E8%AE%BF%E9%97%AE%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0%0A%20%20%20%20front%20%3D%20que%5B0%5D%0A%20%20%20%20print%28%22%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0%20front%20%3D%22,%20front%29%0A%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%87%BA%E9%98%9F%0A%20%20%20%20pop%20%3D%20que.popleft%28%29%0A%20%20%20%20print%28%22%E5%87%BA%E9%98%9F%E5%85%83%E7%B4%A0%20pop%20%3D%22,%20pop%29%0A%20%20%20%20print%28%22%E5%87%BA%E9%98%9F%E5%90%8E%20que%20%3D%22,%20que%29%0A%0A%20%20%20%20%23%20%E8%8E%B7%E5%8F%96%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6%0A%20%20%20%20size%20%3D%20len%28que%29%0A%20%20%20%20print%28%22%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6%20size%20%3D%22,%20size%29%0A%0A%20%20%20%20%23%20%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%0A%20%20%20%20is_empty%20%3D%20len%28que%29%20%3D%3D%200%0A%20%20%20%20print%28%22%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%20%3D%22,%20is_empty%29&amp;cumulative=false&amp;curInstr=3&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_stack_and_queue/queue/#implementing-a-queue","title":"Implementing a queue","text":"<p>To implement a queue, we need a data structure that allows adding elements at one end and removing them at the other. Both linked lists and arrays meet this requirement.</p>"},{"location":"chapter_stack_and_queue/queue/#implementation-based-on-a-linked-list","title":"Implementation based on a linked list","text":"<p>As shown in the figure below, we can consider the \"head node\" and \"tail node\" of a linked list as the \"front\" and \"rear\" of the queue, respectively. It is stipulated that nodes can only be added at the rear and removed at the front.</p> LinkedListQueuepush()pop() <p></p> <p></p> <p></p> <p>Below is the code for implementing a queue using a linked list:</p> <pre><code>[file]{linkedlist_queue}-[class]{linked_list_queue}-[func]{}\n</code></pre>"},{"location":"chapter_stack_and_queue/queue/#implementation-based-on-an-array","title":"Implementation based on an array","text":"<p>Deleting the first element in an array has a time complexity of \\(O(n)\\), which would make the dequeue operation inefficient. However, this problem can be cleverly avoided as follows.</p> <p>We use a variable <code>front</code> to indicate the index of the front element and maintain a variable <code>size</code> to record the queue's length. Define <code>rear = front + size</code>, which points to the position immediately following the tail element.</p> <p>With this design, the effective interval of elements in the array is <code>[front, rear - 1]</code>. The implementation methods for various operations are shown in the figure below.</p> <ul> <li>Enqueue operation: Assign the input element to the <code>rear</code> index and increase <code>size</code> by 1.</li> <li>Dequeue operation: Simply increase <code>front</code> by 1 and decrease <code>size</code> by 1.</li> </ul> <p>Both enqueue and dequeue operations only require a single operation, each with a time complexity of \\(O(1)\\).</p> ArrayQueuepush()pop() <p></p> <p></p> <p></p> <p>You might notice a problem: as enqueue and dequeue operations are continuously performed, both <code>front</code> and <code>rear</code> move to the right and will eventually reach the end of the array and can't move further. To resolve this, we can treat the array as a \"circular array\" where connecting the end of the array back to its beginning.</p> <p>In a circular array, <code>front</code> or <code>rear</code> needs to loop back to the start of the array upon reaching the end. This cyclical pattern can be achieved with a \"modulo operation\" as shown in the code below:</p> <pre><code>[file]{array_queue}-[class]{array_queue}-[func]{}\n</code></pre> <p>The above implementation of the queue still has its limitations: its length is fixed. However, this issue is not difficult to resolve. We can replace the array with a dynamic array that can expand itself if needed. Interested readers can try to implement this themselves.</p> <p>The comparison of the two implementations is consistent with that of the stack and is not repeated here.</p>"},{"location":"chapter_stack_and_queue/queue/#typical-applications-of-queue","title":"Typical applications of queue","text":"<ul> <li>Amazon orders: After shoppers place orders, these orders join a queue, and the system processes them in order. During events like Singles' Day, a massive number of orders are generated in a short time, making high concurrency a key challenge for engineers.</li> <li>Various to-do lists: Any scenario requiring a \"first-come, first-served\" functionality, such as a printer's task queue or a restaurant's food delivery queue, can effectively maintain the order of processing with a queue.</li> </ul>"},{"location":"chapter_stack_and_queue/stack/","title":"5.1 Stack","text":""},{"location":"chapter_stack_and_queue/stack/#stack","title":"Stack","text":"<p>A stack is a linear data structure that follows the principle of Last-In-First-Out (LIFO).</p> <p>We can compare a stack to a pile of plates on a table. To access the bottom plate, one must first remove the plates on top. By replacing the plates with various types of elements (such as integers, characters, objects, etc.), we obtain the data structure known as a stack.</p> <p>As shown in the figure below, we refer to the top of the pile of elements as the \"top of the stack\" and the bottom as the \"bottom of the stack.\" The operation of adding elements to the top of the stack is called \"push,\" and the operation of removing the top element is called \"pop.\"</p> <p></p>"},{"location":"chapter_stack_and_queue/stack/#common-operations-on-stack","title":"Common operations on stack","text":"<p>The common operations on a stack are shown in the table below. The specific method names depend on the programming language used. Here, we use <code>push()</code>, <code>pop()</code>, and <code>peek()</code> as examples.</p> <p> Table  \u00a0 Efficiency of stack operations </p> Method Description Time Complexity <code>push()</code> Push an element onto the stack (add to the top) \\(O(1)\\) <code>pop()</code> Pop the top element from the stack \\(O(1)\\) <code>peek()</code> Access the top element of the stack \\(O(1)\\) <p>Typically, we can directly use the stack class built into the programming language. However, some languages may not specifically provide a stack class. In these cases, we can use the language's \"array\" or \"linked list\" as a stack and ignore operations that are not related to stack logic in the program.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinZig stack.py<pre><code># Initialize the stack\n# Python does not have a built-in stack class, so a list can be used as a stack\nstack: list[int] = []\n\n# Push elements onto the stack\nstack.append(1)\nstack.append(3)\nstack.append(2)\nstack.append(5)\nstack.append(4)\n\n# Access the top element of the stack\npeek: int = stack[-1]\n\n# Pop an element from the stack\npop: int = stack.pop()\n\n# Get the length of the stack\nsize: int = len(stack)\n\n# Check if the stack is empty\nis_empty: bool = len(stack) == 0\n</code></pre> stack.cpp<pre><code>/* Initialize the stack */\nstack&lt;int&gt; stack;\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nint top = stack.top();\n\n/* Pop an element from the stack */\nstack.pop(); // No return value\n\n/* Get the length of the stack */\nint size = stack.size();\n\n/* Check if the stack is empty */\nbool empty = stack.empty();\n</code></pre> stack.java<pre><code>/* Initialize the stack */\nStack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nint peek = stack.peek();\n\n/* Pop an element from the stack */\nint pop = stack.pop();\n\n/* Get the length of the stack */\nint size = stack.size();\n\n/* Check if the stack is empty */\nboolean isEmpty = stack.isEmpty();\n</code></pre> stack.cs<pre><code>/* Initialize the stack */\nStack&lt;int&gt; stack = new();\n\n/* Push elements onto the stack */\nstack.Push(1);\nstack.Push(3);\nstack.Push(2);\nstack.Push(5);\nstack.Push(4);\n\n/* Access the top element of the stack */\nint peek = stack.Peek();\n\n/* Pop an element from the stack */\nint pop = stack.Pop();\n\n/* Get the length of the stack */\nint size = stack.Count;\n\n/* Check if the stack is empty */\nbool isEmpty = stack.Count == 0;\n</code></pre> stack_test.go<pre><code>/* Initialize the stack */\n// In Go, it is recommended to use a Slice as a stack\nvar stack []int\n\n/* Push elements onto the stack */\nstack = append(stack, 1)\nstack = append(stack, 3)\nstack = append(stack, 2)\nstack = append(stack, 5)\nstack = append(stack, 4)\n\n/* Access the top element of the stack */\npeek := stack[len(stack)-1]\n\n/* Pop an element from the stack */\npop := stack[len(stack)-1]\nstack = stack[:len(stack)-1]\n\n/* Get the length of the stack */\nsize := len(stack)\n\n/* Check if the stack is empty */\nisEmpty := len(stack) == 0\n</code></pre> stack.swift<pre><code>/* Initialize the stack */\n// Swift does not have a built-in stack class, so Array can be used as a stack\nvar stack: [Int] = []\n\n/* Push elements onto the stack */\nstack.append(1)\nstack.append(3)\nstack.append(2)\nstack.append(5)\nstack.append(4)\n\n/* Access the top element of the stack */\nlet peek = stack.last!\n\n/* Pop an element from the stack */\nlet pop = stack.removeLast()\n\n/* Get the length of the stack */\nlet size = stack.count\n\n/* Check if the stack is empty */\nlet isEmpty = stack.isEmpty\n</code></pre> stack.js<pre><code>/* Initialize the stack */\n// JavaScript does not have a built-in stack class, so Array can be used as a stack\nconst stack = [];\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nconst peek = stack[stack.length-1];\n\n/* Pop an element from the stack */\nconst pop = stack.pop();\n\n/* Get the length of the stack */\nconst size = stack.length;\n\n/* Check if the stack is empty */\nconst is_empty = stack.length === 0;\n</code></pre> stack.ts<pre><code>/* Initialize the stack */\n// TypeScript does not have a built-in stack class, so Array can be used as a stack\nconst stack: number[] = [];\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nconst peek = stack[stack.length - 1];\n\n/* Pop an element from the stack */\nconst pop = stack.pop();\n\n/* Get the length of the stack */\nconst size = stack.length;\n\n/* Check if the stack is empty */\nconst is_empty = stack.length === 0;\n</code></pre> stack.dart<pre><code>/* Initialize the stack */\n// Dart does not have a built-in stack class, so List can be used as a stack\nList&lt;int&gt; stack = [];\n\n/* Push elements onto the stack */\nstack.add(1);\nstack.add(3);\nstack.add(2);\nstack.add(5);\nstack.add(4);\n\n/* Access the top element of the stack */\nint peek = stack.last;\n\n/* Pop an element from the stack */\nint pop = stack.removeLast();\n\n/* Get the length of the stack */\nint size = stack.length;\n\n/* Check if the stack is empty */\nbool isEmpty = stack.isEmpty;\n</code></pre> stack.rs<pre><code>/* Initialize the stack */\n// Use Vec as a stack\nlet mut stack: Vec&lt;i32&gt; = Vec::new();\n\n/* Push elements onto the stack */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* Access the top element of the stack */\nlet top = stack.last().unwrap();\n\n/* Pop an element from the stack */\nlet pop = stack.pop().unwrap();\n\n/* Get the length of the stack */\nlet size = stack.len();\n\n/* Check if the stack is empty */\nlet is_empty = stack.is_empty();\n</code></pre> stack.c<pre><code>// C does not provide a built-in stack\n</code></pre> stack.kt<pre><code>\n</code></pre> stack.zig<pre><code>\n</code></pre> Code Visualization <p>https://pythontutor.com/render.html#code=%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88%0A%20%20%20%20%23%20Python%20%E6%B2%A1%E6%9C%89%E5%86%85%E7%BD%AE%E7%9A%84%E6%A0%88%E7%B1%BB%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8A%8A%20list%20%E5%BD%93%E4%BD%9C%E6%A0%88%E6%9D%A5%E4%BD%BF%E7%94%A8%0A%20%20%20%20stack%20%3D%20%5B%5D%0A%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%85%A5%E6%A0%88%0A%20%20%20%20stack.append%281%29%0A%20%20%20%20stack.append%283%29%0A%20%20%20%20stack.append%282%29%0A%20%20%20%20stack.append%285%29%0A%20%20%20%20stack.append%284%29%0A%20%20%20%20print%28%22%E6%A0%88%20stack%20%3D%22,%20stack%29%0A%0A%20%20%20%20%23%20%E8%AE%BF%E9%97%AE%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%0A%20%20%20%20peek%20%3D%20stack%5B-1%5D%0A%20%20%20%20print%28%22%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0%20peek%20%3D%22,%20peek%29%0A%0A%20%20%20%20%23%20%E5%85%83%E7%B4%A0%E5%87%BA%E6%A0%88%0A%20%20%20%20pop%20%3D%20stack.pop%28%29%0A%20%20%20%20print%28%22%E5%87%BA%E6%A0%88%E5%85%83%E7%B4%A0%20pop%20%3D%22,%20pop%29%0A%20%20%20%20print%28%22%E5%87%BA%E6%A0%88%E5%90%8E%20stack%20%3D%22,%20stack%29%0A%0A%20%20%20%20%23%20%E8%8E%B7%E5%8F%96%E6%A0%88%E7%9A%84%E9%95%BF%E5%BA%A6%0A%20%20%20%20size%20%3D%20len%28stack%29%0A%20%20%20%20print%28%22%E6%A0%88%E7%9A%84%E9%95%BF%E5%BA%A6%20size%20%3D%22,%20size%29%0A%0A%20%20%20%20%23%20%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%0A%20%20%20%20is_empty%20%3D%20len%28stack%29%20%3D%3D%200%0A%20%20%20%20print%28%22%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%20%3D%22,%20is_empty%29&amp;cumulative=false&amp;curInstr=2&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_stack_and_queue/stack/#implementing-a-stack","title":"Implementing a stack","text":"<p>To gain a deeper understanding of how a stack operates, let's try implementing a stack class ourselves.</p> <p>A stack follows the principle of Last-In-First-Out, which means we can only add or remove elements at the top of the stack. However, both arrays and linked lists allow adding and removing elements at any position, therefore a stack can be seen as a restricted array or linked list. In other words, we can \"shield\" certain irrelevant operations of an array or linked list, aligning their external behavior with the characteristics of a stack.</p>"},{"location":"chapter_stack_and_queue/stack/#implementation-based-on-a-linked-list","title":"Implementation based on a linked list","text":"<p>When implementing a stack using a linked list, we can consider the head node of the list as the top of the stack and the tail node as the bottom of the stack.</p> <p>As shown in the figure below, for the push operation, we simply insert elements at the head of the linked list. This method of node insertion is known as \"head insertion.\" For the pop operation, we just need to remove the head node from the list.</p> LinkedListStackpush()pop() <p></p> <p></p> <p></p> <p>Below is an example code for implementing a stack based on a linked list:</p> <pre><code>[file]{linkedlist_stack}-[class]{linked_list_stack}-[func]{}\n</code></pre>"},{"location":"chapter_stack_and_queue/stack/#implementation-based-on-an-array","title":"Implementation based on an array","text":"<p>When implementing a stack using an array, we can consider the end of the array as the top of the stack. As shown in the figure below, push and pop operations correspond to adding and removing elements at the end of the array, respectively, both with a time complexity of \\(O(1)\\).</p> ArrayStackpush()pop() <p></p> <p></p> <p></p> <p>Since the elements to be pushed onto the stack may continuously increase, we can use a dynamic array, thus avoiding the need to handle array expansion ourselves. Here is an example code:</p> <pre><code>[file]{array_stack}-[class]{array_stack}-[func]{}\n</code></pre>"},{"location":"chapter_stack_and_queue/stack/#comparison-of-the-two-implementations","title":"Comparison of the two implementations","text":"<p>Supported Operations</p> <p>Both implementations support all the operations defined in a stack. The array implementation additionally supports random access, but this is beyond the scope of a stack definition and is generally not used.</p> <p>Time Efficiency</p> <p>In the array-based implementation, both push and pop operations occur in pre-allocated contiguous memory, which has good cache locality and therefore higher efficiency. However, if the push operation exceeds the array capacity, it triggers a resizing mechanism, making the time complexity of that push operation \\(O(n)\\).</p> <p>In the linked list implementation, list expansion is very flexible, and there is no efficiency decrease issue as in array expansion. However, the push operation requires initializing a node object and modifying pointers, so its efficiency is relatively lower. If the elements being pushed are already node objects, then the initialization step can be skipped, improving efficiency.</p> <p>Thus, when the elements for push and pop operations are basic data types like <code>int</code> or <code>double</code>, we can draw the following conclusions:</p> <ul> <li>The array-based stack implementation's efficiency decreases during expansion, but since expansion is a low-frequency operation, its average efficiency is higher.</li> <li>The linked list-based stack implementation provides more stable efficiency performance.</li> </ul> <p>Space Efficiency</p> <p>When initializing a list, the system allocates an \"initial capacity,\" which might exceed the actual need; moreover, the expansion mechanism usually increases capacity by a specific factor (like doubling), which may also exceed the actual need. Therefore, the array-based stack might waste some space.</p> <p>However, since linked list nodes require extra space for storing pointers, the space occupied by linked list nodes is relatively larger.</p> <p>In summary, we cannot simply determine which implementation is more memory-efficient. It requires analysis based on specific circumstances.</p>"},{"location":"chapter_stack_and_queue/stack/#typical-applications-of-stack","title":"Typical applications of stack","text":"<ul> <li>Back and forward in browsers, undo and redo in software. Every time we open a new webpage, the browser pushes the previous page onto the stack, allowing us to go back to the previous page through the back operation, which is essentially a pop operation. To support both back and forward, two stacks are needed to work together.</li> <li>Memory management in programs. Each time a function is called, the system adds a stack frame at the top of the stack to record the function's context information. In recursive functions, the downward recursion phase keeps pushing onto the stack, while the upward backtracking phase keeps popping from the stack.</li> </ul>"},{"location":"chapter_stack_and_queue/summary/","title":"5.4 Summary","text":""},{"location":"chapter_stack_and_queue/summary/#summary","title":"Summary","text":""},{"location":"chapter_stack_and_queue/summary/#key-review","title":"Key review","text":"<ul> <li>Stack is a data structure that follows the Last-In-First-Out (LIFO) principle and can be implemented using arrays or linked lists.</li> <li>In terms of time efficiency, the array implementation of the stack has a higher average efficiency. However, during expansion, the time complexity for a single push operation can degrade to \\(O(n)\\). In contrast, the linked list implementation of a stack offers more stable efficiency.</li> <li>Regarding space efficiency, the array implementation of the stack may lead to a certain degree of space wastage. However, it's important to note that the memory space occupied by nodes in a linked list is generally larger than that for elements in an array.</li> <li>A queue is a data structure that follows the First-In-First-Out (FIFO) principle, and it can also be implemented using arrays or linked lists. The conclusions regarding time and space efficiency for queues are similar to those for stacks.</li> <li>A double-ended queue (deque) is a more flexible type of queue that allows adding and removing elements at both ends.</li> </ul>"},{"location":"chapter_stack_and_queue/summary/#q-a","title":"Q &amp; A","text":"<p>Q: Is the browser's forward and backward functionality implemented with a doubly linked list?</p> <p>A browser's forward and backward navigation is essentially a manifestation of the \"stack\" concept. When a user visits a new page, the page is added to the top of the stack; when they click the back button, the page is popped from the top of the stack. A double-ended queue (deque) can conveniently implement some additional operations, as mentioned in the \"Double-Ended Queue\" section.</p> <p>Q: After popping from a stack, is it necessary to free the memory of the popped node?</p> <p>If the popped node will still be used later, it's not necessary to free its memory. In languages like Java and Python that have automatic garbage collection, manual memory release is not necessary; in C and C++, manual memory release is required.</p> <p>Q: A double-ended queue seems like two stacks joined together. What are its uses?</p> <p>A double-ended queue, which is a combination of a stack and a queue or two stacks joined together, exhibits both stack and queue logic. Thus, it can implement all applications of stacks and queues while offering more flexibility.</p> <p>Q: How exactly are undo and redo implemented?</p> <p>Undo and redo operations are implemented using two stacks: Stack <code>A</code> for undo and Stack <code>B</code> for redo.</p> <ol> <li>Each time a user performs an operation, it is pushed onto Stack <code>A</code>, and Stack <code>B</code> is cleared.</li> <li>When the user executes an \"undo\", the most recent operation is popped from Stack <code>A</code> and pushed onto Stack <code>B</code>.</li> <li>When the user executes a \"redo\", the most recent operation is popped from Stack <code>B</code> and pushed back onto Stack <code>A</code>.</li> </ol>"},{"location":"chapter_tree/","title":"Tree","text":""},{"location":"chapter_tree/#tree","title":"Tree","text":"<p>Abstract</p> <p>The towering tree exudes a vibrant essence, boasting profound roots and abundant foliage, yet its branches are sparsely scattered, creating an ethereal aura.</p> <p>It shows us the vivid form of divide-and-conquer in data.</p>"},{"location":"chapter_tree/array_representation_of_tree/","title":"7.3 Array Representation of tree","text":""},{"location":"chapter_tree/array_representation_of_tree/#array-representation-of-binary-trees","title":"Array representation of binary trees","text":"<p>Under the linked list representation, the storage unit of a binary tree is a node <code>TreeNode</code>, with nodes connected by pointers. The basic operations of binary trees under the linked list representation were introduced in the previous section.</p> <p>So, can we use an array to represent a binary tree? The answer is yes.</p>"},{"location":"chapter_tree/array_representation_of_tree/#representing-perfect-binary-trees","title":"Representing perfect binary trees","text":"<p>Let's analyze a simple case first. Given a perfect binary tree, we store all nodes in an array according to the order of level-order traversal, where each node corresponds to a unique array index.</p> <p>Based on the characteristics of level-order traversal, we can deduce a \"mapping formula\" between the index of a parent node and its children: If a node's index is \\(i\\), then the index of its left child is \\(2i + 1\\) and the right child is \\(2i + 2\\). The figure below shows the mapping relationship between the indices of various nodes.</p> <p></p> <p>The mapping formula plays a role similar to the node references (pointers) in linked lists. Given any node in the array, we can access its left (right) child node using the mapping formula.</p>"},{"location":"chapter_tree/array_representation_of_tree/#representing-any-binary-tree","title":"Representing any binary tree","text":"<p>Perfect binary trees are a special case; there are often many <code>None</code> values in the middle levels of a binary tree. Since the sequence of level-order traversal does not include these <code>None</code> values, we cannot solely rely on this sequence to deduce the number and distribution of <code>None</code> values. This means that multiple binary tree structures can match the same level-order traversal sequence.</p> <p>As shown in the figure below, given a non-perfect binary tree, the above method of array representation fails.</p> <p></p> <p>To solve this problem, we can consider explicitly writing out all <code>None</code> values in the level-order traversal sequence. As shown in the figure below, after this treatment, the level-order traversal sequence can uniquely represent a binary tree. Example code is as follows:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig <pre><code># Array representation of a binary tree\n# Using None to represent empty slots\ntree = [1, 2, 3, 4, None, 6, 7, 8, 9, None, None, 12, None, None, 15]\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using the maximum integer value INT_MAX to mark empty slots\nvector&lt;int&gt; tree = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15};\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using the Integer wrapper class allows for using null to mark empty slots\nInteger[] tree = { 1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15 };\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using nullable int (int?) allows for using null to mark empty slots\nint?[] tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using an any type slice, allowing for nil to mark empty slots\ntree := []any{1, 2, 3, 4, nil, 6, 7, 8, 9, nil, nil, 12, nil, nil, 15}\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using optional Int (Int?) allows for using nil to mark empty slots\nlet tree: [Int?] = [1, 2, 3, 4, nil, 6, 7, 8, 9, nil, nil, 12, nil, nil, 15]\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using null to represent empty slots\nlet tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using null to represent empty slots\nlet tree: (number | null)[] = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using nullable int (int?) allows for using null to mark empty slots\nList&lt;int?&gt; tree = [1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using None to mark empty slots\nlet tree = [Some(1), Some(2), Some(3), Some(4), None, Some(6), Some(7), Some(8), Some(9), None, None, Some(12), None, None, Some(15)];\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using the maximum int value to mark empty slots, therefore, node values must not be INT_MAX\nint tree[] = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15};\n</code></pre> <pre><code>/* Array representation of a binary tree */\n// Using null to represent empty slots\nval tree = mutableListOf( 1, 2, 3, 4, null, 6, 7, 8, 9, null, null, 12, null, null, 15 )\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p></p> <p>It's worth noting that complete binary trees are very suitable for array representation. Recalling the definition of a complete binary tree, <code>None</code> appears only at the bottom level and towards the right, meaning all <code>None</code> values definitely appear at the end of the level-order traversal sequence.</p> <p>This means that when using an array to represent a complete binary tree, it's possible to omit storing all <code>None</code> values, which is very convenient. The figure below gives an example.</p> <p></p> <p>The following code implements a binary tree based on array representation, including the following operations:</p> <ul> <li>Given a node, obtain its value, left (right) child node, and parent node.</li> <li>Obtain the pre-order, in-order, post-order, and level-order traversal sequences.</li> </ul> <pre><code>[file]{array_binary_tree}-[class]{array_binary_tree}-[func]{}\n</code></pre>"},{"location":"chapter_tree/array_representation_of_tree/#advantages-and-limitations","title":"Advantages and limitations","text":"<p>The array representation of binary trees has the following advantages:</p> <ul> <li>Arrays are stored in contiguous memory spaces, which is cache-friendly and allows for faster access and traversal.</li> <li>It does not require storing pointers, which saves space.</li> <li>It allows random access to nodes.</li> </ul> <p>However, the array representation also has some limitations:</p> <ul> <li>Array storage requires contiguous memory space, so it is not suitable for storing trees with a large amount of data.</li> <li>Adding or deleting nodes requires array insertion and deletion operations, which are less efficient.</li> <li>When there are many <code>None</code> values in the binary tree, the proportion of node data contained in the array is low, leading to lower space utilization.</li> </ul>"},{"location":"chapter_tree/avl_tree/","title":"7.5 AVL tree *","text":""},{"location":"chapter_tree/avl_tree/#avl-tree","title":"AVL tree *","text":"<p>In the \"Binary Search Tree\" section, we mentioned that after multiple insertions and removals, a binary search tree might degrade to a linked list. In such cases, the time complexity of all operations degrades from \\(O(\\log n)\\) to \\(O(n)\\).</p> <p>As shown in the figure below, after two node removal operations, this binary search tree will degrade into a linked list.</p> <p></p> <p>For example, in the perfect binary tree shown in the figure below, after inserting two nodes, the tree will lean heavily to the left, and the time complexity of search operations will also degrade.</p> <p></p> <p>In 1962, G. M. Adelson-Velsky and E. M. Landis proposed the AVL Tree in their paper \"An algorithm for the organization of information\". The paper detailed a series of operations to ensure that after continuously adding and removing nodes, the AVL tree would not degrade, thus maintaining the time complexity of various operations at \\(O(\\log n)\\) level. In other words, in scenarios where frequent additions, removals, searches, and modifications are needed, the AVL tree can always maintain efficient data operation performance, which has great application value.</p>"},{"location":"chapter_tree/avl_tree/#common-terminology-in-avl-trees","title":"Common terminology in AVL trees","text":"<p>An AVL tree is both a binary search tree and a balanced binary tree, satisfying all properties of these two types of binary trees, hence it is a balanced binary search tree.</p>"},{"location":"chapter_tree/avl_tree/#node-height","title":"Node height","text":"<p>Since the operations related to AVL trees require obtaining node heights, we need to add a <code>height</code> variable to the node class:</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig <pre><code>class TreeNode:\n    \"\"\"AVL tree node\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                 # Node value\n        self.height: int = 0                # Node height\n        self.left: TreeNode | None = None   # Left child reference\n        self.right: TreeNode | None = None  # Right child reference\n</code></pre> <pre><code>/* AVL tree node */\nstruct TreeNode {\n    int val{};          // Node value\n    int height = 0;     // Node height\n    TreeNode *left{};   // Left child\n    TreeNode *right{};  // Right child\n    TreeNode() = default;\n    explicit TreeNode(int x) : val(x){}\n};\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    public int val;        // Node value\n    public int height;     // Node height\n    public TreeNode left;  // Left child\n    public TreeNode right; // Right child\n    public TreeNode(int x) { val = x; }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode(int? x) {\n    public int? val = x;    // Node value\n    public int height;      // Node height\n    public TreeNode? left;  // Left child reference\n    public TreeNode? right; // Right child reference\n}\n</code></pre> <pre><code>/* AVL tree node */\ntype TreeNode struct {\n    Val    int       // Node value\n    Height int       // Node height\n    Left   *TreeNode // Left child reference\n    Right  *TreeNode // Right child reference\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    var val: Int // Node value\n    var height: Int // Node height\n    var left: TreeNode? // Left child\n    var right: TreeNode? // Right child\n\n    init(x: Int) {\n        val = x\n        height = 0\n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    val; // Node value\n    height; // Node height\n    left; // Left child pointer\n    right; // Right child pointer\n    constructor(val, left, right, height) {\n        this.val = val === undefined ? 0 : val;\n        this.height = height === undefined ? 0 : height;\n        this.left = left === undefined ? null : left;\n        this.right = right === undefined ? null : right;\n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n    val: number;            // Node value\n    height: number;         // Node height\n    left: TreeNode | null;  // Left child pointer\n    right: TreeNode | null; // Right child pointer\n    constructor(val?: number, height?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val;\n        this.height = height === undefined ? 0 : height; \n        this.left = left === undefined ? null : left; \n        this.right = right === undefined ? null : right; \n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode {\n  int val;         // Node value\n  int height;      // Node height\n  TreeNode? left;  // Left child\n  TreeNode? right; // Right child\n  TreeNode(this.val, [this.height = 0, this.left, this.right]);\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* AVL tree node */\nstruct TreeNode {\n    val: i32,                               // Node value\n    height: i32,                            // Node height\n    left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,    // Left child\n    right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,   // Right child\n}\n\nimpl TreeNode {\n    /* Constructor */\n    fn new(val: i32) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {\n        Rc::new(RefCell::new(Self {\n            val,\n            height: 0,\n            left: None,\n            right: None\n        }))\n    }\n}\n</code></pre> <pre><code>/* AVL tree node */\nTreeNode struct TreeNode {\n    int val;\n    int height;\n    struct TreeNode *left;\n    struct TreeNode *right;\n} TreeNode;\n\n/* Constructor */\nTreeNode *newTreeNode(int val) {\n    TreeNode *node;\n\n    node = (TreeNode *)malloc(sizeof(TreeNode));\n    node-&gt;val = val;\n    node-&gt;height = 0;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    return node;\n}\n</code></pre> <pre><code>/* AVL tree node */\nclass TreeNode(val _val: Int) {  // Node value\n    val height: Int = 0          // Node height\n    val left: TreeNode? = null   // Left child\n    val right: TreeNode? = null  // Right child\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>The \"node height\" refers to the distance from that node to its farthest leaf node, i.e., the number of \"edges\" passed. It is important to note that the height of a leaf node is \\(0\\), and the height of a null node is \\(-1\\). We will create two utility functions for getting and updating the height of a node:</p> <pre><code>[file]{avl_tree}-[class]{avl_tree}-[func]{update_height}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#node-balance-factor","title":"Node balance factor","text":"<p>The balance factor of a node is defined as the height of the node's left subtree minus the height of its right subtree, with the balance factor of a null node defined as \\(0\\). We will also encapsulate the functionality of obtaining the node balance factor into a function for easy use later on:</p> <pre><code>[file]{avl_tree}-[class]{avl_tree}-[func]{balance_factor}\n</code></pre> <p>Tip</p> <p>Let the balance factor be \\(f\\), then the balance factor of any node in an AVL tree satisfies \\(-1 \\le f \\le 1\\).</p>"},{"location":"chapter_tree/avl_tree/#rotations-in-avl-trees","title":"Rotations in AVL trees","text":"<p>The characteristic feature of an AVL tree is the \"rotation\" operation, which can restore balance to an unbalanced node without affecting the in-order traversal sequence of the binary tree. In other words, the rotation operation can maintain the property of a \"binary search tree\" while also turning the tree back into a \"balanced binary tree\".</p> <p>We call nodes with an absolute balance factor \\(&gt; 1\\) \"unbalanced nodes\". Depending on the type of imbalance, there are four kinds of rotations: right rotation, left rotation, right-left rotation, and left-right rotation. Below, we detail these rotation operations.</p>"},{"location":"chapter_tree/avl_tree/#right-rotation","title":"Right rotation","text":"<p>As shown in the figure below, the first unbalanced node from the bottom up in the binary tree is \"node 3\". Focusing on the subtree with this unbalanced node as the root, denoted as <code>node</code>, and its left child as <code>child</code>, perform a \"right rotation\". After the right rotation, the subtree is balanced again while still maintaining the properties of a binary search tree.</p> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p>As shown in the figure below, when the <code>child</code> node has a right child (denoted as <code>grand_child</code>), a step needs to be added in the right rotation: set <code>grand_child</code> as the left child of <code>node</code>.</p> <p></p> <p>\"Right rotation\" is a figurative term; in practice, it is achieved by modifying node pointers, as shown in the following code:</p> <pre><code>[file]{avl_tree}-[class]{avl_tree}-[func]{right_rotate}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#left-rotation","title":"Left rotation","text":"<p>Correspondingly, if considering the \"mirror\" of the above unbalanced binary tree, the \"left rotation\" operation shown in the figure below needs to be performed.</p> <p></p> <p>Similarly, as shown in the figure below, when the <code>child</code> node has a left child (denoted as <code>grand_child</code>), a step needs to be added in the left rotation: set <code>grand_child</code> as the right child of <code>node</code>.</p> <p></p> <p>It can be observed that the right and left rotation operations are logically symmetrical, and they solve two symmetrical types of imbalance. Based on symmetry, by replacing all <code>left</code> with <code>right</code>, and all <code>right</code> with <code>left</code> in the implementation code of right rotation, we can get the implementation code for left rotation:</p> <pre><code>[file]{avl_tree}-[class]{avl_tree}-[func]{left_rotate}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#left-right-rotation","title":"Left-right rotation","text":"<p>For the unbalanced node 3 shown in the figure below, using either left or right rotation alone cannot restore balance to the subtree. In this case, a \"left rotation\" needs to be performed on <code>child</code> first, followed by a \"right rotation\" on <code>node</code>.</p> <p></p>"},{"location":"chapter_tree/avl_tree/#right-left-rotation","title":"Right-left rotation","text":"<p>As shown in the figure below, for the mirror case of the above unbalanced binary tree, a \"right rotation\" needs to be performed on <code>child</code> first, followed by a \"left rotation\" on <code>node</code>.</p> <p></p>"},{"location":"chapter_tree/avl_tree/#choice-of-rotation","title":"Choice of rotation","text":"<p>The four kinds of imbalances shown in the figure below correspond to the cases described above, respectively requiring right rotation, left-right rotation, right-left rotation, and left rotation.</p> <p></p> <p>As shown in the table below, we determine which of the above cases an unbalanced node belongs to by judging the sign of the balance factor of the unbalanced node and its higher-side child's balance factor.</p> <p> Table  \u00a0 Conditions for Choosing Among the Four Rotation Cases </p> Balance factor of unbalanced node Balance factor of child node Rotation method to use \\(&gt; 1\\) (Left-leaning tree) \\(\\geq 0\\) Right rotation \\(&gt; 1\\) (Left-leaning tree) \\(&lt;0\\) Left rotation then right rotation \\(&lt; -1\\) (Right-leaning tree) \\(\\leq 0\\) Left rotation \\(&lt; -1\\) (Right-leaning tree) \\(&gt;0\\) Right rotation then left rotation <p>For convenience, we encapsulate the rotation operations into a function. With this function, we can perform rotations on various kinds of imbalances, restoring balance to unbalanced nodes. The code is as follows:</p> <pre><code>[file]{avl_tree}-[class]{avl_tree}-[func]{rotate}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#common-operations-in-avl-trees","title":"Common operations in AVL trees","text":""},{"location":"chapter_tree/avl_tree/#node-insertion","title":"Node insertion","text":"<p>The node insertion operation in AVL trees is similar to that in binary search trees. The only difference is that after inserting a node in an AVL tree, a series of unbalanced nodes may appear along the path from that node to the root node. Therefore, we need to start from this node and perform rotation operations upwards to restore balance to all unbalanced nodes. The code is as follows:</p> <pre><code>[file]{avl_tree}-[class]{avl_tree}-[func]{insert_helper}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#node-removal","title":"Node removal","text":"<p>Similarly, based on the method of removing nodes in binary search trees, rotation operations need to be performed from the bottom up to restore balance to all unbalanced nodes. The code is as follows:</p> <pre><code>[file]{avl_tree}-[class]{avl_tree}-[func]{remove_helper}\n</code></pre>"},{"location":"chapter_tree/avl_tree/#node-search","title":"Node search","text":"<p>The node search operation in AVL trees is consistent with that in binary search trees and will not be detailed here.</p>"},{"location":"chapter_tree/avl_tree/#typical-applications-of-avl-trees","title":"Typical applications of AVL trees","text":"<ul> <li>Organizing and storing large amounts of data, suitable for scenarios with high-frequency searches and low-frequency intertions and removals.</li> <li>Used to build index systems in databases.</li> <li>Red-black trees are also a common type of balanced binary search tree. Compared to AVL trees, red-black trees have more relaxed balancing conditions, require fewer rotations for node insertion and removal, and have a higher average efficiency for node addition and removal operations.</li> </ul>"},{"location":"chapter_tree/binary_search_tree/","title":"7.4 Binary Search tree","text":""},{"location":"chapter_tree/binary_search_tree/#binary-search-tree","title":"Binary search tree","text":"<p>As shown in the figure below, a binary search tree satisfies the following conditions.</p> <ol> <li>For the root node, the value of all nodes in the left subtree \\(&lt;\\) the value of the root node \\(&lt;\\) the value of all nodes in the right subtree.</li> <li>The left and right subtrees of any node are also binary search trees, i.e., they satisfy condition <code>1.</code> as well.</li> </ol> <p></p>"},{"location":"chapter_tree/binary_search_tree/#operations-on-a-binary-search-tree","title":"Operations on a binary search tree","text":"<p>We encapsulate the binary search tree as a class <code>BinarySearchTree</code> and declare a member variable <code>root</code> pointing to the tree's root node.</p>"},{"location":"chapter_tree/binary_search_tree/#searching-for-a-node","title":"Searching for a node","text":"<p>Given a target node value <code>num</code>, one can search according to the properties of the binary search tree. As shown in the figure below, we declare a node <code>cur</code>, start from the binary tree's root node <code>root</code>, and loop to compare the size between the node value <code>cur.val</code> and <code>num</code>.</p> <ul> <li>If <code>cur.val &lt; num</code>, it means the target node is in <code>cur</code>'s right subtree, thus execute <code>cur = cur.right</code>.</li> <li>If <code>cur.val &gt; num</code>, it means the target node is in <code>cur</code>'s left subtree, thus execute <code>cur = cur.left</code>.</li> <li>If <code>cur.val = num</code>, it means the target node is found, exit the loop, and return the node.</li> </ul> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p>The search operation in a binary search tree works on the same principle as the binary search algorithm, eliminating half of the cases in each round. The number of loops is at most the height of the binary tree. When the binary tree is balanced, it uses \\(O(\\log n)\\) time. The example code is as follows:</p> <pre><code>[file]{binary_search_tree}-[class]{binary_search_tree}-[func]{search}\n</code></pre>"},{"location":"chapter_tree/binary_search_tree/#inserting-a-node","title":"Inserting a node","text":"<p>Given an element <code>num</code> to be inserted, to maintain the property of the binary search tree \"left subtree &lt; root node &lt; right subtree,\" the insertion operation proceeds as shown in the figure below.</p> <ol> <li>Finding insertion position: Similar to the search operation, start from the root node, loop downwards according to the size relationship between the current node value and <code>num</code>, until the leaf node is passed (traversed to <code>None</code>), then exit the loop.</li> <li>Insert the node at this position: Initialize the node <code>num</code> and place it where <code>None</code> was.</li> </ol> <p></p> <p>In the code implementation, note the following two points.</p> <ul> <li>The binary search tree does not allow duplicate nodes to exist; otherwise, its definition would be violated. Therefore, if the node to be inserted already exists in the tree, the insertion is not performed, and the node returns directly.</li> <li>To perform the insertion operation, we need to use the node <code>pre</code> to save the node from the previous loop. This way, when traversing to <code>None</code>, we can get its parent node, thus completing the node insertion operation.</li> </ul> <pre><code>[file]{binary_search_tree}-[class]{binary_search_tree}-[func]{insert}\n</code></pre> <p>Similar to searching for a node, inserting a node uses \\(O(\\log n)\\) time.</p>"},{"location":"chapter_tree/binary_search_tree/#removing-a-node","title":"Removing a node","text":"<p>First, find the target node in the binary tree, then remove it. Similar to inserting a node, we need to ensure that after the removal operation is completed, the property of the binary search tree \"left subtree &lt; root node &lt; right subtree\" is still satisfied. Therefore, based on the number of child nodes of the target node, we divide it into three cases: 0, 1, and 2, and perform the corresponding node removal operations.</p> <p>As shown in the figure below, when the degree of the node to be removed is \\(0\\), it means the node is a leaf node and can be directly removed.</p> <p></p> <p>As shown in the figure below, when the degree of the node to be removed is \\(1\\), replacing the node to be removed with its child node is sufficient.</p> <p></p> <p>When the degree of the node to be removed is \\(2\\), we cannot remove it directly, but need to use a node to replace it. To maintain the property of the binary search tree \"left subtree \\(&lt;\\) root node \\(&lt;\\) right subtree,\" this node can be either the smallest node of the right subtree or the largest node of the left subtree.</p> <p>Assuming we choose the smallest node of the right subtree (the next node in in-order traversal), then the removal operation proceeds as shown in the figure below.</p> <ol> <li>Find the next node in the \"in-order traversal sequence\" of the node to be removed, denoted as <code>tmp</code>.</li> <li>Replace the value of the node to be removed with <code>tmp</code>'s value, and recursively remove the node <code>tmp</code> in the tree.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt; <p></p> <p></p> <p></p> <p></p> <p>The operation of removing a node also uses \\(O(\\log n)\\) time, where finding the node to be removed requires \\(O(\\log n)\\) time, and obtaining the in-order traversal successor node requires \\(O(\\log n)\\) time. Example code is as follows:</p> <pre><code>[file]{binary_search_tree}-[class]{binary_search_tree}-[func]{remove}\n</code></pre>"},{"location":"chapter_tree/binary_search_tree/#in-order-traversal-is-ordered","title":"In-order traversal is ordered","text":"<p>As shown in the figure below, the in-order traversal of a binary tree follows the traversal order of \"left \\(\\rightarrow\\) root \\(\\rightarrow\\) right,\" and a binary search tree satisfies the size relationship of \"left child node \\(&lt;\\) root node \\(&lt;\\) right child node.\"</p> <p>This means that when performing in-order traversal in a binary search tree, the next smallest node will always be traversed first, thus leading to an important property: The sequence of in-order traversal in a binary search tree is ascending.</p> <p>Using the ascending property of in-order traversal, obtaining ordered data in a binary search tree requires only \\(O(n)\\) time, without the need for additional sorting operations, which is very efficient.</p> <p></p>"},{"location":"chapter_tree/binary_search_tree/#efficiency-of-binary-search-trees","title":"Efficiency of binary search trees","text":"<p>Given a set of data, we consider using an array or a binary search tree for storage. Observing the table below, the operations on a binary search tree all have logarithmic time complexity, which is stable and efficient. Arrays are more efficient than binary search trees only in scenarios involving frequent additions and infrequent searches or removals.</p> <p> Table  \u00a0 Efficiency comparison between arrays and search trees </p> Unsorted array Binary search tree Search element \\(O(n)\\) \\(O(\\log n)\\) Insert element \\(O(1)\\) \\(O(\\log n)\\) Remove element \\(O(n)\\) \\(O(\\log n)\\) <p>Ideally, the binary search tree is \"balanced,\" allowing any node can be found within \\(\\log n\\) loops.</p> <p>However, if we continuously insert and remove nodes in a binary search tree, it may degenerate into a linked list as shown in the figure below, where the time complexity of various operations also degrades to \\(O(n)\\).</p> <p></p>"},{"location":"chapter_tree/binary_search_tree/#common-applications-of-binary-search-trees","title":"Common applications of binary search trees","text":"<ul> <li>Used as multi-level indexes in systems to implement efficient search, insertion, and removal operations.</li> <li>Serves as the underlying data structure for certain search algorithms.</li> <li>Used to store data streams to maintain their ordered state.</li> </ul>"},{"location":"chapter_tree/binary_tree/","title":"7.1 Binary tree","text":""},{"location":"chapter_tree/binary_tree/#binary-tree","title":"Binary tree","text":"<p>A binary tree is a non-linear data structure that represents the hierarchical relationship between ancestors and descendants and embodies the divide-and-conquer logic of \"splitting into two\". Similar to a linked list, the basic unit of a binary tree is a node, and each node contains a value, a reference to its left child node, and a reference to its right child node.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig <pre><code>class TreeNode:\n    \"\"\"Binary tree node\"\"\"\n    def __init__(self, val: int):\n        self.val: int = val                # Node value\n        self.left: TreeNode | None = None  # Reference to left child node\n        self.right: TreeNode | None = None # Reference to right child node\n</code></pre> <pre><code>/* Binary tree node */\nstruct TreeNode {\n    int val;          // Node value\n    TreeNode *left;   // Pointer to left child node\n    TreeNode *right;  // Pointer to right child node\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    int val;         // Node value\n    TreeNode left;   // Reference to left child node\n    TreeNode right;  // Reference to right child node\n    TreeNode(int x) { val = x; }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode(int? x) {\n    public int? val = x;    // Node value\n    public TreeNode? left;  // Reference to left child node\n    public TreeNode? right; // Reference to right child node\n}\n</code></pre> <pre><code>/* Binary tree node */\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n/* Constructor */\nfunc NewTreeNode(v int) *TreeNode {\n    return &amp;TreeNode{\n        Left:  nil, // Pointer to left child node\n        Right: nil, // Pointer to right child node\n        Val:   v,   // Node value\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    var val: Int // Node value\n    var left: TreeNode? // Reference to left child node\n    var right: TreeNode? // Reference to right child node\n\n    init(x: Int) {\n        val = x\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    val; // Node value\n    left; // Pointer to left child node\n    right; // Pointer to right child node\n    constructor(val, left, right) {\n        this.val = val === undefined ? 0 : val;\n        this.left = left === undefined ? null : left;\n        this.right = right === undefined ? null : right;\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n\n    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n        this.val = val === undefined ? 0 : val; // Node value\n        this.left = left === undefined ? null : left; // Reference to left child node\n        this.right = right === undefined ? null : right; // Reference to right child node\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode {\n  int val;         // Node value\n  TreeNode? left;  // Reference to left child node\n  TreeNode? right; // Reference to right child node\n  TreeNode(this.val, [this.left, this.right]);\n}\n</code></pre> <pre><code>use std::rc::Rc;\nuse std::cell::RefCell;\n\n/* Binary tree node */\nstruct TreeNode {\n    val: i32,                               // Node value\n    left: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,    // Reference to left child node\n    right: Option&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,   // Reference to right child node\n}\n\nimpl TreeNode {\n    /* Constructor */\n    fn new(val: i32) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; {\n        Rc::new(RefCell::new(Self {\n            val,\n            left: None,\n            right: None\n        }))\n    }\n}\n</code></pre> <pre><code>/* Binary tree node */\ntypedef struct TreeNode {\n    int val;                // Node value\n    int height;             // Node height\n    struct TreeNode *left;  // Pointer to left child node\n    struct TreeNode *right; // Pointer to right child node\n} TreeNode;\n\n/* Constructor */\nTreeNode *newTreeNode(int val) {\n    TreeNode *node;\n\n    node = (TreeNode *)malloc(sizeof(TreeNode));\n    node-&gt;val = val;\n    node-&gt;height = 0;\n    node-&gt;left = NULL;\n    node-&gt;right = NULL;\n    return node;\n}\n</code></pre> <pre><code>/* Binary tree node */\nclass TreeNode(val _val: Int) {  // Node value\n    val left: TreeNode? = null   // Reference to left child node\n    val right: TreeNode? = null  // Reference to right child node\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>Each node has two references (pointers), pointing respectively to the left-child node and right-child node. This node is called the parent node of these two child nodes. When given a node of a binary tree, we call the tree formed by this node's left child and all nodes below it the left subtree of this node. Similarly, the right subtree can be defined.</p> <p>In a binary tree, except leaf nodes, all other nodes contain child nodes and non-empty subtrees. As shown in the figure below, if \"Node 2\" is regarded as a parent node, its left and right child nodes are \"Node 4\" and \"Node 5\" respectively. The left subtree is formed by \"Node 4\" and all nodes beneath it, while the right subtree is formed by \"Node 5\" and all nodes beneath it.</p> <p></p>"},{"location":"chapter_tree/binary_tree/#common-terminology-of-binary-trees","title":"Common terminology of binary trees","text":"<p>The commonly used terminology of binary trees is shown in the figure below.</p> <ul> <li>Root node: The node at the top level of a binary tree, which does not have a parent node.</li> <li>Leaf node: A node that does not have any child nodes, with both of its pointers pointing to <code>None</code>.</li> <li>Edge: A line segment that connects two nodes, representing a reference (pointer) between the nodes.</li> <li>The level of a node: It increases from top to bottom, with the root node being at level 1.</li> <li>The degree of a node: The number of child nodes that a node has. In a binary tree, the degree can be 0, 1, or 2.</li> <li>The height of a binary tree: The number of edges from the root node to the farthest leaf node.</li> <li>The depth of a node: The number of edges from the root node to the node.</li> <li>The height of a node: The number of edges from the farthest leaf node to the node.</li> </ul> <p></p> <p>Tip</p> <p>Please note that we usually define \"height\" and \"depth\" as \"the number of edges traversed\", but some questions or textbooks may define them as \"the number of nodes traversed\". In this case, both height and depth need to be incremented by 1.</p>"},{"location":"chapter_tree/binary_tree/#basic-operations-of-binary-trees","title":"Basic operations of binary trees","text":""},{"location":"chapter_tree/binary_tree/#initializing-a-binary-tree","title":"Initializing a binary tree","text":"<p>Similar to a linked list, the initialization of a binary tree involves first creating the nodes and then establishing the references (pointers) between them.</p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_tree.py<pre><code># Initializing a binary tree\n# Initializing nodes\nn1 = TreeNode(val=1)\nn2 = TreeNode(val=2)\nn3 = TreeNode(val=3)\nn4 = TreeNode(val=4)\nn5 = TreeNode(val=5)\n# Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> binary_tree.cpp<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode* n1 = new TreeNode(1);\nTreeNode* n2 = new TreeNode(2);\nTreeNode* n3 = new TreeNode(3);\nTreeNode* n4 = new TreeNode(4);\nTreeNode* n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1-&gt;left = n2;\nn1-&gt;right = n3;\nn2-&gt;left = n4;\nn2-&gt;right = n5;\n</code></pre> binary_tree.java<pre><code>// Initializing nodes\nTreeNode n1 = new TreeNode(1);\nTreeNode n2 = new TreeNode(2);\nTreeNode n3 = new TreeNode(3);\nTreeNode n4 = new TreeNode(4);\nTreeNode n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.cs<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode n1 = new(1);\nTreeNode n2 = new(2);\nTreeNode n3 = new(3);\nTreeNode n4 = new(4);\nTreeNode n5 = new(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.go<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nn1 := NewTreeNode(1)\nn2 := NewTreeNode(2)\nn3 := NewTreeNode(3)\nn4 := NewTreeNode(4)\nn5 := NewTreeNode(5)\n// Linking references (pointers) between nodes\nn1.Left = n2\nn1.Right = n3\nn2.Left = n4\nn2.Right = n5\n</code></pre> binary_tree.swift<pre><code>// Initializing nodes\nlet n1 = TreeNode(x: 1)\nlet n2 = TreeNode(x: 2)\nlet n3 = TreeNode(x: 3)\nlet n4 = TreeNode(x: 4)\nlet n5 = TreeNode(x: 5)\n// Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> binary_tree.js<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nlet n1 = new TreeNode(1),\n    n2 = new TreeNode(2),\n    n3 = new TreeNode(3),\n    n4 = new TreeNode(4),\n    n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.ts<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nlet n1 = new TreeNode(1),\n    n2 = new TreeNode(2),\n    n3 = new TreeNode(3),\n    n4 = new TreeNode(4),\n    n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.dart<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode n1 = new TreeNode(1);\nTreeNode n2 = new TreeNode(2);\nTreeNode n3 = new TreeNode(3);\nTreeNode n4 = new TreeNode(4);\nTreeNode n5 = new TreeNode(5);\n// Linking references (pointers) between nodes\nn1.left = n2;\nn1.right = n3;\nn2.left = n4;\nn2.right = n5;\n</code></pre> binary_tree.rs<pre><code>// Initializing nodes\nlet n1 = TreeNode::new(1);\nlet n2 = TreeNode::new(2);\nlet n3 = TreeNode::new(3);\nlet n4 = TreeNode::new(4);\nlet n5 = TreeNode::new(5);\n// Linking references (pointers) between nodes\nn1.borrow_mut().left = Some(n2.clone());\nn1.borrow_mut().right = Some(n3);\nn2.borrow_mut().left = Some(n4);\nn2.borrow_mut().right = Some(n5);\n</code></pre> binary_tree.c<pre><code>/* Initializing a binary tree */\n// Initializing nodes\nTreeNode *n1 = newTreeNode(1);\nTreeNode *n2 = newTreeNode(2);\nTreeNode *n3 = newTreeNode(3);\nTreeNode *n4 = newTreeNode(4);\nTreeNode *n5 = newTreeNode(5);\n// Linking references (pointers) between nodes\nn1-&gt;left = n2;\nn1-&gt;right = n3;\nn2-&gt;left = n4;\nn2-&gt;right = n5;\n</code></pre> binary_tree.kt<pre><code>// Initializing nodes\nval n1 = TreeNode(1)\nval n2 = TreeNode(2)\nval n3 = TreeNode(3)\nval n4 = TreeNode(4)\nval n5 = TreeNode(5)\n// Linking references (pointers) between nodes\nn1.left = n2\nn1.right = n3\nn2.left = n4\nn2.right = n5\n</code></pre> binary_tree.rb<pre><code>\n</code></pre> binary_tree.zig<pre><code>\n</code></pre> Code visualization <p>https://pythontutor.com/render.html#code=class%20TreeNode%3A%0A%20%20%20%20%22%22%22%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E7%B1%BB%22%22%22%0A%20%20%20%20def%20__init__%28self,%20val%3A%20int%29%3A%0A%20%20%20%20%20%20%20%20self.val%3A%20int%20%3D%20val%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E8%8A%82%E7%82%B9%E5%80%BC%0A%20%20%20%20%20%20%20%20self.left%3A%20TreeNode%20%7C%20None%20%3D%20None%20%20%23%20%E5%B7%A6%E5%AD%90%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%20%20%20%20%20%20%20%20self.right%3A%20TreeNode%20%7C%20None%20%3D%20None%20%23%20%E5%8F%B3%E5%AD%90%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E8%8A%82%E7%82%B9%0A%20%20%20%20n1%20%3D%20TreeNode%28val%3D1%29%0A%20%20%20%20n2%20%3D%20TreeNode%28val%3D2%29%0A%20%20%20%20n3%20%3D%20TreeNode%28val%3D3%29%0A%20%20%20%20n4%20%3D%20TreeNode%28val%3D4%29%0A%20%20%20%20n5%20%3D%20TreeNode%28val%3D5%29%0A%20%20%20%20%23%20%E6%9E%84%E5%BB%BA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E6%8C%87%E9%92%88%EF%BC%89%0A%20%20%20%20n1.left%20%3D%20n2%0A%20%20%20%20n1.right%20%3D%20n3%0A%20%20%20%20n2.left%20%3D%20n4%0A%20%20%20%20n2.right%20%3D%20n5&amp;cumulative=false&amp;curInstr=3&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p>"},{"location":"chapter_tree/binary_tree/#inserting-and-removing-nodes","title":"Inserting and removing nodes","text":"<p>Similar to a linked list, inserting and removing nodes in a binary tree can be achieved by modifying pointers. The figure below provides an example.</p> <p></p> PythonC++JavaC#GoSwiftJSTSDartRustCKotlinRubyZig binary_tree.py<pre><code># Inserting and removing nodes\np = TreeNode(0)\n# Inserting node P between n1 -&gt; n2\nn1.left = p\np.left = n2\n# Removing node P\nn1.left = n2\n</code></pre> binary_tree.cpp<pre><code>/* Inserting and removing nodes */\nTreeNode* P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1-&gt;left = P;\nP-&gt;left = n2;\n// Removing node P\nn1-&gt;left = n2;\n</code></pre> binary_tree.java<pre><code>TreeNode P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.cs<pre><code>/* Inserting and removing nodes */\nTreeNode P = new(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.go<pre><code>/* Inserting and removing nodes */\n// Inserting node P between n1 and n2\np := NewTreeNode(0)\nn1.Left = p\np.Left = n2\n// Removing node P\nn1.Left = n2\n</code></pre> binary_tree.swift<pre><code>let P = TreeNode(x: 0)\n// Inserting node P between n1 and n2\nn1.left = P\nP.left = n2\n// Removing node P\nn1.left = n2\n</code></pre> binary_tree.js<pre><code>/* Inserting and removing nodes */\nlet P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.ts<pre><code>/* Inserting and removing nodes */\nconst P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.dart<pre><code>/* Inserting and removing nodes */\nTreeNode P = new TreeNode(0);\n// Inserting node P between n1 and n2\nn1.left = P;\nP.left = n2;\n// Removing node P\nn1.left = n2;\n</code></pre> binary_tree.rs<pre><code>let p = TreeNode::new(0);\n// Inserting node P between n1 and n2\nn1.borrow_mut().left = Some(p.clone());\np.borrow_mut().left = Some(n2.clone());\n// Removing node P\nn1.borrow_mut().left = Some(n2);\n</code></pre> binary_tree.c<pre><code>/* Inserting and removing nodes */\nTreeNode *P = newTreeNode(0);\n// Inserting node P between n1 and n2\nn1-&gt;left = P;\nP-&gt;left = n2;\n// Removing node P\nn1-&gt;left = n2;\n</code></pre> binary_tree.kt<pre><code>val P = TreeNode(0)\n// Inserting node P between n1 and n2\nn1.left = P\nP.left = n2\n// Removing node P\nn1.left = n2\n</code></pre> binary_tree.rb<pre><code>\n</code></pre> binary_tree.zig<pre><code>\n</code></pre> Code visualization <p>https://pythontutor.com/render.html#code=class%20TreeNode%3A%0A%20%20%20%20%22%22%22%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E7%B1%BB%22%22%22%0A%20%20%20%20def%20__init__%28self,%20val%3A%20int%29%3A%0A%20%20%20%20%20%20%20%20self.val%3A%20int%20%3D%20val%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20%E8%8A%82%E7%82%B9%E5%80%BC%0A%20%20%20%20%20%20%20%20self.left%3A%20TreeNode%20%7C%20None%20%3D%20None%20%20%23%20%E5%B7%A6%E5%AD%90%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%20%20%20%20%20%20%20%20self.right%3A%20TreeNode%20%7C%20None%20%3D%20None%20%23%20%E5%8F%B3%E5%AD%90%E8%8A%82%E7%82%B9%E5%BC%95%E7%94%A8%0A%0A%22%22%22Driver%20Code%22%22%22%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%0A%20%20%20%20%23%20%E5%88%9D%E5%A7%8B%E5%8C%96%E8%8A%82%E7%82%B9%0A%20%20%20%20n1%20%3D%20TreeNode%28val%3D1%29%0A%20%20%20%20n2%20%3D%20TreeNode%28val%3D2%29%0A%20%20%20%20n3%20%3D%20TreeNode%28val%3D3%29%0A%20%20%20%20n4%20%3D%20TreeNode%28val%3D4%29%0A%20%20%20%20n5%20%3D%20TreeNode%28val%3D5%29%0A%20%20%20%20%23%20%E6%9E%84%E5%BB%BA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E6%8C%87%E9%92%88%EF%BC%89%0A%20%20%20%20n1.left%20%3D%20n2%0A%20%20%20%20n1.right%20%3D%20n3%0A%20%20%20%20n2.left%20%3D%20n4%0A%20%20%20%20n2.right%20%3D%20n5%0A%0A%20%20%20%20%23%20%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%0A%20%20%20%20p%20%3D%20TreeNode%280%29%0A%20%20%20%20%23%20%E5%9C%A8%20n1%20-%3E%20n2%20%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%20P%0A%20%20%20%20n1.left%20%3D%20p%0A%20%20%20%20p.left%20%3D%20n2%0A%20%20%20%20%23%20%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%20P%0A%20%20%20%20n1.left%20%3D%20n2&amp;cumulative=false&amp;curInstr=37&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=311&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false</p> <p>Tip</p> <p>It should be noted that inserting nodes may change the original logical structure of the binary tree, while removing nodes typically involves removing the node and all its subtrees. Therefore, in a binary tree, insertion and removal are usually performed through a set of operations to achieve meaningful outcomes.</p>"},{"location":"chapter_tree/binary_tree/#common-types-of-binary-trees","title":"Common types of binary trees","text":""},{"location":"chapter_tree/binary_tree/#perfect-binary-tree","title":"Perfect binary tree","text":"<p>As shown in the figure below, in a perfect binary tree, all levels are completely filled with nodes. In a perfect binary tree, leaf nodes have a degree of \\(0\\), while all other nodes have a degree of \\(2\\). The total number of nodes can be calculated as \\(2^{h+1} - 1\\), where \\(h\\) is the height of the tree. This exhibits a standard exponential relationship, reflecting the common phenomenon of cell division in nature.</p> <p>Tip</p> <p>Please note that in the Chinese community, a perfect binary tree is often referred to as a full binary tree.</p> <p></p>"},{"location":"chapter_tree/binary_tree/#complete-binary-tree","title":"Complete binary tree","text":"<p>As shown in the figure below, a complete binary tree is a binary tree where only the bottom level is possibly not completely filled, and nodes at the bottom level must be filled continuously from left to right. Note that a perfect binary tree is also a complete binary tree.</p> <p></p>"},{"location":"chapter_tree/binary_tree/#full-binary-tree","title":"Full binary tree","text":"<p>As shown in the figure below, a full binary tree, except for the leaf nodes, has two child nodes for all other nodes.</p> <p></p>"},{"location":"chapter_tree/binary_tree/#balanced-binary-tree","title":"Balanced binary tree","text":"<p>As shown in the figure below, in a balanced binary tree, the absolute difference between the height of the left and right subtrees of any node does not exceed 1.</p> <p></p>"},{"location":"chapter_tree/binary_tree/#degeneration-of-binary-trees","title":"Degeneration of binary trees","text":"<p>The figure below shows the ideal and degenerate structures of binary trees. A binary tree becomes a \"perfect binary tree\" when every level is filled; while it degenerates into a \"linked list\" when all nodes are biased toward one side.</p> <ul> <li>A perfect binary tree is an ideal scenario where the \"divide and conquer\" advantage of a binary tree can be fully utilized.</li> <li>On the other hand, a linked list represents another extreme where all operations become linear, resulting in a time complexity of \\(O(n)\\).</li> </ul> <p></p> <p>As shown in the table below, in the best and worst structures, the binary tree achieves either maximum or minimum values for leaf node count, total number of nodes, and height.</p> <p> Table  \u00a0 The Best and Worst Structures of Binary Trees </p> Perfect binary tree Linked list Number of nodes at level \\(i\\) \\(2^{i-1}\\) \\(1\\) Number of leaf nodes in a tree with height \\(h\\) \\(2^h\\) \\(1\\) Total number of nodes in a tree with height \\(h\\) \\(2^{h+1} - 1\\) \\(h + 1\\) Height of a tree with \\(n\\) total nodes \\(\\log_2 (n+1) - 1\\) \\(n - 1\\)"},{"location":"chapter_tree/binary_tree_traversal/","title":"7.2 Binary tree traversal","text":""},{"location":"chapter_tree/binary_tree_traversal/#binary-tree-traversal","title":"Binary tree traversal","text":"<p>From a physical structure perspective, a tree is a data structure based on linked lists. Hence, its traversal method involves accessing nodes one by one through pointers. However, a tree is a non-linear data structure, which makes traversing a tree more complex than traversing a linked list, requiring the assistance of search algorithms.</p> <p>The common traversal methods for binary trees include level-order traversal, pre-order traversal, in-order traversal, and post-order traversal.</p>"},{"location":"chapter_tree/binary_tree_traversal/#level-order-traversal","title":"Level-order traversal","text":"<p>As shown in the figure below, level-order traversal traverses the binary tree from top to bottom, layer by layer. Within each level, it visits nodes from left to right.</p> <p>Level-order traversal is essentially a type of  breadth-first traversal, also known as breadth-first search (BFS), which embodies a \"circumferentially outward expanding\" layer-by-layer traversal method.</p> <p></p>"},{"location":"chapter_tree/binary_tree_traversal/#code-implementation","title":"Code implementation","text":"<p>Breadth-first traversal is usually implemented with the help of a \"queue\". The queue follows the \"first in, first out\" rule, while breadth-first traversal follows the \"layer-by-layer progression\" rule, the underlying ideas of the two are consistent. The implementation code is as follows:</p> <pre><code>[file]{binary_tree_bfs}-[class]{}-[func]{level_order}\n</code></pre>"},{"location":"chapter_tree/binary_tree_traversal/#complexity-analysis","title":"Complexity analysis","text":"<ul> <li>Time complexity is \\(O(n)\\): All nodes are visited once, taking \\(O(n)\\) time, where \\(n\\) is the number of nodes.</li> <li>Space complexity is \\(O(n)\\): In the worst case, i.e., a full binary tree, before traversing to the bottom level, the queue can contain at most \\((n + 1) / 2\\) nodes simultaneously, occupying \\(O(n)\\) space.</li> </ul>"},{"location":"chapter_tree/binary_tree_traversal/#preorder-in-order-and-post-order-traversal","title":"Preorder, in-order, and post-order traversal","text":"<p>Correspondingly, pre-order, in-order, and post-order traversal all belong to depth-first traversal, also known as depth-first search (DFS), which embodies a \"proceed to the end first, then backtrack and continue\" traversal method.</p> <p>The figure below shows the working principle of performing a depth-first traversal on a binary tree. Depth-first traversal is like \"walking\" around the entire binary tree, encountering three positions at each node, corresponding to pre-order, in-order, and post-order traversal.</p> <p></p>"},{"location":"chapter_tree/binary_tree_traversal/#code-implementation_1","title":"Code implementation","text":"<p>Depth-first search is usually implemented based on recursion:</p> <pre><code>[file]{binary_tree_dfs}-[class]{}-[func]{post_order}\n</code></pre> <p>Tip</p> <p>Depth-first search can also be implemented based on iteration, interested readers can study this on their own.</p> <p>The figure below shows the recursive process of pre-order traversal of a binary tree, which can be divided into two opposite parts: \"recursion\" and \"return\".</p> <ol> <li>\"Recursion\" means starting a new method, the program accesses the next node in this process.</li> <li>\"Return\" means the function returns, indicating the current node has been fully accessed.</li> </ol> &lt;1&gt;&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;&lt;6&gt;&lt;7&gt;&lt;8&gt;&lt;9&gt;&lt;10&gt;&lt;11&gt; <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"chapter_tree/binary_tree_traversal/#complexity-analysis_1","title":"Complexity analysis","text":"<ul> <li>Time complexity is \\(O(n)\\): All nodes are visited once, using \\(O(n)\\) time.</li> <li>Space complexity is \\(O(n)\\): In the worst case, i.e., the tree degenerates into a linked list, the recursion depth reaches \\(n\\), the system occupies \\(O(n)\\) stack frame space.</li> </ul>"},{"location":"chapter_tree/summary/","title":"7.6 Summary","text":""},{"location":"chapter_tree/summary/#summary","title":"Summary","text":""},{"location":"chapter_tree/summary/#key-review","title":"Key review","text":"<ul> <li>A binary tree is a non-linear data structure that reflects the \"divide and conquer\" logic of splitting one into two. Each binary tree node contains a value and two pointers, which point to its left and right child nodes, respectively.</li> <li>For a node in a binary tree, its left (right) child node and the tree formed below it are collectively called the node's left (right) subtree.</li> <li>Terms related to binary trees include root node, leaf node, level, degree, edge, height, and depth.</li> <li>The operations of initializing a binary tree, inserting nodes, and removing nodes are similar to those of linked list operations.</li> <li>Common types of binary trees include perfect binary trees, complete binary trees, full binary trees, and balanced binary trees. The perfect binary tree represents the ideal state, while the linked list is the worst state after degradation.</li> <li>A binary tree can be represented using an array by arranging the node values and empty slots in a level-order traversal sequence and implementing pointers based on the index mapping relationship between parent nodes and child nodes.</li> <li>The level-order traversal of a binary tree is a breadth-first search method, which reflects a layer-by-layer traversal manner of \"expanding circle by circle.\" It is usually implemented using a queue.</li> <li>Pre-order, in-order, and post-order traversals are all depth-first search methods, reflecting the traversal manner of \"going to the end first, then backtracking to continue.\" They are usually implemented using recursion.</li> <li>A binary search tree is an efficient data structure for element searching, with the time complexity of search, insert, and remove operations all being \\(O(\\log n)\\). When a binary search tree degrades into a linked list, these time complexities deteriorate to \\(O(n)\\).</li> <li>An AVL tree, also known as a balanced binary search tree, ensures that the tree remains balanced after continuous node insertions and removals through rotation operations.</li> <li>Rotation operations in an AVL tree include right rotation, left rotation, right-left rotation, and left-right rotation. After node insertion or removal, the AVL tree rebalances itself by performing these rotations in a bottom-up manner.</li> </ul>"},{"location":"chapter_tree/summary/#q-a","title":"Q &amp; A","text":"<p>Q: For a binary tree with only one node, are both the height of the tree and the depth of the root node \\(0\\)?</p> <p>Yes, because height and depth are typically defined as \"the number of edges passed.\"</p> <p>Q: The insertion and removal in a binary tree are generally accomplished by a set of operations. What does \"a set of operations\" refer to here? Does it imply releasing the resources of the child nodes?</p> <p>Taking the binary search tree as an example, the operation of removing a node needs to be handled in three different scenarios, each requiring multiple steps of node operations.</p> <p>Q: Why are there three sequences: pre-order, in-order, and post-order for DFS traversal of a binary tree, and what are their uses?</p> <p>Similar to sequential and reverse traversal of arrays, pre-order, in-order, and post-order traversals are three methods of traversing a binary tree, allowing us to obtain a traversal result in a specific order. For example, in a binary search tree, since the node sizes satisfy <code>left child node value &lt; root node value &lt; right child node value</code>, we can obtain an ordered node sequence by traversing the tree in the \"left \\(\\rightarrow\\) root \\(\\rightarrow\\) right\" priority.</p> <p>Q: In a right rotation operation that deals with the relationship between the imbalance nodes <code>node</code>, <code>child</code>, <code>grand_child</code>, isn't the connection between <code>node</code> and its parent node and the original link of <code>node</code> lost after the right rotation?</p> <p>We need to view this problem from a recursive perspective. The <code>right_rotate(root)</code> operation passes the root node of the subtree and eventually returns the root node of the rotated subtree with <code>return child</code>. The connection between the subtree's root node and its parent node is established after this function returns, which is outside the scope of the right rotation operation's maintenance.</p> <p>Q: In C++, functions are divided into <code>private</code> and <code>public</code> sections. What considerations are there for this? Why are the <code>height()</code> function and the <code>updateHeight()</code> function placed in <code>public</code> and <code>private</code>, respectively?</p> <p>It depends on the scope of the method's use. If a method is only used within the class, then it is designed to be <code>private</code>. For example, it makes no sense for users to call <code>updateHeight()</code> on their own, as it is just a step in the insertion or removal operations. However, <code>height()</code> is for accessing node height, similar to <code>vector.size()</code>, thus it is set to <code>public</code> for use.</p> <p>Q: How do you build a binary search tree from a set of input data? Is the choice of root node very important?</p> <p>Yes, the method for building the tree is provided in the <code>build_tree()</code> method in the binary search tree code. As for the choice of the root node, we usually sort the input data and then select the middle element as the root node, recursively building the left and right subtrees. This approach maximizes the balance of the tree.</p> <p>Q: In Java, do you always have to use the <code>equals()</code> method for string comparison?</p> <p>In Java, for primitive data types, <code>==</code> is used to compare whether the values of two variables are equal. For reference types, the working principles of the two symbols are different.</p> <ul> <li><code>==</code>: Used to compare whether two variables point to the same object, i.e., whether their positions in memory are the same.</li> <li><code>equals()</code>: Used to compare whether the values of two objects are equal.</li> </ul> <p>Therefore, to compare values, we should use <code>equals()</code>. However, strings initialized with <code>String a = \"hi\"; String b = \"hi\";</code> are stored in the string constant pool and point to the same object, so <code>a == b</code> can also be used to compare the contents of two strings.</p> <p>Q: Before reaching the bottom level, is the number of nodes in the queue \\(2^h\\) in breadth-first traversal?</p> <p>Yes, for example, a full binary tree with height \\(h = 2\\) has a total of \\(n = 7\\) nodes, then the bottom level has \\(4 = 2^h = (n + 1) / 2\\) nodes.</p>"}]}